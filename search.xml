<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合相关面试题</title>
      <link href="/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java常见的集合类"><a href="#1-Java常见的集合类" class="headerlink" title="1 Java常见的集合类"></a>1 Java常见的集合类</h2><h3 id="面试官：说一说Java提供的常见集合？（高频）"><a href="#面试官：说一说Java提供的常见集合？（高频）" class="headerlink" title="面试官：说一说Java提供的常见集合？（高频）"></a><strong>面试官</strong>：说一说Java提供的常见集合？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>在java中提供了量大类的集合框架，主要分为两类：</p><p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p><ul><li>在Collection中有三个子接口List、Set和Queue。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。在Queue接口中有实现类PriorityQueue等。</li><li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的ConcurrentHashMap</li></ul><p>![image-20250303094632756](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250303094632756.png)</p><h3 id="面试官：说说List-Set-Map三者的区别？"><a href="#面试官：说说List-Set-Map三者的区别？" class="headerlink" title="面试官：说说List,Set,Map三者的区别？"></a><strong>面试官</strong>：说说List,Set,Map三者的区别？</h3><p><strong>候选人</strong>：</p><ul><li><p>List (对付顺序的好帮⼿)： 存储的元素是<strong>有序的</strong>、<strong>可重复</strong>的。</p></li><li><p>Set (注重独⼀⽆⼆的性质): 存储的元素是**⽆序的**、<strong>不可重复</strong>的。</p></li><li><p>Map (⽤ Key 来搜索的专家): 使⽤键值对（kye-value）存储，类似于数学上的函数y&#x3D;f(x)，“x”代表 key，”y”代表 value，<strong>Key 是⽆序的、不可重复的</strong>，<strong>value 是⽆序的、可重复的</strong>，每个键最多映射到⼀个值。</p></li></ul><h3 id="面试官：-常见集合的时间复杂度分析"><a href="#面试官：-常见集合的时间复杂度分析" class="headerlink" title="面试官： 常见集合的时间复杂度分析"></a><strong>面试官：</strong> 常见集合的时间复杂度分析</h3><p><strong>候选人</strong>：以下是各种常见数据结构的基本操作时间复杂度的简要概述：</p><h4 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h4><ul><li><strong>访问</strong>：O(1)，因为可以直接通过索引访问。</li><li><strong>插入&#x2F;删除</strong>：平均 O(n)，因为在中间位置插入或删除元素需要移动后续元素。</li><li><strong>搜索</strong>：O(n)，除非数组有序且使用二分查找，否则需要遍历整个数组。</li></ul><h4 id="2-单向链表（Singly-Linked-List）"><a href="#2-单向链表（Singly-Linked-List）" class="headerlink" title="2. 单向链表（Singly Linked List）"></a>2. 单向链表（Singly Linked List）</h4><ul><li><strong>访问</strong>：O(n)，因为需要从头节点开始遍历。</li><li><strong>插入&#x2F;删除</strong>：O(1)，如果已知前驱节点的话；否则需要 O(n) 来找到前驱节点。</li><li><strong>搜索</strong>：O(n)，因为需要遍历链表直到找到目标元素。</li></ul><h4 id="3-双向链表（Doubly-Linked-List）"><a href="#3-双向链表（Doubly-Linked-List）" class="headerlink" title="3. 双向链表（Doubly Linked List）"></a>3. 双向链表（Doubly Linked List）</h4><ul><li><strong>访问</strong>：O(n)，因为也需要从头节点或尾节点开始遍历。</li><li><strong>插入&#x2F;删除</strong>：O(1)，如果已知前驱或后继节点的话；否则需要 O(n) 来找到前驱或后继节点。</li><li><strong>搜索</strong>：O(n)，因为需要遍历链表直到找到目标元素。</li></ul><h4 id="4-二叉搜索树（Binary-Search-Tree）"><a href="#4-二叉搜索树（Binary-Search-Tree）" class="headerlink" title="4. 二叉搜索树（Binary Search Tree）"></a>4. 二叉搜索树（Binary Search Tree）</h4><ul><li><strong>最佳情况（平衡）</strong>：<ul><li><strong>访问&#x2F;搜索</strong>：O(log n)，如果树是平衡的。</li><li><strong>插入&#x2F;删除</strong>：O(log n)，如果树是平衡的。</li></ul></li><li><strong>最坏情况（不平衡）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(n)，如果树退化成链式结构。</li></ul></li></ul><h4 id="5-红黑树（Red-Black-Tree）"><a href="#5-红黑树（Red-Black-Tree）" class="headerlink" title="5. 红黑树（Red-Black Tree）"></a>5. 红黑树（Red-Black Tree）</h4><ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(log n)，因为红黑树是一种自平衡的二叉搜索树，能够保持树的高度较低。</li></ul><h4 id="6-散列表（Hash-Table）"><a href="#6-散列表（Hash-Table）" class="headerlink" title="6. 散列表（Hash Table）"></a>6. 散列表（Hash Table）</h4><ul><li><strong>理想情况（均匀分布）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：平均 O(1)，理想情况下，哈希函数将键均匀分布在哈希表中，减少了冲突。</li></ul></li><li><strong>最坏情况（严重冲突）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(n)，如果哈希函数导致大量冲突，性能退化。</li></ul></li></ul><h2 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h2><h3 id="面试官：ArrayList底层是如何实现的？-jdk1-8源码解析"><a href="#面试官：ArrayList底层是如何实现的？-jdk1-8源码解析" class="headerlink" title="面试官：ArrayList底层是如何实现的？(jdk1.8源码解析)"></a><strong>面试官</strong>：ArrayList底层是如何实现的？(jdk1.8源码解析)</h3><p><strong>候选人</strong>：</p><ol><li>类定义与成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部使用的数组，用于存储元素</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列表的实际大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初识容量为10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认的空数组，用于初始化空的 ArrayList</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空闲数组，用于优化 ArrayList 的行为</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>构造函数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，初始化为空数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始容量的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从 Collection 初始化 ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="comment">// 第一步：确保数组已使用长度（size）加1之后足够存下下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 第三步：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 第四步：返回添加成功布尔值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>获取元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查索引是否合法。</span></span><br><span class="line">    RangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">RangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#面试官：ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="面试官：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a><strong>面试官</strong>：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h3><p><strong>候选人</strong>：</p><p>在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p><h3 id="面试官：说⼀说-ArrayList-的扩容机制吧？"><a href="#面试官：说⼀说-ArrayList-的扩容机制吧？" class="headerlink" title="面试官：说⼀说 ArrayList 的扩容机制吧？"></a><strong>面试官</strong>：说⼀说 ArrayList 的扩容机制吧？</h3><p>**候选人：**在添加元素时会检查当前数组的容量是否足够存放新的元素。如果不足够，则会触发扩容操作。扩容机制主要包括以下几个步骤：</p><ol><li><p><strong>检测容量不足</strong>：当尝试添加新元素时，<code>ArrayList</code> 会先检查当前的容量是否足以容纳新的元素。</p></li><li><p><strong>触发扩容</strong>：如果当前容量不足，则会调用 <code>ensureCapacityInternal</code> 方法来确保有足够的空间。</p></li><li><p><strong>计算新容量</strong>：通常情况下，新容量为当前容量的 1.5 倍。</p></li><li><p><strong>执行扩容</strong>：使用 <code>Arrays.copyOf</code> 方法来创建一个新的数组，并将旧数组的内容拷贝到新数组中。</p></li></ol><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保有足够的容量来存放新的元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将新元素放置在当前 size 的位置，并将 size 增加 1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回添加成功的标志</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果所需的最小容量大于当前数组的长度，则调用 grow 方法</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算新的容量，默认情况下是旧容量的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量仍然小于所需的最小容量，则使用所需的最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量超过最大数组大小，则使用大的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用新的容量创建一个新的数组，并拷贝旧数组的内容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：-为什么数组索引从0开始？"><a href="#面试官：-为什么数组索引从0开始？" class="headerlink" title="面试官： 为什么数组索引从0开始？"></a><strong>面试官：</strong> 为什么数组索引从0开始？</h3><p><strong>候选人：</strong></p><p>在根据数据索引获取元素的时候，会用索引和寻址公式来计算内存中所对应的元素数据。</p><blockquote><p>数组索引从0开始，寻址公式可以简化为：</p><p><strong>arr[i] &#x3D; baseAddress + i * dataTypeSize</strong><br>地址&#x3D;基地址+(索引×元素大小)</p></blockquote><p>如果数组的索引从1开始，寻址公式中就会增加一次减法操作，对CPU来说就多了一条指令，性能不高。</p><blockquote><p>如果索引从1开始，则寻址公式变为：</p><p><em><em>arr[i] &#x3D; baseAddress + (i - 1)</em> dataTypeSize</em>*<br>地址&#x3D;基地址+((索引−1)×元素大小)</p></blockquote><h3 id="面试官：如何实现数组和List之间的转换"><a href="#面试官：如何实现数组和List之间的转换" class="headerlink" title="面试官：如何实现数组和List之间的转换"></a><strong>面试官</strong>：如何实现数组和List之间的转换</h3><p><strong>候选人</strong>：</p><ol><li><p><strong>数组转List</strong>：可以使用 <code>Arrays.asList(T... a)</code> 方法将数组转换为 <code>List</code>。该方法返回一个基于原数组的 <code>List</code>，所以它是一个固定大小的列表，不能进行添加或删除操作，但可以修改元素。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br></pre></td></tr></table></figure></li><li><p><strong>List 转数组</strong>：可以使用 <code>List</code> 的 <code>toArray()</code> 方法将 <code>List</code> 转换为数组。</p><ul><li><strong><code>toArray()</code></strong>：返回一个包含所有 <code>List</code> 元素的数组，但该数组类型是 <code>Object[]</code>，需要类型转换。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>toArray(new String[0])</code> 中的 <code>new String[0]</code> 是为了确保返回的数组类型正确，而不是使用 <code>new String[list.size()]</code>，这样可以避免在一些情况下的性能问题。</p></blockquote></li></ol><h3 id="面试官：用Arrays-asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗"><a href="#面试官：用Arrays-asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗" class="headerlink" title="面试官：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗"></a><strong>面试官</strong>：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗</h3><p><strong>候选人</strong>：</p><ul><li><strong>Arrays.asList</strong> 转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是<strong>同一个内存地址</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] array = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改数组的元素</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;List: &quot;</span> + list); <span class="comment">// 输出 List: [X, B, C]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Array: &quot;</span> + Arrays.toString(array)); <span class="comment">// 输出 Array: [X, B, C]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list用了 <strong>toArray</strong> 转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了<strong>数组的拷贝</strong>，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 toArray 方法转换为数组</span></span><br><span class="line">        String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 List</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;List: &quot;</span> + list); <span class="comment">// 输出 List: [X, B, C]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Array: &quot;</span> + Arrays.toString(array)); <span class="comment">// 输出 Array: [A, B, C]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：ArrayList-和-LinkedList-的区别是什么？（高频）"><a href="#面试官：ArrayList-和-LinkedList-的区别是什么？（高频）" class="headerlink" title="面试官：ArrayList 和 LinkedList 的区别是什么？（高频）"></a><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ol><li><p><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>底层数据结构：</strong> Arraylist 底层使⽤的是 <strong>Object</strong> <strong>数组</strong>； LinkedList 底层使⽤的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</p></li><li><p><strong>插⼊和删除是否受元素位置的影响：</strong> ① <strong>ArrayList</strong> <strong>采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。</strong> ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置插⼊和删除元素的话时间复杂度就为 O(n)。②<strong>LinkedList</strong> <strong>采⽤链表存储，所以对于</strong> <strong>add(E e)</strong> <strong>⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似O(1)</strong>，如果是要在指定位置插⼊和删除元素的话（ (add(int index, Eelement) ） 时间复杂度近似为o(n)。</p></li><li><p><strong>是否⽀持快速随机访问：</strong> LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。（数组天然⽀持随机访问，时间复杂度为 <strong>O(1)</strong>，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 <strong>O(n)</strong>，所以不⽀持快速随机访问。）</p></li><li><p><strong>内存空间占⽤：</strong> ArrayList 底层是数组，内存连续，节省内存；LinkedList 是双向链表需要存储数据和两个指针，更占用内存。</p></li><li><p>**应用场景：**访问频繁选数组，插删频繁选链表。</p></li></ol><blockquote><p>补充：<strong>双向链表和双向循环链表</strong></p><p><strong>双向链表：</strong> 包含两个指针，⼀个 prev 指向前⼀个节点，⼀个 next 指向后⼀个节点。</p><p>![image-20250218112654847](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112654847.png)</p><p><strong>双向循环链表：</strong> 最后⼀个节点的 next 指向 head，⽽ head 的 prev 指向最后⼀个节点，构成⼀个环。</p><p>![image-20250218112704475](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112704475.png)</p></blockquote><blockquote><p>补充：<strong>RandomAccess接⼝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接⼝中什么都没有定义。所以，在我看来<code>RandomAccess</code> 接⼝不过是⼀个标识罢了。标识什么？ 标识实现这个接⼝的类具有随机访问功能。ArrayList 实现了 <code>RandomAccess</code> 接⼝，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接⼝只是标识，<strong>并不是说 ArrayList实现 RandomAccess 接⼝才具有快速随机访问功能的！</strong></p></blockquote><h3 id="面试官：-ArrayList-与-Vector-区别？"><a href="#面试官：-ArrayList-与-Vector-区别？" class="headerlink" title="面试官：  ArrayList 与 Vector 区别？"></a><strong>面试官：</strong>  ArrayList 与 Vector 区别？</h3><p><strong>候选人：</strong></p><p>• <strong>线程安全性:</strong> Vector是线程安全的，ArrayList不是线程安全的。</p><p>• <strong>扩容策略:</strong> ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</p><blockquote><p>ArrayList和Vector都支持动态扩容，都属于动态数组。</p></blockquote><h3 id="面试官：刚才你说了ArrayList-和-LinkedList-不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？"><a href="#面试官：刚才你说了ArrayList-和-LinkedList-不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？" class="headerlink" title="面试官：刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？"></a><strong>面试官</strong>：刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</h3><p><strong>候选人</strong>：</p><p>主要有两种解决方案：</p><p>第一：我们使用这个集合，优先在方法内使用，定义为<strong>局部变量</strong>，且不能逃离方法的作用范围。这样的话，就不会出现线程安全问题。</p><p>第二：如果非要在成员变量中使用的话，可以使用<strong>线程安全的集合</strong>来替代</p><ul><li><p>ArrayList可以通过Collections 的 <strong>synchronizedList</strong> 方法将 ArrayList 转换成线程安全的容器后再使用。</p></li><li><p>LinkedList 换成<strong>ConcurrentLinkedQueue</strong>来使用</p></li></ul><h2 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3 HashMap"></a>3 HashMap</h2><h3 id="前提知识：红黑树和二叉搜索树（Binary-Search-Tree-BST）"><a href="#前提知识：红黑树和二叉搜索树（Binary-Search-Tree-BST）" class="headerlink" title="前提知识：红黑树和二叉搜索树（Binary Search Tree,BST）"></a>前提知识：红黑树和二叉搜索树（Binary Search Tree,BST）</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型。</p><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p><p>![image-20250218112825681](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112825681.png)</p><h4 id="红黑树（高频）"><a href="#红黑树（高频）" class="headerlink" title="红黑树（高频）"></a>红黑树<code>（高频）</code></h4><p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）。</p><p>![image-20250218112839568](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112839568.png)</p><p>（2）红黑树的特质</p><p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p><p>性质2：根节点是<strong>黑色</strong></p><p>性质3：叶子节点都是黑色的空节点</p><p>性质4：红黑树中红色节点的子节点都是黑色</p><p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p><p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong>。</p><h3 id="面试官：说一下HashMap的实现原理？"><a href="#面试官：说一下HashMap的实现原理？" class="headerlink" title="面试官：说一下HashMap的实现原理？"></a><strong>面试官</strong>：说一下HashMap的实现原理？</h3><p><strong>候选人</strong>：</p><p>1，底层使用hash表数据结构，即<strong>数组 + 链表 &#x2F; 红黑树</strong>。</p><p>2，添加数据时，计算key的值确定元素在数组中的下标。</p><ul><li><p>key相同则替换</p></li><li><p>不同则存入链表或红黑树中</p></li></ul><p>3，获取数据通过key的hash计算数组下标获取元素。</p><h3 id="面试官：HashMap的jdk1-7和jdk1-8有什么区别（高频）"><a href="#面试官：HashMap的jdk1-7和jdk1-8有什么区别（高频）" class="headerlink" title="面试官：HashMap的jdk1.7和jdk1.8有什么区别（高频）"></a><strong>面试官</strong>：HashMap的jdk1.7和jdk1.8有什么区别<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ul><li><p>JDK1.7采用的是拉链法，<strong>数组+链表</strong>。在扩容时使用**“头插法”<strong>插入新元素。这种方式会导致链表顺序反转，在多线程环境下，可能引发环形链表问题，导致程序死循环。扩容是</strong>“先扩容后插入”**，无论是否发生哈希冲突，都会执行扩容操作，可能导致无效扩容。</p></li><li><p>JDK1.8之后采用<strong>数组+链表+红黑树</strong>，链表长度大于8且数组长度大于64则会从链表转化为红黑树。改为**“尾插法”<strong>插入，保证链表顺序一致，避免了扩容中的死循环问题。扩容变为</strong>“先插入再扩容”**，只有当插入后超过阈值或发生哈希冲突时，才会触发扩容，减少了不必要的操作。</p></li></ul><blockquote><p>补充：什么是拉链法？</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建⼀个链表数组，数组中每⼀格就是⼀个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></blockquote><blockquote><p>jdk1.8 中将链表改造红黑树还有一个非常重要的原因，可以防止DDos攻击。</p><p><strong>DDos 攻击</strong>：分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS）</p><p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个。</p></blockquote><h3 id="面试官：知道hashmap在1-7情况下的多线程死循环问题吗？"><a href="#面试官：知道hashmap在1-7情况下的多线程死循环问题吗？" class="headerlink" title="面试官：知道hashmap在1.7情况下的多线程死循环问题吗？"></a><strong>面试官</strong>：知道hashmap在1.7情况下的多线程死循环问题吗？</h3><p><strong>候选人</strong>：</p><h4 id="Java-1-7-中的死循环问题"><a href="#Java-1-7-中的死循环问题" class="headerlink" title="Java 1.7 中的死循环问题"></a>Java 1.7 中的死循环问题</h4><p>在Java 1.7中，<code>HashMap</code>采用的是“头插法”进行扩容。这意味着在扩容时，旧数组中的元素会根据新的索引位置被插入到新数组对应的链表头部。当两个或更多的线程几乎同时进行扩容操作时，可能会导致如下情形：</p><ol><li><strong>线程一读取并开始扩容</strong>：假设线程一开始读取<code>HashMap</code>并准备进行扩容。此时，它读取到了某个链表，该链表包含节点A和节点B（顺序为A -&gt; B）。</li><li><strong>线程二介入并完成扩容</strong>：在线程一还没有完成扩容之前，线程二也开始了扩容操作。线程二按照头插法将节点A和节点B重新插入新数组中的对应位置，但是顺序变成了B -&gt; A（因为A先插入，然后B插入到A的前面）。</li><li><strong>线程一继续执行</strong>：当线程一恢复执行时，它尝试将节点A插入新数组中的对应位置。按照头插法，它会将A插入到链表的头部。然而，此时节点B已经在链表的头部，并且B的<code>next</code>已经指向了A。因此，当线程一将A插入时，A的<code>next</code>又指向了B，这就形成了一个循环链表（A -&gt; B -&gt; A）。</li></ol><h4 id="解决方法：Java-1-8-的尾插法"><a href="#解决方法：Java-1-8-的尾插法" class="headerlink" title="解决方法：Java 1.8 的尾插法"></a>解决方法：Java 1.8 的尾插法</h4><p>Java 1.8中的<code>HashMap</code>采用了“尾插法”，而不是头插法来进行扩容。这意味着在扩容时，元素会插入到链表的末尾，而不是头部。这样做的好处在于，即使多个线程几乎同时进行扩容，也不会改变链表原有的顺序，从而避免了循环链表的产生。</p><h3 id="面试官：说下HashMap中put方法的具体流程（高频）"><a href="#面试官：说下HashMap中put方法的具体流程（高频）" class="headerlink" title="面试官：说下HashMap中put方法的具体流程（高频）"></a><strong>面试官</strong>：说下HashMap中put方法的具体流程<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>![image-20250218112948771](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112948771.png)</p><ul><li>首先判断键值对数组table是否为空，如果为空则执行resize()进行扩容（初始化长度为16的数组）</li><li>如果不为空则根据key计算hash值，得到数组的索引</li><li>判断该索引位置是否为空，如果为空直接<strong>插入</strong>即可，否则进行后续操作</li><li>判断当前索引位置上的key是否与要插入元素的key相同（是否存在），存在相同的话直接<strong>覆盖value</strong>就可以了</li><li>不相同的话判断该位置是否为红黑树，如果是红黑树，则直接在树中<strong>插入</strong>键值对即可</li><li>如果不是的话就要遍历链表，判断该位置的key是否存在，如果存在相同的直接<strong>覆盖value</strong>即可</li><li>如果不相同的话就使用尾插法，并判断链表长度是否大于8，大于8的话把链表转换为红黑树，走红黑树<strong>插入</strong>的逻辑</li><li>最后一步，就是在以上所有涉及到插入的操作中，判断<strong>实际存在的键值对数量size</strong>（也就是++size）是否超出了最大容量threshold，如果超过，就进行扩容。</li></ul><p>添加元素的时候至少考虑三种情况：</p><blockquote><ol><li>数组位置为null</li><li>数组位置不为null，键重复，元素覆盖</li><li>数组位置不为null，键不重复，挂在下面形成链表或者红黑树</li></ol></blockquote><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//参数一：键</span></span><br><span class="line">    <span class="comment">//参数二：值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值：被覆盖元素的值，如果没有覆盖，返回null</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用键计算出对应的哈希值，再把哈希值进行一些额外的处理</span></span><br><span class="line"><span class="comment">//简单理解：返回值就是返回键的哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个局部变量，用来记录哈希表中数组的地址值。</span></span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="comment">//临时的第三方变量，用来记录键值对对象的地址值</span></span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="comment">//表示当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//表示索引</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//把哈希表中数组的地址值，赋值给局部变量tab</span></span><br><span class="line">    tab = table;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//1.如果当前是第一次添加数据，底层会创建一个默认长度为16，加载因子为0.75的数组</span></span><br><span class="line">        <span class="comment">//2.如果不是第一次添加数据，会看数组中的元素是否达到了扩容的条件</span></span><br><span class="line">        <span class="comment">//如果没有达到扩容条件，底层不会做任何操作</span></span><br><span class="line">        <span class="comment">//如果达到了扩容条件，底层会把数组扩容为原先的两倍，并把数据全部转移到新的哈希表中</span></span><br><span class="line">        tab = resize();</span><br><span class="line">        <span class="comment">//表示把当前数组的长度赋值给n</span></span><br><span class="line">        n = tab.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿着数组的长度跟键的哈希值进行计算，计算出当前键值对对象，在数组中应存入的位置</span></span><br><span class="line">    i = (n - <span class="number">1</span>) &amp; hash;   <span class="comment">//index</span></span><br><span class="line">    <span class="comment">//获取数组中对应元素的数据</span></span><br><span class="line">    p = tab[i];</span><br><span class="line">    <span class="comment">//判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//等号的左边：数组中键值对的哈希值</span></span><br><span class="line">        <span class="comment">//等号的右边：当前要添加键值对的哈希值</span></span><br><span class="line">        <span class="comment">//如果键不一样，此时返回false</span></span><br><span class="line">        <span class="comment">//如果键一样，返回true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> p.hash == hash;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (b1 &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            <span class="comment">//判断数组中获取出来的键值对是不是红黑树中的节点</span></span><br><span class="line">            <span class="comment">//如果是，则调用方法putTreeVal，把当前的节点按照红黑树的规则添加到树当中。</span></span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果从数组中获取出来的键值对不是红黑树中的节点</span></span><br><span class="line">            <span class="comment">//表示此时下面挂的是链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//判断当前链表长度是否超过8，如果超过8，就会调用方法treeifyBin</span></span><br><span class="line">                    <span class="comment">//treeifyBin方法的底层还会继续判断:判断数组的长度是否大于等于64</span></span><br><span class="line">                    <span class="comment">//如果同时满足这两个条件，就会把这个链表转成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为覆盖操作</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                    p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出旧值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//threshold：记录的就是数组的长度 * 0.75，哈希表的扩容时机  16 * 0.75 = 12</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//表示当前没有覆盖任何元素，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：讲一讲HashMap的扩容机制（高频）"><a href="#面试官：讲一讲HashMap的扩容机制（高频）" class="headerlink" title="面试官：讲一讲HashMap的扩容机制（高频）"></a><strong>面试官</strong>：讲一讲HashMap的扩容机制<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/29843beb4a42651eaf128ed6fc316417.jpeg" alt="请添加图片描述"></p><ul><li>在添加元素或初始化的时候需要调用resize()方法进行扩容，第一次添加数据初始化数组长度为16，以后每次扩容都是达到了扩容阈值（数组长度 * 0.75）</li></ul><blockquote><p>扩容阈值 &#x3D; 数组容量 * 加载因子（默认为0.75）</p><p>负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。</p></blockquote><ul><li><p>每次扩容的时候，都是扩容之前容量的2倍； </p></li><li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p></li><li><p>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p></li><li><p>有冲突节点的话，如果是红黑树，就走红黑树的添加</p></li><li><p>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ul><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？"><a href="#面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？"></a><strong>面试官</strong>：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？</h3><p><strong>候选人</strong>：JDK 1.8 的 hash ⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二次哈希：首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p><p>在putValue的方法中，计算数组下标的时候使用<strong>hash值与数组长度取模</strong>得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了<strong>数组长度-1</strong> 得到一个值，用这个值按位<strong>与运算</strong>hash值，最终得到数组的位置。（也就是说 **hash%length&#x3D;&#x3D;hash&amp;(length-1)**的前提是 length 是2的 <strong>n</strong> <strong>次⽅）<strong>并且采⽤⼆进制位操作 &amp;，相对于 % 能够提⾼运算效率，这就解释了</strong>HashMap</strong> <strong>的⻓度为什么是2的幂次⽅。</strong></p><h3 id="面试官：好的，hashmap是线程安全的吗？"><a href="#面试官：好的，hashmap是线程安全的吗？" class="headerlink" title="面试官：好的，hashmap是线程安全的吗？"></a><strong>面试官</strong>：好的，hashmap是线程安全的吗？</h3><p><strong>候选人</strong>：不是线程安全的</p><h3 id="面试官：那我们想要使用线程安全的map该怎么做呢？"><a href="#面试官：那我们想要使用线程安全的map该怎么做呢？" class="headerlink" title="面试官：那我们想要使用线程安全的map该怎么做呢？"></a><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</h3><p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p><h3 id="面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）"><a href="#面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）" class="headerlink" title="面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）"></a><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？<code>（高频）</code></h3><blockquote><p>《Java并发编程的艺术》 6.1.1 为什么要使用 ConcurrentHashMap?</p><p>在并发编程中使用 HashMap 可能导致程序死循环。而使用线程安全的 HashTable 效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap 的登场机会。</p><p>（1）线程不安全的HashMap</p><p>在多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近100%，所以在并发情况下不能使用 HashMap。HashMap 在并发执行 put 操作时会引起死循环，是因为多线程会导致 HashMap 的 Entry 链表形成<strong>环形数据结构</strong>，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取 Entry。</p><p>（2）效率低下的HashTable（一锁就锁全表）</p><p>HashTable 容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable 的效率非常低下。因为当一个线程访问HashTable 的同步方法，其他线程也访问HashTable 的同步方法时，会进入阻塞或轮询状态。如线程1使用 put 进行元素添加，线程2 不但不能使用 put 方法添加元素，也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p><p>（3）ConcurrentHashMap 的锁分段技术可有效提升并发访问率</p><p>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap 所使用的锁分段技术。</p></blockquote><p><strong>候选人</strong>：ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong>。</li></ul><p>在jdk1.7中ConcurrentHashMap 是由Segment 数组结构和HashEntry数组结构组成。Segment 是一种可重入锁(类似ReentrantLock)，扮演锁的⻆⾊。HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个Segment数组。一个Segment 里包含一个 HashEntry 数组，<strong>每个 HashEntry 是一个链表结构的元素</strong>，每个 Segment 守护着一个 HashEntry 数组，当对 HashEntry 数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p><p>![image-20250218113808758](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218113808758.png)</p><p>在jdk1.8中ConcurrentHashMap 取消了 Segment 分段锁，采⽤ <strong>CAS 和 synchronized</strong> 来保证并发安全。虽然 <code>CAS</code> 能保证<strong>单个变量</strong>的原子更新，但在 <strong>多个变量关联修改</strong> 时，就会产生<strong>ABA 问题</strong>或 <strong>自旋失败问题</strong>，因此 JDK 1.8 <code>ConcurrentHashMap</code> 仍然<strong>结合 <code>synchronized</code></strong> 来保证更复杂场景的安全。</p><blockquote><p>ABA 问题是 <strong>CAS（Compare-And-Swap）</strong> 机制中的一种特殊并发问题，指的是：<br><strong>某个变量的值从 A 变为 B，然后又变回 A，CAS 机制无法察觉这个变化，从而导致错误的结果。</strong></p><p>在 <strong>高并发环境</strong> 下，如果线程在 CAS 操作时仅仅判断值是否相等，而不检查是否发生过中间修改，就可能出现 ABA 问题。</p></blockquote><h3 id="面试官：说说ConcurrentHashMap的get、put、size操作"><a href="#面试官：说说ConcurrentHashMap的get、put、size操作" class="headerlink" title="面试官：说说ConcurrentHashMap的get、put、size操作"></a><strong>面试官</strong>：说说ConcurrentHashMap的get、put、size操作</h3><p><strong>候选人</strong>：（源自《Java并发编程的艺术》 6.1.5节）</p><p><strong>get操作：</strong></p><p>先经过一次散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key.hashcode());</span><br><span class="line">  <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。我们知道 HashTable 容器的 get 方法是需要加锁的，那么 <strong>ConcurrentHashMap 的 get 操作是如何做到不加锁</strong>的呢？原因是它的 get方法里将要使用的共享变量都定义成 <strong>volatile</strong> 类型。定义成 volatile 的变量，能够在线程之间保持可见性，<strong>能够被多线程同时读，并且保证不会读到过期的值</strong>，但是只能被单线程写(有一种情况可以被多线程写，就是写入的值不依赖于原值)，在get操作里只需要读不需要写共享变量 count 和 value，所以可以不用加锁。之所以不会读到过期的值，是因为根据 <strong>Java 内存模型的 happens-before 原则</strong>，对 volatile 字段的写入操作先于读操作，即使两个线程同时修改和获取 volatile 变量，get操作也能拿到最新的值，这是用 volatile替换锁的经典应用场景。</p><p><strong>put操作：</strong></p><p>由于 put 方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放在 HashEnty 数组里。</p><p>1）是否需要扩容</p><p>在插入元素前会先判断Segment 里的 HashEnty数组是否超过容量(threshold)，如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比 HashMap 更恰当，因为 HashMap 是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，可能扩容之后没有新元素插入，这时 HashMap 就进行了一次无效的扩容。</p><p>2）如何扩容</p><p>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个 Segment 进行扩容。</p><p><strong>size 操作：</strong></p><p>如果要统计整个 ConcurrentHashMap 里元素的大小，就必须统计所有 Segment 里元素的大小后求和。Segment里的全局变量 count 是一个 volatile 变量，那么在多线程场景下，是不是直接把所有 Segment 的 count 相加就可以得到整个 ConcurrentHashMap 大小了呢? 不是的，虽然相加时可以获取每个 Segment 的 count 的最新值，但是可能累加前使用的 count 发生了变化，那么统计结果就不准了。所以，最安全的做法是在统计size的时候把所有Segment 的put、remove 和 clean 方法全部锁住，但是这种做法显然非常低效。</p><p>因为在累加 count 操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap 的做法是<strong>尝试2次</strong>：通过不锁住Segment的方式来统计各个Segment大小；如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment 的大小。</p><p>那么 ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢?使用modCount 变量，在 put、remove 和 clean 方法里操作元素前都会将变量 modCount 进行加1.那么在统计 size 前后比较 modCount 是否发生变化，从而得知容器的大小是否发生变化。</p><h3 id="面试官：ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#面试官：ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="面试官：ConcurrentHashMap用了悲观锁还是乐观锁?"></a><strong>面试官</strong>：ConcurrentHashMap用了悲观锁还是乐观锁?</h3><p><strong>候选人</strong>：悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空:</p><p>• 如果为空则使用 <code>volatile + CAS (乐观锁)</code> 来初始化。</p><p>• 如果容器不为空，则根据存储的元素计算该位置是否为空。</p><p>•如果根据存储的元素计算结果为空，则利用<code>CAS(乐观锁)</code> 设置该节点;</p><p>• 如果根据存储的元素计算结果不为空，则使用 synchronized(悲观锁)，然后遍历桶中的数据并替换或新增节点到桶中，最后再判断是否需要转为红黑树,这样就能保证并发访问时的线程安全了。</p><h3 id="面试官：HashSet与HashMap的区别？"><a href="#面试官：HashSet与HashMap的区别？" class="headerlink" title="面试官：HashSet与HashMap的区别？"></a><strong>面试官</strong>：HashSet与HashMap的区别？</h3><p><strong>候选人</strong>：HashSet 底层就是基于 HashMap 实现的。</p><p>![image-20250218113836389](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218113836389.png)</p><h3 id="面试官：HashTable与HashMap的区别"><a href="#面试官：HashTable与HashMap的区别" class="headerlink" title="面试官：HashTable与HashMap的区别"></a><strong>面试官</strong>：HashTable与HashMap的区别</h3><p><strong>候选人</strong>：</p><table><thead><tr><th align="center"><strong>区别</strong></th><th align="center"><strong>HashTable</strong></th><th align="center"><strong>HashMap</strong></th></tr></thead><tbody><tr><td align="center">数据结构</td><td align="center">数组+链表</td><td align="center">数组+链表+红黑树</td></tr><tr><td align="center">是否可以为null</td><td align="center">Key和value都不能为null</td><td align="center">可以为null</td></tr><tr><td align="center">hash算法</td><td align="center">key的hashCode()</td><td align="center">二次hash</td></tr><tr><td align="center">扩容方式</td><td align="center">当前容量翻倍 +1（2n + 1）</td><td align="center">当前容量翻倍(2n)</td></tr><tr><td align="center">线程安全</td><td align="center">同步(synchronized)的，线程安全</td><td align="center">非线程安全</td></tr></tbody></table><p>在实际开发中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE相关面试题</title>
      <link href="/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）"><a href="#面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）" class="headerlink" title="面试官： 面向对象(OOP)和面向过程(POP)的区别（高频）"></a><strong>面试官</strong>： 面向对象(OOP)和面向过程(POP)的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>⾯向过程</strong> ：<strong>⾯向过程性能⽐⾯向对象⾼。</strong> ⽐如单⽚机、嵌⼊式开发、Linux&#x2F;Unix 等⼀般采⽤⾯向过程开发。以函数为中心，强调逻辑流程。</p></li><li><p><strong>⾯向对象</strong> ：<strong>⾯向对象易维护、易复⽤、易扩展。</strong> 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>⾯向对象性能⽐⾯向过程低</strong>。以对象为中心，强调数据和行为的封装。</p></li></ul><blockquote><p>拓展：为什么⾯向过程性能⽐⾯向对象⾼？</p><p>⾯向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是⾯向对象语⾔，⽽是 Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的⼆进制机械码。⽽⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏。</p></blockquote><h3 id="面试官：Java的基本数据类型"><a href="#面试官：Java的基本数据类型" class="headerlink" title="面试官：Java的基本数据类型"></a><strong>面试官</strong>：Java的基本数据类型</h3><p><strong>候选人：</strong> Java 语言一共提供了八种原始的数据类型(byte、short、int、long、float、double、char、boolean)。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png" alt="img"></p><p>以上这些基本类型可以分为如下三种类型：</p><p>1）数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</p><p>2）字符型：char</p><p>3）布尔型：boolean</p><p>8种基本数据类型的默认值、位数、取值范围，如下表所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="img"></p><h3 id="面试官：说说JVM-、-JDK-和-JRE的区别？"><a href="#面试官：说说JVM-、-JDK-和-JRE的区别？" class="headerlink" title="面试官：说说JVM 、 JDK 和 JRE的区别？"></a><strong>面试官</strong>：说说JVM 、 JDK 和 JRE的区别？</h3><p><strong>候选人：</strong></p><ul><li><strong>Java Virtual Machine（JVM）</strong> 是运⾏ Java 字节码的虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li></ul><blockquote><p>拓展：什么是字节码?采⽤字节码的好处是什么?</p><p>在 Java 中，JVM 可以理解的代码就叫做  （即扩展名为 .class 的⽂件），它<strong>不⾯向任何特定的处理器，只⾯向虚拟机</strong>。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔<strong>执⾏效率低</strong>的问题，同时⼜保留了解释型语⾔<strong>可移植</strong>的特点。</p></blockquote><ul><li><strong>Java Runtime Environment（JRE）</strong> 包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包。</li><li><strong>Java Development Kit（JDK）</strong> 是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed34206201fcfe5a01689c30e3113972.png" alt="img"></p><h3 id="面试官：Java-程序从源代码到运⾏分为哪几步？"><a href="#面试官：Java-程序从源代码到运⾏分为哪几步？" class="headerlink" title="面试官：Java 程序从源代码到运⾏分为哪几步？"></a><strong>面试官</strong>：Java 程序从源代码到运⾏分为哪几步？</h3><p><strong>候选人：</strong> Java程序从源代码到运⾏⼀般有下⾯3步：</p><p>![image-20250218110538905](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110538905.png)</p><p>我们需要格外注意的是 <strong>.class-&gt;机器码</strong> 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过解释器逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的<strong>热点代码</strong>)，所以后⾯引进了 <strong>JIT 编译器</strong>，⽽ JIT 属于<strong>运⾏时编译</strong>。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。这也解释了我们为什么经常会说 Java 是编译与解释共存的语⾔。</p><h3 id="面试官：Java和C-的区别"><a href="#面试官：Java和C-的区别" class="headerlink" title="面试官：Java和C++的区别"></a><strong>面试官</strong>：Java和C++的区别</h3><p><strong>候选人：</strong></p><ul><li>都是面向对象的语言，都支持封装、继承和多态。</li><li>Java不提供指针来直接访问内存，程序内存更加安全。</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以有多个实现类。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存。</li><li>在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符‘\0’来表示结束。但是，Java 语⾔中没有结束符这⼀概念。</li></ul><blockquote><p>深度思考：</p><p>在C语言中，字符串是以空字符（’\0’）结尾的字符数组。这种设计的好处是简单直接，但缺点是在访问字符串时每次都需要检查空字符来确定字符串的长度，这可能会导致额外的计算开销。在Java中，字符串是一个类（<code>String</code>），它包含了字符串的值以及其长度信息。这种设计使得字符串的长度可以在创建时确定，并且可以通过内置的方法（如<code>length()</code>）轻松获取。这种方法提高了效率，减少了因字符串处理不当而导致的安全隐患。</p></blockquote><h3 id="面试官：-什么是序列化-什么是反序列化"><a href="#面试官：-什么是序列化-什么是反序列化" class="headerlink" title="面试官： 什么是序列化?什么是反序列化?"></a><strong>面试官</strong>： 什么是序列化?什么是反序列化?</h3><p><strong>候选人：</strong></p><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>：将<strong>数据结构或对象</strong>转换成可以存储或传输的形式，通常是<strong>二进制字节流</strong>，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为<strong>原始数据结构或者对象</strong>的过程</li></ul><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到 <strong>数据库（如 Redis）</strong> 之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><h3 id="面试官：-重载和重写的区别（高频）"><a href="#面试官：-重载和重写的区别（高频）" class="headerlink" title="面试官： 重载和重写的区别（高频）"></a><strong>面试官</strong>： 重载和重写的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>重载（编译时多态）是同一个类中方法之间的关系，是水平关系。</p><p>重写（运行时多态）是子类和父类之间的关系，是垂直关系。</p><p>![image-20250218110611282](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110611282.png)</p><h3 id="面试官：面向对象的特征有哪些方面？（高频）"><a href="#面试官：面向对象的特征有哪些方面？（高频）" class="headerlink" title="面试官：面向对象的特征有哪些方面？（高频）"></a><strong>面试官</strong>：面向对象的特征有哪些方面？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。<strong>继承是多态的前提。</strong></p><blockquote><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol></blockquote><p><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。例如，如果父类 Animal 有一个 <code>makeSound()</code> 方法，子类 Dog 和 Cat 可以分别重写这个方法，当调用 <code>animal.makeSound()</code> 时，具体执行的是 Dog 或 Cat 的实现。</p><h3 id="面试官：面向对象的设计原则你知道有哪些吗"><a href="#面试官：面向对象的设计原则你知道有哪些吗" class="headerlink" title="面试官：面向对象的设计原则你知道有哪些吗"></a><strong>面试官</strong>：面向对象的设计原则你知道有哪些吗</h3><p><strong>候选人：</strong> 面向对象编程中的五大原则:</p><ul><li><strong>单一职责原则(SRP)</strong>:一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子:考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li><li><strong>开放封闭原则(OCP)</strong>:软件实体应该对扩展开放，对修改封闭。例子:通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li><li><strong>里氏替换原则(LSP)</strong>:子类对象应该能够替换掉所有父类对象。例子:一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li><li><strong>接口隔离原则(ISP)</strong> :客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子:通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li><li><strong>依赖倒置原则(DIP)</strong>:高层模块不应该依赖低层模块，二者都应该依赖于抽象;抽象不应该依赖于细节，细节应该依赖于抽象。例子:如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类。</li></ul><h3 id="面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）"><a href="#面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）" class="headerlink" title="面试官： String 、StringBuffer 和 StringBuilder 的区别是什么?（高频）"></a><strong>面试官</strong>： String 、StringBuffer 和 StringBuilder 的区别是什么?<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>可变性：</strong></p><ul><li><p>String对象是不可变类，也就是说String对象一旦被创建，其值将不能被改变。String 类中使⽤ <code>final</code> 关键字修饰字符数组来保存字符串， <code>private final char[] value</code> ，所以 String 对象是不可变的。</p><blockquote><p>拓展：在 Java 9 之后，String 类的实现改⽤ byte 数组存储字符串</p><p><strong>private final byte[] value</strong></p></blockquote></li><li><p>StringBuilder 与 StringBuffer 都继承⾃ <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使⽤字符数组保存字符串 <code>char[] value</code> 但是没有⽤ <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>线程安全性</strong>：</p><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>StringBuffer 对<code>AbstractStringBuilder</code>⽅法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对⽅法加同步锁，线程不安全。</li></ul><p><strong>性能</strong>：</p><ul><li><p>每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象。性能最好。</p></li><li><p>StringBuffer 每次都会对<strong>对象本身</strong>进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。性能最差。</p></li><li><p>相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 <strong>10%~15%</strong> 左右的性能提升，但却要冒多线程不安全的⻛险。(如下)</p></li></ul><p><strong>实例化&#x2F;初始化：</strong></p><blockquote><p>《Java程序员面试笔试宝典》第二版 1.18节</p><p>当实例化String的时候，可以利用构造方法（String s1 &#x3D; new String(“world”)）的方式来对其初始化，也可以使用赋值（String s1 &#x3D; “Hello”）的方式来初始化，而StringBuffer和StringBuilder只能使用构造方法（StringBuffer s &#x3D; new StringBuffer(“world”)）的方式来初始化。</p></blockquote><p><strong>在频繁字符串拼接或修改情况下：</strong></p><p>String 字符串修改实现的原理为：当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuilder，然后调用 StingBuilder 的append 方法，最后调用 StingBuilder 的 toString方法把结果返回。举例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码等价于下述代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">s.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">s = sb.toString();</span><br></pre></td></tr></table></figure><p>由此可以看出，上述过程比使用 StingBuilder 多了一些附加的操作，同时也生成了一些临时的对象，导致程序的执行效率降低。</p><p><strong>对于三者使⽤的总结：</strong></p><ol><li>操作少量的数据: 适⽤ String</li><li><strong>单线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li><strong>多线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ol><h3 id="面试官：接⼝和抽象类的区别是什么？（高频）"><a href="#面试官：接⼝和抽象类的区别是什么？（高频）" class="headerlink" title="面试官：接⼝和抽象类的区别是什么？（高频）"></a><strong>面试官</strong>：接⼝和抽象类的区别是什么？<code>（高频）</code></h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">参数</th><th align="center">抽象类（从属关系is-a）</th><th align="center">接口（特定功能的实现has-a）</th></tr></thead><tbody><tr><td align="center">声明</td><td align="center">抽象类使用abstract关键字声明</td><td align="center">接口使用interface关键字声明</td></tr><tr><td align="center">实现</td><td align="center">子类使用extends关键字来继承抽象类</td><td align="center">子类使用implements关键字来实现接口</td></tr><tr><td align="center">构造器</td><td align="center">抽象类可以有构造器</td><td align="center">接口不能有构造器</td></tr><tr><td align="center">访问修饰符</td><td align="center">抽象类中的方法可以是任意访问修饰符</td><td align="center">接口方法默认修饰符是public。并且不允许定义为private 或者 protected</td></tr><tr><td align="center">多继承</td><td align="center">一个类最多只能继承一个抽象类</td><td align="center">一个类可以实现多个接口</td></tr><tr><td align="center">字段声明</td><td align="center">抽象类的字段声明可以是任意的</td><td align="center">接口的字段默认都是 static 和 final 的</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sparrow</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating seeds.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：成员变量与局部变量的区别有哪些？"><a href="#面试官：成员变量与局部变量的区别有哪些？" class="headerlink" title="面试官：成员变量与局部变量的区别有哪些？"></a><strong>面试官</strong>：成员变量与局部变量的区别有哪些？</h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">属性</th><th align="center">成员变量</th><th align="center">局部变量</th></tr></thead><tbody><tr><td align="center"><strong>作用域</strong></td><td align="center">针对整个类有效</td><td align="center">只在某个范围内有效，通常在方法或语句体内</td></tr><tr><td align="center"><strong>存储位置</strong></td><td align="center">随着对象的创建而存在，存储在堆内存中</td><td align="center">在方法被调用或语句被执行的时候存在，存储在栈内存中</td></tr><tr><td align="center"><strong>生命周期</strong></td><td align="center">随着对象的创建而存在，随着对象的消失而消失</td><td align="center">当方法调用完，或者语句结束后，就自动释放</td></tr><tr><td align="center"><strong>初始值</strong></td><td align="center">有默认初始值，如数字类型为0，布尔类型为false，引用类型为null</td><td align="center">没有默认初始值，使用前必须显式赋值</td></tr><tr><td align="center"><strong>使用原则</strong></td><td align="center">就近原则（首先在局部范围找，有就使用；接着在成员位置找）</td><td align="center">就近原则</td></tr></tbody></table><h3 id="面试官：-什么是自动拆箱-装箱？（高频）"><a href="#面试官：-什么是自动拆箱-装箱？（高频）" class="headerlink" title="面试官： 什么是自动拆箱&#x2F;装箱？（高频）"></a><strong>面试官：</strong> 什么是自动拆箱&#x2F;装箱？<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p>自动装箱是指将基本数据类型（如 int、double、boolean 等）自动转换为对应的包装类对象（如 Integer、Double、Boolean 等）。这个过程由<strong>编译器</strong>自动完成，当存储一个基本数据类型到需要用到对象的场景中(例如集合)，Java 编译器会检测到基本数据类型需要被转换为包装类对象，编译器会自动调用包装类的 <code>valueOf()</code> 方法来创建对应的包装类对象，生成的对象会被存储到目标位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> Integer.valueOf(num);</span><br></pre></td></tr></table></figure></li><li><p>自动拆箱是指将包装类对象（如 Integer、Double、Boolean 等）自动转换为对应的基本数据类型（如 int、double、boolean 等）。同样，这个过程也是由<strong>编译器</strong>自动完成的。当你从一个需要对象的场景中取出值并赋给基本数据类型时，Java 编译器会检测到目标变量是一个基本数据类型。编译器会自动调用包装类的 <code>xxxValue()</code> 方法，比如 <code>intValue()</code>、<code>doubleValue()</code> 等，来获取基本数据类型的值。返回的基本数据类型值会被赋给目标变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> integerObj.intValue();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>一共有3点需要注意</p><p>第一个是<strong>性能问题</strong>，频繁的自动装箱和拆箱可能会导致额外的性能开销，因为每次都需要创建或转换对象。</p><p>第二个是<strong>空指针异常</strong>，如果对一个 null 的包装类对象进行自动拆箱操作，会抛出 NullPointerException。</p><p>第三个是<strong>缓存机制</strong>，某些包装类（如 Integer、Boolean 等）会对常用值进行缓存。</p></blockquote><h3 id="面试官：-int和Integer的区别（高频）"><a href="#面试官：-int和Integer的区别（高频）" class="headerlink" title="面试官： int和Integer的区别（高频）"></a><strong>面试官：</strong> int和Integer的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ol><li><p><strong>定义上的区别:</strong></p><ul><li><p>int 是 Java 的基本数据类型，<strong>直接存储数值</strong>，占用固定的 4 字节内存空间，范围是从 -2,147,483,648 到 2,147,483,647。</p></li><li><p>而 Integer 是 int 的包装类，<strong>它是一个对象</strong>，通过引用指向存储的数值，因此除了存储数值本身外，还需要额外的内存开销。</p></li></ul></li><li><p><strong>使用方式上的区别:</strong></p><ul><li><p>int 是一种原始类型，可以直接声明和赋值。</p></li><li><p>而 Integer 必须实例化后才能使用，它提供了更多的功能，比如支持泛型、序列化、缓存以及一些实用方法。</p></li></ul></li><li><p><strong>使用场景上的区别:</strong></p><ul><li><p>当需要高效处理整数时，优先使用 int。</p></li><li><p>当需要将整数作为对象使用时，选择 Integer。</p></li></ul></li></ol><blockquote><p>Java 是一门面向对象的语言，很多场景需要将数据封装成对象。例如：泛型（Generics）要求参数必须是对象类型，而不能是基本数据类型。序列化（Serialization）需要对象支持，以便将数据持久化或通过网络传输。缓存机制需要对整数进行复用，以提高性能和节省内存。</p><p>因此，Java 设计了 Integer 作为 int 的包装类，解决了这些面向对象的需求。</p></blockquote><h3 id="面试官：-与-equals（高频）"><a href="#面试官：-与-equals（高频）" class="headerlink" title="面试官：  &#x3D;&#x3D; 与 equals（高频）"></a><strong>面试官：</strong>  &#x3D;&#x3D; 与 equals<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>&#x3D;&#x3D;</strong> : 它的作⽤是判断两个对象的地址是不是相等。(基本数据类型&#x3D;&#x3D;⽐的是值，引⽤数据类型&#x3D;&#x3D;⽐的是内存地址)。</p><p><strong>equals()</strong> : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：</p><ul><li><p>情况 1：类<strong>没有覆盖 equals()</strong> ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“&#x3D;&#x3D;”⽐这两个对象地址。</p></li><li><p>情况 2：类<strong>覆盖了 equals()</strong> ⽅法。⼀般我们都覆盖 equals() ⽅法来⽐两个对象的内容是否相等；若它们的内容相等，则返回 true 。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true，因为String内部重写了equals.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？"><a href="#面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？" class="headerlink" title="面试官：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？"></a><strong>面试官</strong>：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？</h3><p><strong>候选人：</strong></p><p><strong>1）hashCode()介绍:</strong></p><p>hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><strong>2）以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3）为啥hashcode相同了，这两个对象还有可能不相同呢？</strong></p><p>这是由于哈希码值的空间有限（通常是32位整数），而对象的状态空间可能非常大，因此可能会发生**“哈希碰撞”**，即不同的对象拥有相同的哈希码值。举个例子，考虑一个简单的类 <code>Person</code>，它有两个属性 <code>name</code> 和 <code>age</code>。你可以为这个类重写 <code>hashCode()</code> 和 <code>equals()</code> 方法来确保当两个 <code>Person</code> 对象具有相同的 <code>name</code> 和 <code>age</code> 时，它们的哈希码相同并且 <code>equals()</code> 方法也返回 <code>true</code>。但是，如果你仅仅让 <code>hashCode()</code> 方法基于 <code>name</code> 属性计算哈希码，那么即使 <code>age</code> 不同，两个具有相同名字的 <code>Person</code> 对象也会有相同的哈希码值，尽管它们实际上是不同的对象。</p><p><strong>4）为什么重写equals 时必须重写 hashCode ⽅法？</strong></p><p>如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等,对两个对象分别调⽤ equals⽅法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。<strong>因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖。</strong></p><h3 id="面试官：值传递和引用传递有什么区别？（高频）"><a href="#面试官：值传递和引用传递有什么区别？（高频）" class="headerlink" title="面试官：值传递和引用传递有什么区别？（高频）"></a><strong>面试官</strong>：值传递和引用传递有什么区别？<code>（高频）</code></h3><p><strong>候选人：</strong> Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。（《Java 核⼼技术 卷Ⅰ基础知识》第⼗版 4.5 节）</p><ul><li><strong>值传递</strong>：指的是在方法调用时，传递的参数是<strong>按值的拷贝传递</strong>，也就是说传递后就互不相关了。Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>![image-20250218110642119](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110642119.png)</p><p><strong>解析：</strong> 在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><ul><li><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，<strong>其实传递的引用的地址</strong>，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>![image-20250218110654146](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110654146.png)</p><p><strong>解析：</strong> array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p>![image-20250218110707866](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110707866.png)</p><p>![image-20250218110721206](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110721206.png)</p><p>解析：通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</strong></p><h3 id="面试官：final-、finally-、finalize区别"><a href="#面试官：final-、finally-、finalize区别" class="headerlink" title="面试官：final 、finally 、finalize区别"></a><strong>面试官</strong>：final 、finally 、finalize区别</h3><p><strong>候选人：</strong></p><ul><li>final可以修饰类、变量、方法。修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。（如果是<strong>基本数据类型</strong>的变量，则其数值⼀旦在初始化之后便不能更改；如果是<strong>引⽤类型</strong>的变量，则在对其初始化之后便不能再让其指向另⼀个对象。）</li><li>finally一般作用在<strong>try-catch</strong>代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾。</li></ul><h3 id="面试官：finally块中的代码什么时候被执行？"><a href="#面试官：finally块中的代码什么时候被执行？" class="headerlink" title="面试官：finally块中的代码什么时候被执行？"></a><strong>面试官</strong>：finally块中的代码什么时候被执行？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.19节）<br>在 Java 语言的异常处理中，finally 语句块的作用就是保证无论出现什么情况，finally 块里的代码一定会被执行。由于当程序执行 return 的时候就意味着结束对当前方法的调用并跳出这个方法体，任何语句要执行都只能在 return 前执行(除非碰到 exit 函数)，因此 fnally 块里的代码也是在return 前执行的。<strong>此外，如果 try-finally 或者 catch-finally 中都有 return，则 finally 块中的 return 语句将会覆盖别处的 return 语句，最终返回到调用者的是 finally 中 return 的值</strong>。下面通过两个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>从上面这个例子中可以看出，在执行 return 前确实执行了 finally 中的代码。紧接着，在 finally块里面放置 return 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>在以下</strong> <strong>3</strong> <strong>种特殊情况下，</strong> <strong>finally</strong> <strong>块不会被执⾏：</strong></p><ol><li><p>在 try 或 finally 块中⽤了 System.exit(0) 退出程序。</p></li><li><p>当程序在进入try语句块之前就出现异常的时候（int i &#x3D; 5&#x2F;0;）。</p></li><li><p>程序所在的线程死亡。</p></li><li><p>关闭 CPU。</p></li></ol><h3 id="面试官：this与super的区别"><a href="#面试官：this与super的区别" class="headerlink" title="面试官：this与super的区别"></a><strong>面试官</strong>：this与super的区别</h3><p><strong>候选人：</strong></p><ul><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h3 id="面试官：Java程序初始化的顺序可以说下吗？"><a href="#面试官：Java程序初始化的顺序可以说下吗？" class="headerlink" title="面试官：Java程序初始化的顺序可以说下吗？"></a><strong>面试官</strong>：Java程序初始化的顺序可以说下吗？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.1节）</p><p>Java程序的初始化工作可以在许多不同的代码块中来完成(例如:静态代码块、构造函数等)，它们执行的顺序为:<strong>父类静态变量</strong>→父类静态代码块→<strong>子类静态变量</strong>→子类静态代码→<strong>父类非静态变量</strong>→父类非静态代码块→父类构造方法→<strong>子类非静态变量</strong>→子类非静态代码块→子类构造方法。下面给出一个不同模块初始化时执行顺序的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Base <span class="keyword">static</span> block</span><br><span class="line">Derived <span class="keyword">static</span> block</span><br><span class="line">Base block</span><br><span class="line">Base constructor</span><br><span class="line">Derived block</span><br><span class="line">Derived constructor</span><br></pre></td></tr></table></figure><p>这里需要注意的是，(静态)非静态成员域在定义时初始化和(静态)非静态块中初始化的优先级是平级的，也就是说按照从上到下初始化，最后一次初始化为最终的值(不包括非静态的成员域在构造器中初始化)。所以在(静态)非静态块中初始化的域甚至能在该域声明的上方，因为分配存储空间在初始化之前就完成了。如下例所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="面试官：说下构造方法（构造器）吧！"><a href="#面试官：说下构造方法（构造器）吧！" class="headerlink" title="面试官：说下构造方法（构造器）吧！"></a><strong>面试官</strong>：说下构造方法（构造器）吧！</h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.2节）</p><p>Java 语言中，构造方法具有以下特点:</p><p>1）构造方法必须与类的名字相同，并且不能有返回值(返回值也不能为 void)。</p><p>2）每个类可以有多个构造方法。</p><p>3）构造方法可以有0个、1 个或1个以上的参数。</p><p>4）构造方法总是伴随着 new 操作一起调用。</p><p>5）构造方法的主要作用是完成对象的初始化工作。</p><p>6）构造方法不能被继承，因此就不能被重写(Override)，但是构造方法能够被重载(Overload)。</p><p>7）当父类和子类都没有定义构造方法的时候，编译器会为父类生成一个默认的无参数的构造方法，给子类也生成一个默认的无参数的构造方法。</p><h3 id="面试官：break、continue以及return的区别"><a href="#面试官：break、continue以及return的区别" class="headerlink" title="面试官：break、continue以及return的区别"></a><strong>面试官</strong>：break、continue以及return的区别</h3><p><strong>候选人：</strong></p><ul><li>break：跳出上一层循环，不再执行循环(结束当前的循环体)。所以，当多层循环嵌套，break 语句出现在嵌套循环中的内层循环，它将仅仅只是终止了内层循环的执行，而不影响外层循环的执行。</li></ul><blockquote><p>拓展：由于 break 只能跳出当前的循环，那么如何才能实现跳出多重循环呢?可以在多重循环的外面定义一个标识，然后在循环体里使用带有标识的 break 语句即可跳出多重循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     out:</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) <span class="keyword">break</span> out;</span><br><span class="line">             System.out.println(j);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在 C&#x2F;C++中，goto 常被用作跳出多重循环，在 Java 语言中，可以使用 break 和 continue 来达到同样的效果。那么既然 goto 没有在 Java 语言中使用，为什么还要作为保留字呢?其中一个可能的原因就是这个关键字有可能会在将来被使用。这里需要注意的是，在 Java 语言中，虽然没有 goto 语句，但是却能使用标识符加冒号 (:)的形式定义标签，其目的主要是在多重循环中方便使用 break 和 continue。</p></blockquote><ul><li>continue：跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)。简单地说，continue 只是中断一次循环的执行而己。</li><li>return：程序返回，不再执行下面的代码(结束当前的方法直接返回)。</li></ul><h3 id="面试官：-说说你对Java-中的异常处理的理解？"><a href="#面试官：-说说你对Java-中的异常处理的理解？" class="headerlink" title="面试官： 说说你对Java 中的异常处理的理解？"></a><strong>面试官</strong>： 说说你对Java 中的异常处理的理解？</h3><p>**候选人：**在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类有两个重要的⼦类 Exception （异常）和 Error （错误）。 Exception 能被程序本身处理( trycatch )， Error 是⽆法处理的(只能尽量避免)。Exception 和 Error ⼆者都是 Java 异常处理的重要⼦类，各⾃都包含⼤量⼦类。</p><ul><li><strong>Exception</strong>：程序本身可以处理的异常，可以通过 catch 来进⾏捕获。 Exception ⼜可以分为 <strong>受检异常</strong>(必须处理) 和 <strong>非受检异常</strong>(可以不处理)。</li></ul><blockquote><p><strong>受检查异常</strong>：Java 代码在编译过程中，如果受检查异常没有被 catch &#x2F; throw 处理的话，就没办法通过编译。除了 RuntimeException 及其⼦类以外，其他的 Exception 类及其⼦类都属于检查异常 。常⻅的受检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException …。</p><p><strong>不受检查异常</strong>：Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException 及其⼦类都统称为⾮受检查异常，例如： NullPointExecrption（空指针异常） 、 NumberFormatException （字符串转换为数字）、 ArrayIndexOutOfBoundsException （数组越界）、 ClassCastException （类型转换错误）等。</p></blockquote><ul><li><strong>Error</strong>：Error 属于程序⽆法处理的错误 ，我们没办法通过 catch 来进⾏捕获 。例如，Java 虚拟机运⾏错误（ Virtual MachineError ）、虚拟机内存不够错误( OutOfMemoryError )、类定义错误（NoClassDefFoundError ）等 。这些异常发⽣时，Java虚拟机（JVM）⼀般会选择线程终⽌。</li></ul><p>![image-20250218110747074](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110747074.png)</p><h3 id="面试官：-BIO-NIO-AIO-有什么区别-（高频）"><a href="#面试官：-BIO-NIO-AIO-有什么区别-（高频）" class="headerlink" title="面试官： BIO,NIO,AIO 有什么区别?（高频）"></a><strong>面试官</strong>： BIO,NIO,AIO 有什么区别?<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>BIO (Blocking I&#x2F;O):</strong>  <strong>同步阻塞</strong> I&#x2F;O 模式，数据的读取写⼊必须<strong>阻塞</strong>在⼀个线程内等待其完成（每个线程只能处理一个连接）。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型不错的，可以让每⼀个连接专注于⾃⼰的 I&#x2F;O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。但是，当⾯对⼗万甚⾄百万级连接的时候，这种方式需要创建大量的线程，而系统的资源都是有限的，大量的线程会降低系统的性能。</p></li><li><p><strong>NIO (Non-blocking I&#x2F;O):</strong> <strong>同步⾮阻塞</strong> 的 I&#x2F;O 模型。NIO通过 <code>Channels , Selector，Buffers</code> 来实现非阻塞的IO操作。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I&#x2F;O 操作⽅法。它最主要的特点是，提供了基于Selector的异步网络I&#x2F;O，使得一个线程可以管理多个连接。</p><p>（图片源自《Java程序员面试笔试宝典》第二版 2.4节）</p><p>![image-20250218110800609](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110800609.png)</p></li></ul><blockquote><p>扩展：Channel（通道） , Selector（选择器），Buffer（缓冲区）</p><p>(1) Channel(通道)<br>为了更容易地理解什么是 <code>Channel</code>，这里以 <code>InputStream</code> 为例来介绍什么是 <code>Channel</code>。传统的 IO 中经常使用下面的代码来读取文件(此处忽略异常处理):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;imput.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">byte</span>[] tempbyte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((tempbyte=is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><p><code>InputStream</code> 其实就是一个用来读取文件的通道。只不过 <code>InputStream</code> 是一个单向的通道，只能用来读取数据。而 NIO 中的 <code>Channel</code> 是一个双向的通道，不仅能读取数据，而且还能写入数据。</p><p>(2) Buffer(缓冲区)<br>在上面的示例代码中，<code>InputSteam</code> 把读取到的数据放在了 byte 数组中，如果用 <code>OutputSteam</code> 写数据，那么也可以把 byte 数组中的数据<strong>写到文件</strong>中。而在 NIO 中，数据只能被<strong>写到 Buffer</strong> 中，同理读取的数据也只能放在 Buffer 中，由此可见 Bufer 是 Channel 用来读写数据的非常重要的一个工具。</p><p>![image-20250218110814433](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110814433.png)</p><p>(3) Selector(选择器)<br><code>Selector</code> 是 NIO 中最重要的部分，是实现一个线程管理多个连接的关键，它的作用就是<strong>轮询</strong>所有被注册的<code>Channel</code>，一旦发现 <code>Channel</code> 上被注册的事件发生，就可以对这个事件进行处理。</p></blockquote><ul><li><strong>AIO (Asynchronous I&#x2F;O):</strong> AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是<strong>异步⾮阻塞</strong>的 IO 模型。虽然 NIO 在⽹络操作中，也提供了⾮阻塞的⽅法，但它本身仍然是同步的，选择器仍然需要通过<strong>轮询</strong>主动检查数据请求。而异步 IO （AIO）是<strong>基于事件和回调机制</strong>实现的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</li></ul><h3 id="面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"><a href="#面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？" class="headerlink" title="面试官： NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"></a><strong>面试官：</strong> NIO是如何实现同步非阻塞的？主线程是只有一个嘛？</h3><p><strong>候选人：</strong></p><p>在NIO中，使用了多路复用器Selector来实现同步非阻塞的IO操作。Selector是一个可以监控多个通道（Channel）是否有数据可读或可写的对象，当一个或多个Channel准备好读或写时，Selector会通知程序进行读写操作，而不是像BIO一样阻塞等待IO操作完成。</p><p>在NIO中，主线程<strong>通常只有一个</strong>，但是可以使用Selector来管理多个Channel，实现多个连接的非阻塞读写操作。当有多个Channel需要进行IO操作时，Selector会<strong>轮询</strong>这些Channel，检查它们的状态是否可读或可写，如果有可读或可写的Channel，就将其加入到一个已选择键集合中，等待程序处理。这样，一个线程就可以同时处理多个Channel，提高了系统的并发处理能力。</p><h3 id="面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"><a href="#面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）" class="headerlink" title="面试官： 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"></a><strong>面试官：</strong> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？<code>（高频）</code></h3><ul><li><p>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接<strong>复制内部对象的引用地址</strong>，也就是说<strong>拷贝对象和原对象共用同一个内部对象</strong>。浅拷贝实现简单，使用 <code>clone()</code> 即可。</p></li><li><p>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。**增加了一个指针并且申请了一个新的内存，使这个新增的指针指向新的内存。**深拷贝需要递归复制或序列化，实现较复杂。</p><blockquote><p>联想：在租房的场景中，租客和房东共享房子的使用权，任何改动都会影响对方；而在买房的场景中，买方拥有独立的房子，可以自由改造而不影响他人。通过租房和买房的类比，轻松理解浅拷贝和深拷贝的不同。</p><p>浅拷贝 → 租房（租客和房东共享房子，改动家具会影响房东）。</p><p>深拷贝 → 买房（买房后拥有完全独立的房子，改动家具不会影响房东）。</p></blockquote></li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p>![image-20250303092129835](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250303092129835.png)</p><h3 id="面试官：-什么是泛型？有什么作用？（高频）"><a href="#面试官：-什么是泛型？有什么作用？（高频）" class="headerlink" title="面试官： 什么是泛型？有什么作用？（高频）"></a><strong>面试官：</strong> 什么是泛型？有什么作用？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>泛型是一种在编译时提供类型安全检查的机制，它允许我们将类型作为参数传递给类、接口或方法，从而避免硬编码具体的类型。通过泛型，我们可以编写适用于多种数据类型的代码，同时确保类型安全。</p><p>泛型的作用主要有4点：</p><p>第一点是<strong>提高代码的复用性</strong>，它允许我们编写与类型无关的通用代码。</p><p>第二点是<strong>增强类型安全性</strong>，在没有泛型的情况下，集合类（如 ArrayList）默认存储的是 Object 类型，取出元素时需要手动进行类型转换，容易引发 ClassCastException。而泛型在编译时就会进行类型检查，避免了运行时的类型错误。</p><p>第三点是<strong>简化代码</strong>，使用泛型后，我们无需显式地进行类型转换，减少了冗余代码，提高了代码的可读性和维护性。</p><p>第四点是<strong>支持复杂的类型约束</strong>，泛型可以通过通配符（如 ? extends T 和 ? super T）实现更复杂的类型限制，满足特定场景下的需求。</p><h3 id="面试官：-Java反射机制以及获取反射对象的几种方式（高频）"><a href="#面试官：-Java反射机制以及获取反射对象的几种方式（高频）" class="headerlink" title="面试官： Java反射机制以及获取反射对象的几种方式（高频）"></a><strong>面试官：</strong> Java反射机制以及获取反射对象的几种方式<code>（高频）</code></h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.4节）</p><p>在Java语言中，反射机制是指对于运行时类，都能够动态地获取到这个类的所有属性和方法。对于任意的一个对象，都能够调用它的任意一个方法以及访问它的属性；这种动态地获取类或对象的属性以及方法从而完成调用功能被称为Java语言的反射机制。</p><p>反射机制中Class是一个非常重要的类，在Java语言中获取Class对象主要有如下几种方法。</p><ol><li>通过<code>.class</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = A.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>Class.forName()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="3"><li>通过<code>.getClass()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">new</span> <span class="title class_">A</span>().getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">dynamic block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><p>从上面的例子可知，虽然这三种方式都可以获得类的Class对象，但是它们还是有区别的，主要区别如下所示：</p><p>方法1）<strong>不执行静态块和普通代码块</strong></p><p>方法2）<strong>只执行静态块，而不执行普通代码块</strong></p><p>方法3）<strong>因为需要创建对象，所以会执行静态块和普通代码块</strong></p><h3 id="面试官：-Java创建对象除了new还有别的什么方式"><a href="#面试官：-Java创建对象除了new还有别的什么方式" class="headerlink" title="面试官： Java创建对象除了new还有别的什么方式?"></a><strong>面试官：</strong> Java创建对象除了new还有别的什么方式?</h3><p><strong>候选人：</strong></p><ul><li><p><strong>通过反射创建对象</strong>:通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newinstance() 方法或者通过 Constructor 类来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; clazz=MyClass.class;</span><br><span class="line">    MyClass obj=(MyClass)clazz.newInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过反序列化创建对象</strong>:通过将对象序列化(保存到文件或网络传输)然后再反序列化(从文件或网络传输中读取对象)的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Serialize object</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialize object</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过clone创建对象</strong>:所有 Java 对象都继承自 Object 类，Object 类中有一个 clone()方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/22/hello-world/"/>
      <url>/2025/03/22/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="🎉-Hello-World"><a href="#🎉-Hello-World" class="headerlink" title="🎉 Hello, World!"></a>🎉 Hello, World!</h1><p>欢迎来到我的个人网站！这是一个承载思考与创意的空间，也是我与世界对话的窗口。从构思到上线，这个小小的角落凝聚了我的热情与心血。</p><h2 id="🌿-为什么是“Hello-World”"><a href="#🌿-为什么是“Hello-World”" class="headerlink" title="🌿 为什么是“Hello, World”?"></a>🌿 为什么是“Hello, World”?</h2><p>“Hello, World!” 是程序员的第一课。它不仅是一句简单的问候，更象征着探索与创造的开始。每一个程序员在学习一门新语言时，都会用它来向世界宣告自己的到来。</p><p>而我的个人网站，也像是一次数字世界的问候。它不仅代表着技术上的实现，更是我向世界展示自我的方式。在这里，我记录思考、分享作品、交流想法。这个名字承载了我对新起点的期待，也寄托着我不断学习和成长的决心。</p><h2 id="🌿-关于这里"><a href="#🌿-关于这里" class="headerlink" title="🌿 关于这里"></a>🌿 关于这里</h2><p>在这里，你会找到：</p><ul><li><strong>📝 日常分享</strong>：记录生活中的点滴瞬间，感悟万物之美。</li><li><strong>🎨 绘画作品</strong>：用色彩描绘内心世界，捕捉灵感的瞬间。</li><li><strong>💡 技术探索</strong>：分享我的学习笔记和项目经验，共同成长。</li></ul><h2 id="💬-与我互动"><a href="#💬-与我互动" class="headerlink" title="💬 与我互动"></a>💬 与我互动</h2><p>每一篇文章、每一幅作品，都是我世界的一部分。我希望你在这里找到共鸣，也欢迎留下你的想法和故事。</p><ul><li>想法碰撞？留下评论吧！</li><li>想了解更多？敬请期待更新！</li><li>有问题？<a href="#">联系我</a> 我很乐意听到你的声音。</li></ul><h2 id="🚀-未来可期"><a href="#🚀-未来可期" class="headerlink" title="🚀 未来可期"></a>🚀 未来可期</h2><p>未来还有更多精彩内容等待解锁。感谢你的到来，让我们一起探索这场数字旅程吧！</p><p>再次欢迎你，愿你在这里度过美好的时光！🌟</p>]]></content>
      
      
      <categories>
          
          <category> 个人碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
