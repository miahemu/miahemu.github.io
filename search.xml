<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/22/hello-world/"/>
      <url>/2025/03/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE相关面试题</title>
      <link href="/2025/03/22/mianshiti/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/22/mianshiti/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）"><a href="#面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）" class="headerlink" title="面试官： 面向对象(OOP)和面向过程(POP)的区别（高频）"></a><strong>面试官</strong>： 面向对象(OOP)和面向过程(POP)的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>⾯向过程</strong> ：<strong>⾯向过程性能⽐⾯向对象⾼。</strong> ⽐如单⽚机、嵌⼊式开发、Linux&#x2F;Unix 等⼀般采⽤⾯向过程开发。以函数为中心，强调逻辑流程。</p></li><li><p><strong>⾯向对象</strong> ：<strong>⾯向对象易维护、易复⽤、易扩展。</strong> 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>⾯向对象性能⽐⾯向过程低</strong>。以对象为中心，强调数据和行为的封装。</p></li></ul><blockquote><p>拓展：为什么⾯向过程性能⽐⾯向对象⾼？</p><p>⾯向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是⾯向对象语⾔，⽽是 Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的⼆进制机械码。⽽⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏。</p></blockquote><h3 id="面试官：Java的基本数据类型"><a href="#面试官：Java的基本数据类型" class="headerlink" title="面试官：Java的基本数据类型"></a><strong>面试官</strong>：Java的基本数据类型</h3><p><strong>候选人：</strong> Java 语言一共提供了八种原始的数据类型(byte、short、int、long、float、double、char、boolean)。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png" alt="img"></p><p>以上这些基本类型可以分为如下三种类型：</p><p>1）数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</p><p>2）字符型：char</p><p>3）布尔型：boolean</p><p>8种基本数据类型的默认值、位数、取值范围，如下表所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="img"></p><h3 id="面试官：说说JVM-、-JDK-和-JRE的区别？"><a href="#面试官：说说JVM-、-JDK-和-JRE的区别？" class="headerlink" title="面试官：说说JVM 、 JDK 和 JRE的区别？"></a><strong>面试官</strong>：说说JVM 、 JDK 和 JRE的区别？</h3><p><strong>候选人：</strong></p><ul><li><strong>Java Virtual Machine（JVM）</strong> 是运⾏ Java 字节码的虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li></ul><blockquote><p>拓展：什么是字节码?采⽤字节码的好处是什么?</p><p>在 Java 中，JVM 可以理解的代码就叫做  （即扩展名为 .class 的⽂件），它<strong>不⾯向任何特定的处理器，只⾯向虚拟机</strong>。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔<strong>执⾏效率低</strong>的问题，同时⼜保留了解释型语⾔<strong>可移植</strong>的特点。</p></blockquote><ul><li><strong>Java Runtime Environment（JRE）</strong> 包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包。</li><li><strong>Java Development Kit（JDK）</strong> 是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed34206201fcfe5a01689c30e3113972.png" alt="img"></p><h3 id="面试官：Java-程序从源代码到运⾏分为哪几步？"><a href="#面试官：Java-程序从源代码到运⾏分为哪几步？" class="headerlink" title="面试官：Java 程序从源代码到运⾏分为哪几步？"></a><strong>面试官</strong>：Java 程序从源代码到运⾏分为哪几步？</h3><p><strong>候选人：</strong> Java程序从源代码到运⾏⼀般有下⾯3步：</p><p>![image-20250218110538905](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110538905.png)</p><p>我们需要格外注意的是 <strong>.class-&gt;机器码</strong> 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过解释器逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的<strong>热点代码</strong>)，所以后⾯引进了 <strong>JIT 编译器</strong>，⽽ JIT 属于<strong>运⾏时编译</strong>。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。这也解释了我们为什么经常会说 Java 是编译与解释共存的语⾔。</p><h3 id="面试官：Java和C-的区别"><a href="#面试官：Java和C-的区别" class="headerlink" title="面试官：Java和C++的区别"></a><strong>面试官</strong>：Java和C++的区别</h3><p><strong>候选人：</strong></p><ul><li>都是面向对象的语言，都支持封装、继承和多态。</li><li>Java不提供指针来直接访问内存，程序内存更加安全。</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以有多个实现类。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存。</li><li>在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符‘\0’来表示结束。但是，Java 语⾔中没有结束符这⼀概念。</li></ul><blockquote><p>深度思考：</p><p>在C语言中，字符串是以空字符（’\0’）结尾的字符数组。这种设计的好处是简单直接，但缺点是在访问字符串时每次都需要检查空字符来确定字符串的长度，这可能会导致额外的计算开销。在Java中，字符串是一个类（<code>String</code>），它包含了字符串的值以及其长度信息。这种设计使得字符串的长度可以在创建时确定，并且可以通过内置的方法（如<code>length()</code>）轻松获取。这种方法提高了效率，减少了因字符串处理不当而导致的安全隐患。</p></blockquote><h3 id="面试官：-什么是序列化-什么是反序列化"><a href="#面试官：-什么是序列化-什么是反序列化" class="headerlink" title="面试官： 什么是序列化?什么是反序列化?"></a><strong>面试官</strong>： 什么是序列化?什么是反序列化?</h3><p><strong>候选人：</strong></p><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>：将<strong>数据结构或对象</strong>转换成可以存储或传输的形式，通常是<strong>二进制字节流</strong>，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为<strong>原始数据结构或者对象</strong>的过程</li></ul><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到 <strong>数据库（如 Redis）</strong> 之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><h3 id="面试官：-重载和重写的区别（高频）"><a href="#面试官：-重载和重写的区别（高频）" class="headerlink" title="面试官： 重载和重写的区别（高频）"></a><strong>面试官</strong>： 重载和重写的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>重载（编译时多态）是同一个类中方法之间的关系，是水平关系。</p><p>重写（运行时多态）是子类和父类之间的关系，是垂直关系。</p><p>![image-20250218110611282](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110611282.png)</p><h3 id="面试官：面向对象的特征有哪些方面？（高频）"><a href="#面试官：面向对象的特征有哪些方面？（高频）" class="headerlink" title="面试官：面向对象的特征有哪些方面？（高频）"></a><strong>面试官</strong>：面向对象的特征有哪些方面？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。<strong>继承是多态的前提。</strong></p><blockquote><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol></blockquote><p><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。例如，如果父类 Animal 有一个 <code>makeSound()</code> 方法，子类 Dog 和 Cat 可以分别重写这个方法，当调用 <code>animal.makeSound()</code> 时，具体执行的是 Dog 或 Cat 的实现。</p><h3 id="面试官：面向对象的设计原则你知道有哪些吗"><a href="#面试官：面向对象的设计原则你知道有哪些吗" class="headerlink" title="面试官：面向对象的设计原则你知道有哪些吗"></a><strong>面试官</strong>：面向对象的设计原则你知道有哪些吗</h3><p><strong>候选人：</strong> 面向对象编程中的五大原则:</p><ul><li><strong>单一职责原则(SRP)</strong>:一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子:考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li><li><strong>开放封闭原则(OCP)</strong>:软件实体应该对扩展开放，对修改封闭。例子:通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li><li><strong>里氏替换原则(LSP)</strong>:子类对象应该能够替换掉所有父类对象。例子:一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li><li><strong>接口隔离原则(ISP)</strong> :客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子:通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li><li><strong>依赖倒置原则(DIP)</strong>:高层模块不应该依赖低层模块，二者都应该依赖于抽象;抽象不应该依赖于细节，细节应该依赖于抽象。例子:如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类。</li></ul><h3 id="面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）"><a href="#面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）" class="headerlink" title="面试官： String 、StringBuffer 和 StringBuilder 的区别是什么?（高频）"></a><strong>面试官</strong>： String 、StringBuffer 和 StringBuilder 的区别是什么?<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>可变性：</strong></p><ul><li><p>String对象是不可变类，也就是说String对象一旦被创建，其值将不能被改变。String 类中使⽤ <code>final</code> 关键字修饰字符数组来保存字符串， <code>private final char[] value</code> ，所以 String 对象是不可变的。</p><blockquote><p>拓展：在 Java 9 之后，String 类的实现改⽤ byte 数组存储字符串</p><p><strong>private final byte[] value</strong></p></blockquote></li><li><p>StringBuilder 与 StringBuffer 都继承⾃ <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使⽤字符数组保存字符串 <code>char[] value</code> 但是没有⽤ <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>线程安全性</strong>：</p><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>StringBuffer 对<code>AbstractStringBuilder</code>⽅法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对⽅法加同步锁，线程不安全。</li></ul><p><strong>性能</strong>：</p><ul><li><p>每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象。性能最好。</p></li><li><p>StringBuffer 每次都会对<strong>对象本身</strong>进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。性能最差。</p></li><li><p>相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 <strong>10%~15%</strong> 左右的性能提升，但却要冒多线程不安全的⻛险。(如下)</p></li></ul><p><strong>实例化&#x2F;初始化：</strong></p><blockquote><p>《Java程序员面试笔试宝典》第二版 1.18节</p><p>当实例化String的时候，可以利用构造方法（String s1 &#x3D; new String(“world”)）的方式来对其初始化，也可以使用赋值（String s1 &#x3D; “Hello”）的方式来初始化，而StringBuffer和StringBuilder只能使用构造方法（StringBuffer s &#x3D; new StringBuffer(“world”)）的方式来初始化。</p></blockquote><p><strong>在频繁字符串拼接或修改情况下：</strong></p><p>String 字符串修改实现的原理为：当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuilder，然后调用 StingBuilder 的append 方法，最后调用 StingBuilder 的 toString方法把结果返回。举例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码等价于下述代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">s.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">s = sb.toString();</span><br></pre></td></tr></table></figure><p>由此可以看出，上述过程比使用 StingBuilder 多了一些附加的操作，同时也生成了一些临时的对象，导致程序的执行效率降低。</p><p><strong>对于三者使⽤的总结：</strong></p><ol><li>操作少量的数据: 适⽤ String</li><li><strong>单线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li><strong>多线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ol><h3 id="面试官：接⼝和抽象类的区别是什么？（高频）"><a href="#面试官：接⼝和抽象类的区别是什么？（高频）" class="headerlink" title="面试官：接⼝和抽象类的区别是什么？（高频）"></a><strong>面试官</strong>：接⼝和抽象类的区别是什么？<code>（高频）</code></h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">参数</th><th align="center">抽象类（从属关系is-a）</th><th align="center">接口（特定功能的实现has-a）</th></tr></thead><tbody><tr><td align="center">声明</td><td align="center">抽象类使用abstract关键字声明</td><td align="center">接口使用interface关键字声明</td></tr><tr><td align="center">实现</td><td align="center">子类使用extends关键字来继承抽象类</td><td align="center">子类使用implements关键字来实现接口</td></tr><tr><td align="center">构造器</td><td align="center">抽象类可以有构造器</td><td align="center">接口不能有构造器</td></tr><tr><td align="center">访问修饰符</td><td align="center">抽象类中的方法可以是任意访问修饰符</td><td align="center">接口方法默认修饰符是public。并且不允许定义为private 或者 protected</td></tr><tr><td align="center">多继承</td><td align="center">一个类最多只能继承一个抽象类</td><td align="center">一个类可以实现多个接口</td></tr><tr><td align="center">字段声明</td><td align="center">抽象类的字段声明可以是任意的</td><td align="center">接口的字段默认都是 static 和 final 的</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sparrow</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating seeds.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：成员变量与局部变量的区别有哪些？"><a href="#面试官：成员变量与局部变量的区别有哪些？" class="headerlink" title="面试官：成员变量与局部变量的区别有哪些？"></a><strong>面试官</strong>：成员变量与局部变量的区别有哪些？</h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">属性</th><th align="center">成员变量</th><th align="center">局部变量</th></tr></thead><tbody><tr><td align="center"><strong>作用域</strong></td><td align="center">针对整个类有效</td><td align="center">只在某个范围内有效，通常在方法或语句体内</td></tr><tr><td align="center"><strong>存储位置</strong></td><td align="center">随着对象的创建而存在，存储在堆内存中</td><td align="center">在方法被调用或语句被执行的时候存在，存储在栈内存中</td></tr><tr><td align="center"><strong>生命周期</strong></td><td align="center">随着对象的创建而存在，随着对象的消失而消失</td><td align="center">当方法调用完，或者语句结束后，就自动释放</td></tr><tr><td align="center"><strong>初始值</strong></td><td align="center">有默认初始值，如数字类型为0，布尔类型为false，引用类型为null</td><td align="center">没有默认初始值，使用前必须显式赋值</td></tr><tr><td align="center"><strong>使用原则</strong></td><td align="center">就近原则（首先在局部范围找，有就使用；接着在成员位置找）</td><td align="center">就近原则</td></tr></tbody></table><h3 id="面试官：-什么是自动拆箱-装箱？（高频）"><a href="#面试官：-什么是自动拆箱-装箱？（高频）" class="headerlink" title="**面试官：**什么是自动拆箱&#x2F;装箱？（高频）"></a>**面试官：**什么是自动拆箱&#x2F;装箱？<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p>自动装箱是指将基本数据类型（如 int、double、boolean 等）自动转换为对应的包装类对象（如 Integer、Double、Boolean 等）。这个过程由<strong>编译器</strong>自动完成，当存储一个基本数据类型到需要用到对象的场景中(例如集合)，Java 编译器会检测到基本数据类型需要被转换为包装类对象，编译器会自动调用包装类的 <code>valueOf()</code> 方法来创建对应的包装类对象，生成的对象会被存储到目标位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> Integer.valueOf(num);</span><br></pre></td></tr></table></figure></li><li><p>自动拆箱是指将包装类对象（如 Integer、Double、Boolean 等）自动转换为对应的基本数据类型（如 int、double、boolean 等）。同样，这个过程也是由<strong>编译器</strong>自动完成的。当你从一个需要对象的场景中取出值并赋给基本数据类型时，Java 编译器会检测到目标变量是一个基本数据类型。编译器会自动调用包装类的 <code>xxxValue()</code> 方法，比如 <code>intValue()</code>、<code>doubleValue()</code> 等，来获取基本数据类型的值。返回的基本数据类型值会被赋给目标变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> integerObj.intValue();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>一共有3点需要注意</p><p>第一个是<strong>性能问题</strong>，频繁的自动装箱和拆箱可能会导致额外的性能开销，因为每次都需要创建或转换对象。</p><p>第二个是<strong>空指针异常</strong>，如果对一个 null 的包装类对象进行自动拆箱操作，会抛出 NullPointerException。</p><p>第三个是<strong>缓存机制</strong>，某些包装类（如 Integer、Boolean 等）会对常用值进行缓存。</p></blockquote><h3 id="面试官：-int和Integer的区别（高频）"><a href="#面试官：-int和Integer的区别（高频）" class="headerlink" title="**面试官：**int和Integer的区别（高频）"></a>**面试官：**int和Integer的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ol><li><p><strong>定义上的区别:</strong></p><ul><li><p>int 是 Java 的基本数据类型，<strong>直接存储数值</strong>，占用固定的 4 字节内存空间，范围是从 -2,147,483,648 到 2,147,483,647。</p></li><li><p>而 Integer 是 int 的包装类，<strong>它是一个对象</strong>，通过引用指向存储的数值，因此除了存储数值本身外，还需要额外的内存开销。</p></li></ul></li><li><p><strong>使用方式上的区别:</strong></p><ul><li><p>int 是一种原始类型，可以直接声明和赋值。</p></li><li><p>而 Integer 必须实例化后才能使用，它提供了更多的功能，比如支持泛型、序列化、缓存以及一些实用方法。</p></li></ul></li><li><p><strong>使用场景上的区别:</strong></p><ul><li><p>当需要高效处理整数时，优先使用 int。</p></li><li><p>当需要将整数作为对象使用时，选择 Integer。</p></li></ul></li></ol><blockquote><p>Java 是一门面向对象的语言，很多场景需要将数据封装成对象。例如：泛型（Generics）要求参数必须是对象类型，而不能是基本数据类型。序列化（Serialization）需要对象支持，以便将数据持久化或通过网络传输。缓存机制需要对整数进行复用，以提高性能和节省内存。</p><p>因此，Java 设计了 Integer 作为 int 的包装类，解决了这些面向对象的需求。</p></blockquote><h3 id="面试官：-与-equals（高频）"><a href="#面试官：-与-equals（高频）" class="headerlink" title="面试官：  &#x3D;&#x3D; 与 equals（高频）"></a><strong>面试官：</strong>  &#x3D;&#x3D; 与 equals<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>&#x3D;&#x3D;</strong> : 它的作⽤是判断两个对象的地址是不是相等。(基本数据类型&#x3D;&#x3D;⽐的是值，引⽤数据类型&#x3D;&#x3D;⽐的是内存地址)。</p><p><strong>equals()</strong> : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：</p><ul><li><p>情况 1：类<strong>没有覆盖 equals()</strong> ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“&#x3D;&#x3D;”⽐这两个对象地址。</p></li><li><p>情况 2：类<strong>覆盖了 equals()</strong> ⽅法。⼀般我们都覆盖 equals() ⽅法来⽐两个对象的内容是否相等；若它们的内容相等，则返回 true 。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true，因为String内部重写了equals.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？"><a href="#面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？" class="headerlink" title="面试官：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？"></a><strong>面试官</strong>：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？</h3><p><strong>候选人：</strong></p><p><strong>1）hashCode()介绍:</strong></p><p>hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><strong>2）以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3）为啥hashcode相同了，这两个对象还有可能不相同呢？</strong></p><p>这是由于哈希码值的空间有限（通常是32位整数），而对象的状态空间可能非常大，因此可能会发生**“哈希碰撞”**，即不同的对象拥有相同的哈希码值。举个例子，考虑一个简单的类 <code>Person</code>，它有两个属性 <code>name</code> 和 <code>age</code>。你可以为这个类重写 <code>hashCode()</code> 和 <code>equals()</code> 方法来确保当两个 <code>Person</code> 对象具有相同的 <code>name</code> 和 <code>age</code> 时，它们的哈希码相同并且 <code>equals()</code> 方法也返回 <code>true</code>。但是，如果你仅仅让 <code>hashCode()</code> 方法基于 <code>name</code> 属性计算哈希码，那么即使 <code>age</code> 不同，两个具有相同名字的 <code>Person</code> 对象也会有相同的哈希码值，尽管它们实际上是不同的对象。</p><p><strong>4）为什么重写equals 时必须重写 hashCode ⽅法？</strong></p><p>如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等,对两个对象分别调⽤ equals⽅法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。<strong>因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖。</strong></p><h3 id="面试官：值传递和引用传递有什么区别？（高频）"><a href="#面试官：值传递和引用传递有什么区别？（高频）" class="headerlink" title="面试官：值传递和引用传递有什么区别？（高频）"></a><strong>面试官</strong>：值传递和引用传递有什么区别？<code>（高频）</code></h3><p>**候选人：**Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。（《Java 核⼼技术 卷Ⅰ基础知识》第⼗版 4.5 节）</p><ul><li><strong>值传递</strong>：指的是在方法调用时，传递的参数是<strong>按值的拷贝传递</strong>，也就是说传递后就互不相关了。Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>![image-20250218110642119](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110642119.png)</p><p>**解析：**在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><ul><li><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，<strong>其实传递的引用的地址</strong>，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>![image-20250218110654146](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110654146.png)</p><p>**解析：**array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p>![image-20250218110707866](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110707866.png)</p><p>![image-20250218110721206](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110721206.png)</p><p>解析：通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</strong></p><h3 id="面试官：final-、finally-、finalize区别"><a href="#面试官：final-、finally-、finalize区别" class="headerlink" title="面试官：final 、finally 、finalize区别"></a><strong>面试官</strong>：final 、finally 、finalize区别</h3><p><strong>候选人：</strong></p><ul><li>final可以修饰类、变量、方法。修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。（如果是<strong>基本数据类型</strong>的变量，则其数值⼀旦在初始化之后便不能更改；如果是<strong>引⽤类型</strong>的变量，则在对其初始化之后便不能再让其指向另⼀个对象。）</li><li>finally一般作用在<strong>try-catch</strong>代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾。</li></ul><h3 id="面试官：finally块中的代码什么时候被执行？"><a href="#面试官：finally块中的代码什么时候被执行？" class="headerlink" title="面试官：finally块中的代码什么时候被执行？"></a><strong>面试官</strong>：finally块中的代码什么时候被执行？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.19节）<br>在 Java 语言的异常处理中，finally 语句块的作用就是保证无论出现什么情况，finally 块里的代码一定会被执行。由于当程序执行 return 的时候就意味着结束对当前方法的调用并跳出这个方法体，任何语句要执行都只能在 return 前执行(除非碰到 exit 函数)，因此 fnally 块里的代码也是在return 前执行的。<strong>此外，如果 try-finally 或者 catch-finally 中都有 return，则 finally 块中的 return 语句将会覆盖别处的 return 语句，最终返回到调用者的是 finally 中 return 的值</strong>。下面通过两个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>从上面这个例子中可以看出，在执行 return 前确实执行了 finally 中的代码。紧接着，在 finally块里面放置 return 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>在以下</strong> <strong>3</strong> <strong>种特殊情况下，</strong> <strong>finally</strong> <strong>块不会被执⾏：</strong></p><ol><li><p>在 try 或 finally 块中⽤了 System.exit(0) 退出程序。</p></li><li><p>当程序在进入try语句块之前就出现异常的时候（int i &#x3D; 5&#x2F;0;）。</p></li><li><p>程序所在的线程死亡。</p></li><li><p>关闭 CPU。</p></li></ol><h3 id="面试官：this与super的区别"><a href="#面试官：this与super的区别" class="headerlink" title="面试官：this与super的区别"></a><strong>面试官</strong>：this与super的区别</h3><p><strong>候选人：</strong></p><ul><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h3 id="面试官：Java程序初始化的顺序可以说下吗？"><a href="#面试官：Java程序初始化的顺序可以说下吗？" class="headerlink" title="面试官：Java程序初始化的顺序可以说下吗？"></a><strong>面试官</strong>：Java程序初始化的顺序可以说下吗？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.1节）</p><p>Java程序的初始化工作可以在许多不同的代码块中来完成(例如:静态代码块、构造函数等)，它们执行的顺序为:<strong>父类静态变量</strong>→父类静态代码块→<strong>子类静态变量</strong>→子类静态代码→<strong>父类非静态变量</strong>→父类非静态代码块→父类构造方法→<strong>子类非静态变量</strong>→子类非静态代码块→子类构造方法。下面给出一个不同模块初始化时执行顺序的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Base <span class="keyword">static</span> block</span><br><span class="line">Derived <span class="keyword">static</span> block</span><br><span class="line">Base block</span><br><span class="line">Base constructor</span><br><span class="line">Derived block</span><br><span class="line">Derived constructor</span><br></pre></td></tr></table></figure><p>这里需要注意的是，(静态)非静态成员域在定义时初始化和(静态)非静态块中初始化的优先级是平级的，也就是说按照从上到下初始化，最后一次初始化为最终的值(不包括非静态的成员域在构造器中初始化)。所以在(静态)非静态块中初始化的域甚至能在该域声明的上方，因为分配存储空间在初始化之前就完成了。如下例所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="面试官：说下构造方法（构造器）吧！"><a href="#面试官：说下构造方法（构造器）吧！" class="headerlink" title="面试官：说下构造方法（构造器）吧！"></a><strong>面试官</strong>：说下构造方法（构造器）吧！</h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.2节）</p><p>Java 语言中，构造方法具有以下特点:</p><p>1）构造方法必须与类的名字相同，并且不能有返回值(返回值也不能为 void)。</p><p>2）每个类可以有多个构造方法。</p><p>3）构造方法可以有0个、1 个或1个以上的参数。</p><p>4）构造方法总是伴随着 new 操作一起调用。</p><p>5）构造方法的主要作用是完成对象的初始化工作。</p><p>6）构造方法不能被继承，因此就不能被重写(Override)，但是构造方法能够被重载(Overload)。</p><p>7）当父类和子类都没有定义构造方法的时候，编译器会为父类生成一个默认的无参数的构造方法，给子类也生成一个默认的无参数的构造方法。</p><h3 id="面试官：break、continue以及return的区别"><a href="#面试官：break、continue以及return的区别" class="headerlink" title="面试官：break、continue以及return的区别"></a><strong>面试官</strong>：break、continue以及return的区别</h3><p><strong>候选人：</strong></p><ul><li>break：跳出上一层循环，不再执行循环(结束当前的循环体)。所以，当多层循环嵌套，break 语句出现在嵌套循环中的内层循环，它将仅仅只是终止了内层循环的执行，而不影响外层循环的执行。</li></ul><blockquote><p>拓展：由于 break 只能跳出当前的循环，那么如何才能实现跳出多重循环呢?可以在多重循环的外面定义一个标识，然后在循环体里使用带有标识的 break 语句即可跳出多重循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     out:</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) <span class="keyword">break</span> out;</span><br><span class="line">             System.out.println(j);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在 C&#x2F;C++中，goto 常被用作跳出多重循环，在 Java 语言中，可以使用 break 和 continue 来达到同样的效果。那么既然 goto 没有在 Java 语言中使用，为什么还要作为保留字呢?其中一个可能的原因就是这个关键字有可能会在将来被使用。这里需要注意的是，在 Java 语言中，虽然没有 goto 语句，但是却能使用标识符加冒号 (:)的形式定义标签，其目的主要是在多重循环中方便使用 break 和 continue。</p></blockquote><ul><li>continue：跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)。简单地说，continue 只是中断一次循环的执行而己。</li><li>return：程序返回，不再执行下面的代码(结束当前的方法直接返回)。</li></ul><h3 id="面试官：-说说你对Java-中的异常处理的理解？"><a href="#面试官：-说说你对Java-中的异常处理的理解？" class="headerlink" title="面试官： 说说你对Java 中的异常处理的理解？"></a><strong>面试官</strong>： 说说你对Java 中的异常处理的理解？</h3><p>**候选人：**在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类有两个重要的⼦类 Exception （异常）和 Error （错误）。 Exception 能被程序本身处理( trycatch )， Error 是⽆法处理的(只能尽量避免)。Exception 和 Error ⼆者都是 Java 异常处理的重要⼦类，各⾃都包含⼤量⼦类。</p><ul><li><strong>Exception</strong>：程序本身可以处理的异常，可以通过 catch 来进⾏捕获。 Exception ⼜可以分为 <strong>受检异常</strong>(必须处理) 和 <strong>非受检异常</strong>(可以不处理)。</li></ul><blockquote><p><strong>受检查异常</strong>：Java 代码在编译过程中，如果受检查异常没有被 catch &#x2F; throw 处理的话，就没办法通过编译。除了 RuntimeException 及其⼦类以外，其他的 Exception 类及其⼦类都属于检查异常 。常⻅的受检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException …。</p><p><strong>不受检查异常</strong>：Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException 及其⼦类都统称为⾮受检查异常，例如： NullPointExecrption（空指针异常） 、 NumberFormatException （字符串转换为数字）、 ArrayIndexOutOfBoundsException （数组越界）、 ClassCastException （类型转换错误）等。</p></blockquote><ul><li><strong>Error</strong>：Error 属于程序⽆法处理的错误 ，我们没办法通过 catch 来进⾏捕获 。例如，Java 虚拟机运⾏错误（ Virtual MachineError ）、虚拟机内存不够错误( OutOfMemoryError )、类定义错误（NoClassDefFoundError ）等 。这些异常发⽣时，Java虚拟机（JVM）⼀般会选择线程终⽌。</li></ul><p>![image-20250218110747074](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110747074.png)</p><h3 id="面试官：-BIO-NIO-AIO-有什么区别-（高频）"><a href="#面试官：-BIO-NIO-AIO-有什么区别-（高频）" class="headerlink" title="面试官： BIO,NIO,AIO 有什么区别?（高频）"></a><strong>面试官</strong>： BIO,NIO,AIO 有什么区别?<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>BIO (Blocking I&#x2F;O):</strong>  <strong>同步阻塞</strong> I&#x2F;O 模式，数据的读取写⼊必须<strong>阻塞</strong>在⼀个线程内等待其完成（每个线程只能处理一个连接）。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型不错的，可以让每⼀个连接专注于⾃⼰的 I&#x2F;O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。但是，当⾯对⼗万甚⾄百万级连接的时候，这种方式需要创建大量的线程，而系统的资源都是有限的，大量的线程会降低系统的性能。</p></li><li><p><strong>NIO (Non-blocking I&#x2F;O):</strong> <strong>同步⾮阻塞</strong>的 I&#x2F;O 模型。NIO通过 <code>Channels , Selector，Buffers</code> 来实现非阻塞的IO操作。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I&#x2F;O 操作⽅法。它最主要的特点是，提供了基于Selector的异步网络I&#x2F;O，使得一个线程可以管理多个连接。</p><p>（图片源自《Java程序员面试笔试宝典》第二版 2.4节）</p><p>![image-20250218110800609](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110800609.png)</p></li></ul><blockquote><p>扩展：Channel（通道） , Selector（选择器），Buffer（缓冲区）</p><p>(1) Channel(通道)<br>为了更容易地理解什么是 <code>Channel</code>，这里以 <code>InputStream</code> 为例来介绍什么是 <code>Channel</code>。传统的 IO 中经常使用下面的代码来读取文件(此处忽略异常处理):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;imput.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">byte</span>[] tempbyte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((tempbyte=is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><p><code>InputStream</code> 其实就是一个用来读取文件的通道。只不过 <code>InputStream</code> 是一个单向的通道，只能用来读取数据。而 NIO 中的 <code>Channel</code> 是一个双向的通道，不仅能读取数据，而且还能写入数据。</p><p>(2) Buffer(缓冲区)<br>在上面的示例代码中，<code>InputSteam</code> 把读取到的数据放在了 byte 数组中，如果用 <code>OutputSteam</code> 写数据，那么也可以把 byte 数组中的数据<strong>写到文件</strong>中。而在 NIO 中，数据只能被<strong>写到 Buffer</strong> 中，同理读取的数据也只能放在 Buffer 中，由此可见 Bufer 是 Channel 用来读写数据的非常重要的一个工具。</p><p>![image-20250218110814433](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110814433.png)</p><p>(3) Selector(选择器)<br><code>Selector</code> 是 NIO 中最重要的部分，是实现一个线程管理多个连接的关键，它的作用就是<strong>轮询</strong>所有被注册的<code>Channel</code>，一旦发现 <code>Channel</code> 上被注册的事件发生，就可以对这个事件进行处理。</p></blockquote><ul><li><strong>AIO (Asynchronous I&#x2F;O):</strong> AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是<strong>异步⾮阻塞</strong>的 IO 模型。虽然 NIO 在⽹络操作中，也提供了⾮阻塞的⽅法，但它本身仍然是同步的，选择器仍然需要通过<strong>轮询</strong>主动检查数据请求。而异步 IO （AIO）是<strong>基于事件和回调机制</strong>实现的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</li></ul><h3 id="面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"><a href="#面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？" class="headerlink" title="**面试官：**NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"></a>**面试官：**NIO是如何实现同步非阻塞的？主线程是只有一个嘛？</h3><p><strong>候选人：</strong></p><p>在NIO中，使用了多路复用器Selector来实现同步非阻塞的IO操作。Selector是一个可以监控多个通道（Channel）是否有数据可读或可写的对象，当一个或多个Channel准备好读或写时，Selector会通知程序进行读写操作，而不是像BIO一样阻塞等待IO操作完成。</p><p>在NIO中，主线程<strong>通常只有一个</strong>，但是可以使用Selector来管理多个Channel，实现多个连接的非阻塞读写操作。当有多个Channel需要进行IO操作时，Selector会<strong>轮询</strong>这些Channel，检查它们的状态是否可读或可写，如果有可读或可写的Channel，就将其加入到一个已选择键集合中，等待程序处理。这样，一个线程就可以同时处理多个Channel，提高了系统的并发处理能力。</p><h3 id="面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"><a href="#面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）" class="headerlink" title="面试官： 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"></a><strong>面试官：</strong> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？<code>（高频）</code></h3><ul><li><p>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接<strong>复制内部对象的引用地址</strong>，也就是说<strong>拷贝对象和原对象共用同一个内部对象</strong>。浅拷贝实现简单，使用 <code>clone()</code> 即可。</p></li><li><p>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。**增加了一个指针并且申请了一个新的内存，使这个新增的指针指向新的内存。**深拷贝需要递归复制或序列化，实现较复杂。</p><blockquote><p>联想：在租房的场景中，租客和房东共享房子的使用权，任何改动都会影响对方；而在买房的场景中，买方拥有独立的房子，可以自由改造而不影响他人。通过租房和买房的类比，轻松理解浅拷贝和深拷贝的不同。</p><p>浅拷贝 → 租房（租客和房东共享房子，改动家具会影响房东）。</p><p>深拷贝 → 买房（买房后拥有完全独立的房子，改动家具不会影响房东）。</p></blockquote></li></ul><p>**那什么是引用拷贝呢？**简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p>![image-20250303092129835](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250303092129835.png)</p><h3 id="面试官：-什么是泛型？有什么作用？（高频）"><a href="#面试官：-什么是泛型？有什么作用？（高频）" class="headerlink" title="**面试官：**什么是泛型？有什么作用？（高频）"></a>**面试官：**什么是泛型？有什么作用？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>泛型是一种在编译时提供类型安全检查的机制，它允许我们将类型作为参数传递给类、接口或方法，从而避免硬编码具体的类型。通过泛型，我们可以编写适用于多种数据类型的代码，同时确保类型安全。</p><p>泛型的作用主要有4点：</p><p>第一点是<strong>提高代码的复用性</strong>，它允许我们编写与类型无关的通用代码。</p><p>第二点是<strong>增强类型安全性</strong>，在没有泛型的情况下，集合类（如 ArrayList）默认存储的是 Object 类型，取出元素时需要手动进行类型转换，容易引发 ClassCastException。而泛型在编译时就会进行类型检查，避免了运行时的类型错误。</p><p>第三点是<strong>简化代码</strong>，使用泛型后，我们无需显式地进行类型转换，减少了冗余代码，提高了代码的可读性和维护性。</p><p>第四点是<strong>支持复杂的类型约束</strong>，泛型可以通过通配符（如 ? extends T 和 ? super T）实现更复杂的类型限制，满足特定场景下的需求。</p><h3 id="面试官：-Java反射机制以及获取反射对象的几种方式（高频）"><a href="#面试官：-Java反射机制以及获取反射对象的几种方式（高频）" class="headerlink" title="**面试官：**Java反射机制以及获取反射对象的几种方式（高频）"></a>**面试官：**Java反射机制以及获取反射对象的几种方式<code>（高频）</code></h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.4节）</p><p>在Java语言中，反射机制是指对于运行时类，都能够动态地获取到这个类的所有属性和方法。对于任意的一个对象，都能够调用它的任意一个方法以及访问它的属性；这种动态地获取类或对象的属性以及方法从而完成调用功能被称为Java语言的反射机制。</p><p>反射机制中Class是一个非常重要的类，在Java语言中获取Class对象主要有如下几种方法。</p><ol><li>通过<code>.class</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = A.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>Class.forName()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="3"><li>通过<code>.getClass()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">new</span> <span class="title class_">A</span>().getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">dynamic block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><p>从上面的例子可知，虽然这三种方式都可以获得类的Class对象，但是它们还是有区别的，主要区别如下所示：</p><p>方法1）<strong>不执行静态块和普通代码块</strong></p><p>方法2）<strong>只执行静态块，而不执行普通代码块</strong></p><p>方法3）<strong>因为需要创建对象，所以会执行静态块和普通代码块</strong></p><h3 id="面试官：-Java创建对象除了new还有别的什么方式"><a href="#面试官：-Java创建对象除了new还有别的什么方式" class="headerlink" title="**面试官：**Java创建对象除了new还有别的什么方式?"></a>**面试官：**Java创建对象除了new还有别的什么方式?</h3><p><strong>候选人：</strong></p><ul><li><p><strong>通过反射创建对象</strong>:通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newinstance() 方法或者通过 Constructor 类来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; clazz=MyClass.class;</span><br><span class="line">    MyClass obj=(MyClass)clazz.newInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过反序列化创建对象</strong>:通过将对象序列化(保存到文件或网络传输)然后再反序列化(从文件或网络传输中读取对象)的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Serialize object</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialize object</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过clone创建对象</strong>:所有 Java 对象都继承自 Object 类，Object 类中有一个 clone()方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
