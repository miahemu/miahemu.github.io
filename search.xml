<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux、Git常用命令</title>
      <link href="/2025/03/29/Linux%E3%80%81Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/03/29/Linux%E3%80%81Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-常用命令："><a href="#Linux-常用命令：" class="headerlink" title="Linux 常用命令："></a>Linux 常用命令：</h2><p><img src="https://pic1.imgdb.cn/item/67e81d540ba3d5a1d7e68b82.png" alt="image-20250307111331880"></p><p><img src="https://pic1.imgdb.cn/item/67e81d540ba3d5a1d7e68b83.png" alt="image-20250307111343336"></p><p><img src="https://pic1.imgdb.cn/item/67e81d540ba3d5a1d7e68b84.png" alt="image-20250307111349183"></p><blockquote><p>**常用命令：**如果发现某一端口号被占用（例如8082）时（<strong>MacOS和Linux系统</strong>）：</p><p>[sudo 命令]全称“SuperUser Do”，是Linux系统中的一个命令能够使普通用户以超级用户身份去执行某些命令。</p><p><img src="https://pic1.imgdb.cn/item/67e81d7d0ba3d5a1d7e68b8d.png" alt="image-20250228103857630"></p></blockquote><hr><h2 id="Git常用命令："><a href="#Git常用命令：" class="headerlink" title="Git常用命令："></a>Git常用命令：</h2><h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><ul><li><strong>git init</strong>: 初始化一个新的 Git 仓库</li><li><strong>git clone</strong> : 克隆远程仓库到本地</li><li><strong>git status</strong>: 查看当前工作区和暂存区的状态</li><li><strong>git add :</strong> 将文件添加到暂存区<ul><li><code>git add .</code>: 添加当前目录下所有更改的文件到暂存区</li></ul></li><li><strong>git commit -m “message”</strong>: 提交暂存区的更改到本地仓库</li><li><strong>git log:</strong> 查看提交历史记录<ul><li><code>git log --oneline</code>: 以简洁的单行方式查看提交历史</li></ul></li></ul><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li><strong>git branch:</strong> 查看当前分支列表<ul><li><code>git branch &lt;branch-name&gt;</code>: 创建新分支</li><li><code>git branch -d &lt;branch-name&gt;</code>: 删除本地分支</li></ul></li><li><strong>git checkout :</strong> 切换到指定分支<ul><li><code>git checkout -b &lt;branch-name&gt;</code>: 创建并切换到新分支</li></ul></li><li><strong>git merge</strong> : 合并指定分支到当前分支</li><li><strong>git rebase</strong> : 基于指定分支进行变基操作，通常用于保持提交历史的整洁</li></ul><h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><ul><li><strong>git remote -v</strong>: 查看远程仓库地址</li><li><strong>git remote add</strong>  : 添加远程仓库</li><li><strong>git push  :</strong> 将本地分支推送到远程仓库<ul><li><code>git push origin master</code>: 将 <code>master</code> 分支推送到 <code>origin</code> 远程仓库</li></ul></li><li><strong>git pull  :</strong> 从远程仓库拉取更新并合并到当前分支<ul><li><code>git pull origin master</code>: 从 <code>origin</code> 的 <code>master</code> 分支拉取更新</li></ul></li><li><strong>git fetch</strong> : 获取远程仓库的更新，但不自动合并</li></ul><h3 id="文件和工作区操作"><a href="#文件和工作区操作" class="headerlink" title="文件和工作区操作"></a>文件和工作区操作</h3><ul><li><strong>git restore</strong> : 恢复工作区文件至上次提交状态</li><li><strong>git reset :</strong> 将文件从暂存区移除，保留本地修改<ul><li><code>git reset --hard</code>: 重置工作区和暂存区，丢弃所有未提交的更改</li></ul></li></ul><h3 id="历史回退"><a href="#历史回退" class="headerlink" title="历史回退"></a>历史回退</h3><ul><li><strong>git revert</strong> : 创建一个新的提交来撤销某次提交的修改</li><li><strong>git reset –hard</strong> : 回退到指定的提交，丢弃当前工作区和暂存区的更改<ul><li><code>git reset --hard HEAD~1</code>: 回退到上一个提交</li></ul></li></ul><h3 id="合作与冲突"><a href="#合作与冲突" class="headerlink" title="合作与冲突"></a>合作与冲突</h3><ul><li><strong>git stash</strong>: 临时保存当前工作区的更改</li><li><strong>git stash pop</strong>: 恢复并删除最近的 stash</li><li><strong>git merge –abort</strong>: 在合并冲突时中止合并操作</li></ul><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul><li><strong>git config –global user.name “Your Name”</strong>: 设置全局用户名</li><li><strong>git config –global user.email “<a href="mailto:&#121;&#x6f;&#x75;&#x72;&#101;&#109;&#97;&#105;&#x6c;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;">juechen@gmail.com</a>“</strong>: 设置全局用户邮箱</li><li><strong>git config –list</strong>: 查看当前的 Git 配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十道海量数据处理面试题与十个方法总结</title>
      <link href="/2025/03/29/%E5%8D%81%E9%81%93%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E5%8D%81%E4%B8%AA%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2025/03/29/%E5%8D%81%E9%81%93%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E5%8D%81%E4%B8%AA%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、十道海量数据处理面试题"><a href="#一、十道海量数据处理面试题" class="headerlink" title="一、十道海量数据处理面试题"></a><strong>一、十道海量数据处理面试题</strong></h2><h3 id="♟️1、海量日志数据，提取出某日访问百度次数最多的那个IP。-分治思想-哈希表"><a href="#♟️1、海量日志数据，提取出某日访问百度次数最多的那个IP。-分治思想-哈希表" class="headerlink" title="♟️1、海量日志数据，提取出某日访问百度次数最多的那个IP。(分治思想 + 哈希表)"></a>♟️<strong>1、海量日志数据，提取出某日访问百度次数最多的那个IP。</strong><code>(分治思想 + 哈希表)</code></h3><ol><li><p>首先，从日志中提取出所有访问百度的IP地址，将它们逐个写入一个大文件中，便于后续处理。</p></li><li><p>考虑到IP地址是32位的，最多有 2^23 个不同IP。为了减少单个文件的处理压力，可以采用哈希或者取模的方式，将这些IP均匀分散到 <strong>1000个小文件</strong> 中。这样每个小文件的规模大幅缩小，更便于处理。</p></li><li><p>对于每个小文件，使用 <strong>HashMap</strong> 统计每个IP的出现次数。HashMap的插入和查找操作都是 O(1) 的复杂度，能够高效地完成频率统计。然后从中找出出现频率最高的IP和对应的频率。</p></li><li><p>最后，将这 <strong>1000个小文件</strong> 中统计出的最高频率IP和频率值汇总。再在这1000个IP中执行一次线性扫描，找到频率最高的IP，得到最终结果。</p></li></ol><hr><h3 id="♟️2、在1千万个查询记录中，去重后不超过300万个，要求在内存不超过1G的情况下，统计出最热门的10个查询串。-典型的-Top-K-问题"><a href="#♟️2、在1千万个查询记录中，去重后不超过300万个，要求在内存不超过1G的情况下，统计出最热门的10个查询串。-典型的-Top-K-问题" class="headerlink" title="♟️2、在1千万个查询记录中，去重后不超过300万个，要求在内存不超过1G的情况下，统计出最热门的10个查询串。(典型的 Top K 问题)"></a>♟️<strong>2、在1千万个查询记录中，去重后不超过300万个，要求在内存不超过1G的情况下，统计出最热门的10个查询串。</strong><code>(典型的 Top K 问题)</code></h3><p>该问题是典型的 <strong>Top K</strong> 问题，可以通过以下两种方法解决：</p><p><strong>1. Hash + 小根堆方法：</strong><br> 首先，使用 <strong>Hash表</strong> 在 O(N) 的时间复杂度下统计所有查询串的出现次数。然后，使用一个大小为 <strong>K（10）</strong> 的 <strong>小根堆</strong> 来维护出现频率最高的查询串。在遍历300万个查询串的统计结果时，每次与堆顶元素比较，如果出现次数更高，则替换堆顶元素并重新调整堆。最终得到Top 10的查询串。总体时间复杂度为 O(N)+O(N′log⁡K)。</p><p><strong>2. Trie树 + 小根堆方法：</strong><br> 构建一个 <strong>Trie树</strong>，将所有查询串插入其中，同时在Trie树的节点中记录每个查询串的出现次数。这样可以有效地管理和存储大量查询串。最后，再使用一个大小为 <strong>10</strong> 的小根堆，对Trie树中存储的查询串进行排序，找出出现次数最多的Top 10。该方法在查询串较长时，空间效率较高。</p><hr><h3 id="♟️3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。-分治思想-哈希表"><a href="#♟️3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。-分治思想-哈希表" class="headerlink" title="♟️3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。(分治思想 + 哈希表)"></a>♟️<strong>3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</strong><code>(分治思想 + 哈希表)</code></h3><ol><li><p>顺序读取数据，对每个词 <strong>x</strong> 进行哈希操作 <strong>hash(x) % 5000</strong>，将词分配到5000个小文件中，每个文件约200KB。</p></li><li><p>如果某个文件超过1MB，可继续使用类似的方法将其划分为更小的文件，直到所有小文件的大小都不超过1MB。</p></li><li><p>对每个小文件，使用 <strong>Trie树</strong> 或 <strong>HashMap</strong> 统计词频，并通过维护一个<strong>100个节点的小根堆</strong>，选出出现频率最高的100个词，将结果存入文件。</p></li><li><p>最终，对这5000个文件进行类似于 <strong>归并排序</strong> 的过程，整合并找到全局出现频率最高的词。</p></li></ol><hr><h3 id="♟️4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。-典型的-Top-K-问题"><a href="#♟️4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。-典型的-Top-K-问题" class="headerlink" title="♟️4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。(典型的 Top K 问题)"></a><strong>♟️4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</strong><code>(典型的 Top K 问题)</code></h3><p>该问题是典型的 <strong>Top K</strong> 问题，可以通过以下三种方案解决：</p><p><strong>1. 分割+归并排序方案：</strong><br> 首先，将数据顺序读取，并根据 <strong>hash(query) % 10</strong> 将查询串分配到另外10个小文件中，每个文件约1G。然后在一台 <strong>内存2G</strong> 的机器上，使用 <strong>HashMap</strong> 统计每个查询串的出现次数，再通过 <strong>快速排序</strong>、<strong>堆排序</strong> 或 <strong>归并排序</strong> 进行排序。最终，将这10个排好序的文件进行<strong>归并排序</strong>，得到最终的结果。</p><p><strong>2. 直接内存统计方案：</strong><br> 如果所有的查询串总量有限，可以直接将它们加载到内存中，使用 <strong>Trie树</strong> 或 <strong>HashMap</strong> 统计每个查询串的出现次数。之后，通过排序算法快速获取出现次数最多的查询串。</p><p><strong>3. 分布式处理方案：</strong><br> 与方案1类似，数据分割后分配到多个小文件中，但进一步采用 <strong>分布式架构</strong>（如 <strong>MapReduce</strong>）进行并行处理。各节点分别统计和排序后，将结果合并，进一步提升处理效率。</p><hr><p>　</p><h3 id="♟️5、-给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？-分治法-布隆过滤器"><a href="#♟️5、-给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？-分治法-布隆过滤器" class="headerlink" title="♟️5、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？(分治法/布隆过滤器)"></a>♟️<strong>5、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</strong><code>(分治法/布隆过滤器)</code></h3><p>该问题涉及 <strong>大规模数据去重和求交集</strong>，可通过以下两种方案解决：</p><p><strong>1. 分治法方案：</strong><br> 由于数据量过大无法直接加载到内存中，采用 <strong>分治法</strong>。</p><ul><li><strong>第一步</strong>：对两个文件分别按 <strong>hash(url) % 1000</strong> 进行划分，生成1000对小文件。这样每个小文件的大约为300M，同一哈希值的URL存储在对应的小文件中。</li><li><strong>第二步</strong>：对于每对小文件（如a0和b0），使用 <strong>HashSet</strong> 存储其中一个小文件的URL，再遍历另一个小文件，对比URL是否存在于HashSet中，找出共同的URL。</li></ul><p><strong>2. Bloom Filter方案：</strong><br> 如果允许一定的<strong>错误率</strong>，可以使用 <strong>Bloom Filter</strong>。</p><ul><li><strong>第一步</strong>：使用 <strong>4G内存</strong>（约340亿bit）将一个文件的URL映射到Bloom Filter中。</li><li><strong>第二步</strong>：读取另一个文件的URL，逐个检查是否在Bloom Filter中，若存在则认为是可能的共同URL。由于Bloom Filter存在误判的可能性，结果需要进一步验证。</li></ul><hr><h3 id="♟️6、在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。-Bitmap、分治法"><a href="#♟️6、在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。-Bitmap、分治法" class="headerlink" title="♟️6、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。(Bitmap、分治法)"></a>♟️<strong>6、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</strong><code>(Bitmap、分治法)</code></h3><p>该问题涉及 <strong>大规模数据去重和查找唯一整数</strong>，可通过以下两种方案解决：</p><p><strong>1. Bitmap方案：</strong></p><ul><li><strong>原理</strong>：使用 <strong>Bitmap</strong> 为每个整数分配 <strong>2bit</strong> 来表示状态：<ul><li><strong>00</strong>：不存在</li><li><strong>01</strong>：出现一次</li><li><strong>10</strong>：出现多次</li><li><strong>11</strong>：无意义</li></ul></li><li><strong>步骤</strong>：扫描整数文件，更新Bitmap状态。扫描完成后，再遍历Bitmap，输出所有状态为 <strong>01</strong> 的整数，即为不重复的整数。由于Bitmap占用内存较小，适用于数据量较大的场景。</li></ul><p><strong>2. 分治法方案：</strong></p><ul><li><strong>原理</strong>：如果数据量过大，可以采用 <strong>分治法</strong>。</li><li><strong>步骤</strong>：将数据按 <strong>hash(num) % N</strong> 进行划分，存入 <strong>N个小文件</strong> 中，确保同一整数存入同一个文件。对每个小文件使用HashMap或Bitmap统计整数出现次数。然后再排序和归并这些小文件，同时去重，最终输出不重复的整数。<br> 此方法在内存受限时非常有效。</li></ul><hr><h3 id="♟️7、腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#♟️7、腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="♟️7、腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>♟️<strong>7、腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</strong></h3><p>该问题涉及 <strong>大规模数据查找和去重</strong>，可通过以下两种方案解决：</p><p><strong>1. 位图法（Bitmap）方案：</strong><br> 申请 <strong>512M内存</strong>，使用 <strong>1bit</strong> 表示一个无符号整数的存在状态。读取40亿个数时，将对应位置的bit置为1。查询时，只需检查该位置的bit是否为1，即可判断数是否存在。此方法内存占用小，查询效率高。</p><p><strong>2. 分治法（二分查找）方案：</strong><br> 根据数的 <strong>最高位</strong> 将数据划分为两个文件，一个存储最高位为0的数，另一个存储最高位为1的数。根据查询数的最高位，选择对应的文件继续查找。重复这一过程，每次根据下一位划分数据，类似 <strong>二分查找</strong>，最终以 O(log⁡n) 的时间复杂度定位查询数。此方法适用于超大数据集的查找。</p><hr><h3 id="♟️8、怎么在海量数据中找出重复次数最多的一个？"><a href="#♟️8、怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="♟️8、怎么在海量数据中找出重复次数最多的一个？"></a>♟️<strong>8、怎么在海量数据中找出重复次数最多的一个？</strong></h3><p> 先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><hr><h3 id="♟️9、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。"><a href="#♟️9、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。" class="headerlink" title="♟️9、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。"></a>♟️<strong>9、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</strong></h3><p>上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用<strong>hashmap&#x2F;搜索二叉树&#x2F;红黑树</strong>等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p><hr><h3 id="♟️10、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"><a href="#♟️10、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。" class="headerlink" title="♟️10、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"></a>♟️<strong>10、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</strong></h3><p>这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(nle)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(nlg10)。所以总的时间复杂度，是O(nle)与O(nlg10)中较大的那一个。</p><hr><h2 id="二、海量数据处理的十大方法总结"><a href="#二、海量数据处理的十大方法总结" class="headerlink" title="二、海量数据处理的十大方法总结"></a><strong>二、海量数据处理的十大方法总结</strong></h2><p>在面对超大数据时，无法一次性加载到内存中处理。这时就需要一些高效的算法和数据结构。以下是10个常用方法的详细总结，包含原理、适用场景和典型问题示例。</p><hr><h3 id="📌-1-Bloom-Filter（布隆过滤器）"><a href="#📌-1-Bloom-Filter（布隆过滤器）" class="headerlink" title="📌 1. Bloom Filter（布隆过滤器）"></a>📌 <strong>1. Bloom Filter（布隆过滤器）</strong></h3><p><strong>用途</strong></p><ul><li>判断某个数据是否存在于集合中。</li><li>适合快速去重、检测数据是否存在。</li></ul><p><strong>原理</strong></p><ul><li>使用一个位数组和多个哈希函数。</li><li>插入数据时，将数据用哈希函数计算多个位置，将这些位置的位设为1。</li><li>判断数据是否存在时，检查所有对应的位是否为1。</li><li><strong>注意</strong>：布隆过滤器会有<strong>假阳性</strong>（误判为存在），但不会有假阴性。</li></ul><p><strong>优化</strong></p><ul><li><strong>Counting Bloom Filter</strong>：用计数器代替位数组，支持删除操作。</li><li><strong>Spectral Bloom Filter</strong>：支持统计元素的频次。</li></ul><p><strong>典型场景</strong></p><ul><li>URL去重：检测某个网页是否已被爬取。</li><li>垃圾邮件检测：判断是否是已知垃圾邮件。</li><li>广告反欺诈：检测是否重复点击广告。</li></ul><hr><h3 id="📌-2-Hashing（哈希）"><a href="#📌-2-Hashing（哈希）" class="headerlink" title="📌 2. Hashing（哈希）"></a>📌 <strong>2. Hashing（哈希）</strong></h3><p><strong>用途</strong></p><ul><li>数据快速查找、统计和去重。</li></ul><p><strong>原理</strong></p><ul><li>使用哈希函数将数据映射到固定大小的哈希表中。</li><li>通过哈希表存储键值对，O(1)的时间复杂度完成查找和插入。</li><li>解决哈希冲突的方式：<strong>链地址法</strong>、<strong>开放地址法</strong>。</li></ul><p><strong>典型场景</strong></p><ul><li>统计某日访问量最大的IP地址。</li><li>判断两个大文件中是否有重复的记录。</li></ul><hr><h3 id="📌-3-Bitmap（位图）"><a href="#📌-3-Bitmap（位图）" class="headerlink" title="📌 3. Bitmap（位图）"></a>📌 <strong>3. Bitmap（位图）</strong></h3><p><strong>用途</strong></p><ul><li>占用极少的空间判断数据是否存在或进行数据去重。</li><li>适用于数据范围大但数据量相对较小的场景。</li></ul><p><strong>原理</strong></p><ul><li>用每一位（bit）表示一个数据的存在状态。</li><li>数据值直接映射到位数组中的索引位置，置1表示存在。</li></ul><p><strong>优化</strong></p><ul><li>使用<strong>多bit位图</strong>可以统计数据的出现次数。</li></ul><p><strong>典型场景</strong></p><ul><li>统计某个地区的所有电话号码。</li><li>2.5亿个整数中找出不重复的整数。</li></ul><hr><h3 id="📌-4-Heap（堆）"><a href="#📌-4-Heap（堆）" class="headerlink" title="📌 4. Heap（堆）"></a>📌 <strong>4. Heap（堆）</strong></h3><p><strong>用途</strong></p><ul><li>快速找出前N大的数据或前N小的数据。</li></ul><p><strong>原理</strong></p><ul><li>使用最小堆或最大堆。</li><li>当需要找前N大的数据时，用一个大小为N的最小堆。</li><li>每次遇到更大的数据时替换堆顶元素。</li></ul><p><strong>典型场景</strong></p><ul><li>找出100万个数中最大的前100个数。</li><li>实时监控系统中检测前N个异常事件。</li></ul><hr><h3 id="📌-5-分治法（双层桶划分）"><a href="#📌-5-分治法（双层桶划分）" class="headerlink" title="📌 5. 分治法（双层桶划分）"></a>📌 <strong>5. 分治法（双层桶划分）</strong></h3><p><strong>用途</strong></p><ul><li>解决无法一次性加载到内存的大数据问题。</li><li>适合找中位数、第K大元素或去重等问题。</li></ul><p><strong>原理</strong></p><ul><li>通过哈希函数或简单取模的方式，将数据划分到多个桶中。</li><li>每个桶的大小控制在内存可处理的范围内。</li><li>在桶内继续执行相关操作。</li></ul><p><strong>典型场景</strong></p><ul><li>找出5亿个整数的中位数。</li><li>找出2.5亿个整数中不重复的整数。</li></ul><hr><h3 id="📌-6-数据库索引"><a href="#📌-6-数据库索引" class="headerlink" title="📌 6. 数据库索引"></a>📌 <strong>6. 数据库索引</strong></h3><p><strong>用途</strong></p><ul><li>提高大规模数据的查询效率。</li></ul><p><strong>原理</strong></p><ul><li>数据库通过B+树或哈希索引等结构，为表中的字段创建索引。</li><li>查询时通过索引快速定位数据，而不是全表扫描。</li></ul><p><strong>典型场景</strong></p><ul><li>电商平台中商品的快速查询。</li><li>银行系统中的账户查询。</li></ul><hr><h3 id="📌-7-倒排索引（Inverted-Index）"><a href="#📌-7-倒排索引（Inverted-Index）" class="headerlink" title="📌 7. 倒排索引（Inverted Index）"></a>📌 <strong>7. 倒排索引（Inverted Index）</strong></h3><p><strong>用途</strong></p><ul><li>用于关键词搜索场景。</li><li>搜索引擎等文本数据场景。</li></ul><p><strong>原理</strong></p><ul><li>每个单词对应一个文档列表，记录出现位置和频率。</li><li>搜索时将关键词对应的文档列表取交集，快速获取结果。</li></ul><p><strong>典型场景</strong></p><ul><li>搜索引擎中查找包含某个关键词的文章。</li><li>论文数据库中查找包含指定关键词的论文。</li></ul><hr><h3 id="📌-8-外排序"><a href="#📌-8-外排序" class="headerlink" title="📌 8. 外排序"></a>📌 <strong>8. 外排序</strong></h3><p><strong>用途</strong></p><ul><li>对无法全部加载到内存中的数据进行排序。</li></ul><p><strong>原理</strong></p><ul><li>使用<strong>归并排序</strong>和<strong>分块排序</strong>的思想。</li><li>将数据分割为若干小块，每块在内存中排序后存储到磁盘。</li><li>最后使用多路归并排序合并结果。</li></ul><p><strong>典型场景</strong></p><ul><li>处理1G大小的文本文件，内存仅有1M的情况。</li><li>大型日志文件的排序与分析。</li></ul><hr><h3 id="📌-9-Trie树"><a href="#📌-9-Trie树" class="headerlink" title="📌 9. Trie树"></a>📌 <strong>9. Trie树</strong></h3><p><strong>用途</strong></p><ul><li>快速查找和前缀匹配。</li><li>适用于海量字符串数据的存储与搜索。</li></ul><p><strong>原理</strong></p><ul><li>使用树状结构存储字符串，每个节点代表一个字符。</li><li>查询时根据字符逐层匹配，时间复杂度为O(L)，L为字符串长度。</li></ul><p><strong>优化</strong></p><ul><li><strong>压缩Trie树</strong>：减少节点数量。</li></ul><p><strong>典型场景</strong></p><ul><li>搜索引擎的自动补全和联想词推荐。</li><li>查询重复的搜索关键词。</li></ul><hr><h3 id="📌-10-分布式处理（MapReduce）"><a href="#📌-10-分布式处理（MapReduce）" class="headerlink" title="📌 10. 分布式处理（MapReduce）"></a>📌 <strong>10. 分布式处理（MapReduce）</strong></h3><p><strong>用途</strong></p><ul><li>处理超大规模的数据集，常用于分布式环境。</li></ul><p><strong>原理</strong></p><ul><li><strong>Map阶段</strong>：将数据分割并分发到多台机器上进行并行计算。</li><li><strong>Reduce阶段</strong>：对Map阶段的结果进行归约，得到最终结果。</li></ul><p><strong>典型场景</strong></p><ul><li>日志分析：统计日志中不同类型的访问次数。</li><li>计算全网用户的行为数据。</li></ul><hr><h2 id="🚀-总结与对比"><a href="#🚀-总结与对比" class="headerlink" title="🚀 总结与对比"></a>🚀 <strong>总结与对比</strong></h2><table><thead><tr><th align="left">方法</th><th align="left">主要用途</th><th>优点</th><th>缺点</th><th align="left">典型场景</th></tr></thead><tbody><tr><td align="left">Bloom Filter</td><td align="left">数据判重</td><td>占用内存少、效率高</td><td>有误判率，不支持删除</td><td align="left">URL去重、垃圾邮件检测</td></tr><tr><td align="left">Hashing</td><td align="left">快速查找和统计</td><td>查找速度快</td><td>可能发生哈希冲突</td><td align="left">IP访问统计、数据去重</td></tr><tr><td align="left">Bitmap</td><td align="left">存储和判断数据是否存在</td><td>节省内存空间</td><td>仅适合整数等有限范围数据</td><td align="left">电话号码去重、整数计数</td></tr><tr><td align="left">Heap</td><td align="left">前N大或前N小</td><td>时间复杂度低</td><td>不适合全量排序</td><td align="left">实时监控异常数据</td></tr><tr><td align="left">分治法</td><td align="left">数据划分处理</td><td>适合大规模数据</td><td>需要多次扫描数据</td><td align="left">找中位数、查找不重复数据</td></tr><tr><td align="left">数据库索引</td><td align="left">快速查询</td><td>查询效率高</td><td>需要额外存储空间</td><td align="left">电商商品查询、用户查询</td></tr><tr><td align="left">倒排索引</td><td align="left">关键词搜索</td><td>查询速度快</td><td>建索引耗时较长</td><td align="left">搜索引擎、论文检索</td></tr><tr><td align="left">外排序</td><td align="left">数据排序</td><td>适合超大数据集</td><td>需要磁盘I&#x2F;O</td><td align="left">大型日志排序</td></tr><tr><td align="left">Trie树</td><td align="left">字符串查找</td><td>前缀匹配高效</td><td>空间占用大</td><td align="left">搜索联想、词频统计</td></tr><tr><td align="left">MapReduce</td><td align="left">分布式数据处理</td><td>并行处理速度快</td><td>部署复杂</td><td align="left">日志分析、用户行为分析</td></tr></tbody></table><h2 id="三、海量数据中找出现次数最多的前N个数据的解决方案"><a href="#三、海量数据中找出现次数最多的前N个数据的解决方案" class="headerlink" title="三、海量数据中找出现次数最多的前N个数据的解决方案"></a><strong>三、海量数据中找出现次数最多的前N个数据的解决方案</strong></h2><p>在处理海量数据时，主要分为<strong>可一次读入内存</strong>和<strong>不可一次读入内存</strong>两种情况。针对这两种场景，有多种解决思路和优化策略。</p><hr><h3 id="情况一：数据可一次读入内存"><a href="#情况一：数据可一次读入内存" class="headerlink" title="情况一：数据可一次读入内存"></a><strong>情况一：数据可一次读入内存</strong></h3><p>当数据量经过去重后，可以一次性读入内存时，推荐使用<strong>HashMap</strong>或<strong>Trie树</strong>进行数据统计。HashMap通过键值对存储数据及其出现次数，Trie树在处理字符串类数据时尤为高效。</p><p>在统计完成后，可以利用<strong>小顶堆</strong>维护出现次数最多的前N个数据。每次比较当前数据与堆顶元素，如果当前数据出现次数更高，则替换堆顶元素。小顶堆的插入和删除操作的时间复杂度为 O(log⁡N)，在大数据量中表现优越。</p><p>如果数据存在较多重复，可以先使用**布隆过滤器（Bloom Filter）**进行判重，减少内存占用和计算量。对于需要进一步优化的场景，可以使用优先队列替代小顶堆，减少堆的维护成本。</p><hr><h3 id="情况二：数据无法一次读入内存"><a href="#情况二：数据无法一次读入内存" class="headerlink" title="情况二：数据无法一次读入内存"></a><strong>情况二：数据无法一次读入内存</strong></h3><p>当数据量过大，无法全部加载到内存中时，有以下几种解决方案：</p><h4 id="1-分布式计算（MapReduce）"><a href="#1-分布式计算（MapReduce）" class="headerlink" title="1. 分布式计算（MapReduce）"></a><strong>1. 分布式计算（MapReduce）</strong></h4><p>分布式计算是解决超大规模数据的常用方法。通过<strong>MapReduce</strong>将数据划分到多台机器，每台机器处理不同的数据分区。</p><p>在Map阶段，机器会对数据进行局部统计，得到当前分区内的Top N数据。随后在Reduce阶段，各个机器的结果会被汇总并合并，再次取Top N，最终得到全局前N个数据。</p><p>分布式计算适用于数据规模极大且需要快速响应的场景，常用于日志分析、搜索引擎等。</p><h4 id="2-数据分区-单机处理"><a href="#2-数据分区-单机处理" class="headerlink" title="2. 数据分区 + 单机处理"></a><strong>2. 数据分区 + 单机处理</strong></h4><p>如果没有分布式环境，可以手动进行数据分区。根据数据的特征，可以选择哈希取模或按数据范围划分，将数据写入不同的子文件。</p><p>对于每个子文件，采用与内存场景类似的方法进行统计和堆排序。最后再对这些中间结果执行归并排序，取前N个数据。</p><p>这种方法充分利用了磁盘存储能力，解决了内存不足的问题，且相较于分布式计算更加经济。</p><h4 id="3-近似统计"><a href="#3-近似统计" class="headerlink" title="3. 近似统计"></a><strong>3. 近似统计</strong></h4><p>在某些场景下，获取一个近似的Top N结果即可满足需求。这时可以使用<strong>Count-Min Sketch</strong>等概率统计方法，快速估算数据的出现频率。</p><p>Count-Min Sketch采用哈希映射，将数据映射到一个二维数组中。通过多次哈希计算，得到数据的频率估计值。虽然有一定误差，但在流式数据处理中非常高效。</p><p>此外，如果只需要热门数据，还可以通过<strong>LRU缓存</strong>或<strong>滑动窗口</strong>等方法进行实时监控，适合日志监控和异常检测等场景。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统相关面试题</title>
      <link href="/2025/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h3 id="面试官：-进程和线程的区别（高频）"><a href="#面试官：-进程和线程的区别（高频）" class="headerlink" title="面试官： 进程和线程的区别（高频）"></a><strong>面试官：</strong> 进程和线程的区别<code>（高频）</code></h3><p><strong>候选人：</strong> 线程和进程的区别主要体现在以下四个方面：</p><p>1️⃣ <strong>资源分配：</strong> 进程是操作系统分配资源的基本单位，拥有独立的内存空间；线程共享进程资源，多个线程可访问相同的数据。</p><blockquote><p><strong>你说到进程是分配资源的基本单位，那么这个资源指的是什么？</strong> 虚拟内存、文件句柄、信号量等资源。</p></blockquote><p>2️⃣ <strong>创建与切换开销：</strong> 进程创建和切换成本较高，需要完整的资源分配和回收；线程切换更轻量，仅需保存和恢复私有数据。</p><p>3️⃣ <strong>通信与同步：</strong> 进程间通信（IPC）依赖管道、消息队列等机制，效率较低；线程共享进程数据，通信更快，但需加锁避免竞争。</p><p>4️⃣ <strong>容错与并发：</strong> 进程崩溃通常不影响其他进程，适用于高可靠性场景；线程共享进程资源，故单个线程异常可能导致整个进程崩溃。</p><blockquote><p><img src="https://pic1.imgdb.cn/item/67e6bbfe0ba3d5a1d7e5c513.png" alt="image-20250312163103774"></p></blockquote><hr><h3 id="面试官：-线程比进程高效的原因？（高频）"><a href="#面试官：-线程比进程高效的原因？（高频）" class="headerlink" title="面试官： 线程比进程高效的原因？（高频）"></a><strong>面试官：</strong> 线程比进程高效的原因？<code>（高频）</code></h3><p><strong>候选人：</strong> 线程相较于进程的优势主要体现在<strong>资源共享、创建成本、切换开销和并发效率</strong>四个方面。  </p><ul><li><strong>资源共享</strong>：进程间通信（IPC）成本较高，而线程共享进程资源，数据访问更快，通信更高效。  </li><li><strong>创建成本</strong>：进程创建需分配独立内存，开销大；线程仅需分配栈，创建速度更快。  </li><li><strong>切换开销</strong>：进程切换涉及完整上下文切换，线程切换仅涉及寄存器和栈指针，开销更小。  </li><li><strong>并发执行</strong>：线程能充分利用多核 CPU 并行执行，提高程序吞吐量，而进程的资源隔离限制了并发效率。</li></ul><hr><h3 id="面试官：-进程，线程，协程的区别是什么？（高频）"><a href="#面试官：-进程，线程，协程的区别是什么？（高频）" class="headerlink" title="面试官： 进程，线程，协程的区别是什么？（高频）"></a><strong>面试官：</strong> 进程，线程，协程的区别是什么？<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p>首先,我们来谈谈<strong>进程</strong>。进程是操作系统分配资源的基本单位，它拥有自己的<strong>独立内存空间</strong>和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。进程间通信需要通过特定的机制，<strong>如管道、消息队列、信号量等</strong>。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高,但同时上下文切换的开销也较大,因为需要保存和恢复整个进程的状态。</p></li><li><p>接下来是<strong>线程</strong>。线程是进程内的一个执行单元,也是CPU调度的基本单位。与进程不同，线程共享进程的内存空间，包括堆和方法区。线程之间通信更加高效，因为它们可以直接读写<strong>共享内存</strong>。线程的上下文切换开销较小,因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此存在线程安全的问题，需要通过同步和互斥机制来解决。</p></li><li><p>最后是<strong>协程</strong>。协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。<strong>协程拥有自己的寄存器和栈，但与其他协程共享堆内存。<strong>协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理</strong>大量并发任务时</strong>具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说,其编程模型更为复杂。</p></li></ul><hr><h3 id="面试官：-用户态和内核态是如何切换的？（高频）"><a href="#面试官：-用户态和内核态是如何切换的？（高频）" class="headerlink" title="面试官： 用户态和内核态是如何切换的？（高频）"></a><strong>面试官：</strong> 用户态和内核态是如何切换的？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>在操作系统中，<strong>用户态</strong>用于运行普通应用程序，受限访问系统资源，而<strong>内核态</strong>具备最高权限，能够直接控制硬件。两者的切换主要通过以下三种方式：  </p><ul><li><strong>系统调用</strong>：应用程序请求受限资源（如文件、网络）时，会触发系统调用，使 CPU 进入内核态，执行相应内核函数，完成后返回用户态。  </li><li><strong>异常处理</strong>：程序在用户态发生错误（如除零、非法内存访问）时，CPU 进入内核态执行异常处理程序，决定是否恢复或终止进程。  </li><li><strong>硬件中断</strong>：当外设（比如键盘、定时器等）完成任务时，触发中断，CPU 切换至内核态处理中断，随后恢复用户态继续执行程序。</li></ul><hr><h3 id="面试官：-什么是孤儿进程？什么是僵尸进程？"><a href="#面试官：-什么是孤儿进程？什么是僵尸进程？" class="headerlink" title="面试官： 什么是孤儿进程？什么是僵尸进程？"></a><strong>面试官：</strong> 什么是孤儿进程？什么是僵尸进程？</h3><p><strong>候选人：</strong></p><ul><li><p><code>孤儿进程</code>是指父进程在子进程结束之前就已经退出，导致子进程失去了父进程的管理和控制，成为了 “孤儿”。此时，这些子进程会被系统的 init 进程（在 Linux 系统中，进程 ID 为 1）所收养，init 进程会负责回收它们的资源等工作。</p></li><li><p><code>僵尸进程</code>是指一个进程已经执行完了它的主要任务，进入了终止状态，但由于某些原因，它的父进程没有调用相应的系统函数（如 wait () 或 waitpid ()）来收集它的退出状态信息，导致该进程虽然已经停止运行，但在系统进程表中仍然保留着一个记录，占据着一定的系统资源。</p><blockquote><p>Linux 下可以使用 Top 命令查找，<code>zombie</code> 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。</p><p><img src="https://pic1.imgdb.cn/item/67e6bc090ba3d5a1d7e5c51a.png" alt="僵尸进程查看"></p><p>下面这个命令可以定位僵尸进程以及该僵尸进程的父进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -ostat,ppid,pid,cmd |grep -e <span class="string">&#x27;^[Zz]&#x27;</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><h3 id="面试官：-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？"><a href="#面试官：-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？" class="headerlink" title="面试官： 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？"></a><strong>面试官：</strong> 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</h3><p><strong>候选人：</strong> 在没有任何同步机制的情况下，两个线程并发对同一个整型变量进行 50 次加 1 操作，最终结果可能是 100，也可能小于 100，最坏的结果是 50，也就是最终的结果可能是在 [50, 100] 。</p><p>小于 100 情况的分析，由于对整型变量的 <code>num++</code> 操作不是原子操作，它实际上包含了三个步骤：读取变量的值、将值加 1、将新值写回变量。在多线程环境下，可能会出现线程安全问题。例如，线程 1 和线程 2 同时读取了变量的当前值，然后各自将其加 1，最后都将相同的新值写回变量，这就导致了一次加 1 操作的丢失。这种情况会多次发生，最终结果就会小于 100。</p><blockquote><p><strong>追问：</strong> 如何保证2 个线程累加之后达到 100？</p><p>第一种方式：原子变量的方法。使用 <code>AtomicInteger</code> 替代普通 <code>int</code>，其 <code>incrementAndGet()</code> 方法保证原子性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式：通过 <code>synchronized</code> 关键字或 <code>ReentrantLock</code> 确保操作的互斥性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="面试官：-进程的调度算法有哪些"><a href="#面试官：-进程的调度算法有哪些" class="headerlink" title="面试官： 进程的调度算法有哪些?"></a><strong>面试官：</strong> 进程的调度算法有哪些?</h3><p><strong>候选人：</strong></p><ul><li><p><strong>先到先服务(FCFS)调度算法</strong> : 按照进程到达的先后顺序进行调度，即最早到达的进程先执行，直到完成或阻塞。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720958097438-d2dccfb8-bd9b-4556-86a3-2cb8d6c370f1.png" alt="img"></p></li><li><p><strong>短作业优先(SJF)调度算法</strong> : 优先选择运行时间最短的进程来运行。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720958113844-46b5799d-6ebf-4f91-8924-d9744e9895d1.png" alt="img"></p></li><li><p><strong>时间⽚轮转调度算法</strong> : 将 <code>CPU</code> 时间划分为时间片(时间量)，每个进程在一个时间片内运行，然后切换到下一个进程。</p></li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1720958138354-bb990348-3374-4239-8aa6-bd3b3737b5ea.png" alt="image.png"></p><ul><li><p><strong>多级反馈队列调度算法</strong> ：将进程划分为多个队列，每个队列具有不同的优先级，进程在队列之间移动。具有更高优先级的队列的进程会更早执行，而长时间等待的进程会被提升到更高优先级队列。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720958157105-0947c14a-f422-464a-9294-7cf5ef8a23bd.png" alt="img"></p></li><li><p><strong>最高优先级调度</strong> ： 为每个进程分配一个优先级，优先级较高的进程先执行。这可能导致低优先级进程长时间等待可能引发饥饿问题。</p></li></ul><hr><h3 id="面试官：-进程间的通信方式"><a href="#面试官：-进程间的通信方式" class="headerlink" title="面试官： 进程间的通信方式"></a><strong>面试官：</strong> 进程间的通信方式</h3><p><strong>候选人：</strong> ⼤概有 7 种常⻅的进程间的通信⽅式。</p><ol><li><p><strong>管道&#x2F;匿名管道(Pipes)</strong> ：⽤于具有<code>亲缘关系</code>的⽗⼦进程间或者兄弟进程之间的通信。</p></li><li><p><strong>有名管道(Names Pipes)</strong>: 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)，可以实现本机任意两个进程通信。</p></li><li><p><strong>信号(Signal)</strong> ：信号是⼀种⽐复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；</p></li><li><p><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是<strong>消息队列存放在内核</strong>中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取，⽐ FIFO 更有优势。</p></li><li><p><strong>信号量(Semaphores)</strong> ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p></li><li><p><strong>共享内存(Shared memory)</strong>：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。</p></li><li><p><strong>套接字(Sockets)</strong> : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持 TCP&#x2F;IP 的⽹络通信的基本操作单元，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</p></li></ol><p><img src="https://pic1.imgdb.cn/item/67e6bc2c0ba3d5a1d7e5c520.png" alt="image-20250225162852270"></p><hr><h3 id="面试官：-那线程间的同步的⽅式有哪些呢？"><a href="#面试官：-那线程间的同步的⽅式有哪些呢？" class="headerlink" title="面试官： 那线程间的同步的⽅式有哪些呢？"></a><strong>面试官：</strong> 那线程间的同步的⽅式有哪些呢？</h3><p><strong>候选人：</strong></p><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p><p>下面是几种常见的线程同步的方式：</p><ol><li><strong>互斥锁(Mutex)</strong> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 <code>synchronized</code> 关键词和各种 <code>Lock</code> 都是这种机制。</li><li><strong>读写锁（Read-Write Lock）</strong> ：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</li><li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>屏障（Barrier）</strong> ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 <code>CyclicBarrier</code> 是这种机制。</li><li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol><hr><h3 id="面试官：-操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式？"><a href="#面试官：-操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式？" class="headerlink" title="面试官： 操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式？"></a><strong>面试官：</strong> 操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式？</h3><p><strong>候选人：</strong> 简单分为 <strong>连续分配管理⽅式</strong> 和 <strong>⾮连续分配管理⽅式</strong> 这两种。连续分配管理⽅式是指为⼀个⽤户程序分配⼀个连续的内存空间，常⻅的如 <strong>块式管理</strong> 。同样地，⾮连续分配管理⽅式允许⼀个程序使⽤的内存分布在离散或者说不相邻的内存中，常⻅的如 <strong>⻚式管理</strong> 和 <strong>段式管理</strong>。</p><ol><li><p><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了，产生一定的内存碎片。</p></li><li><p><strong>⻚式管理</strong> ：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过<code>⻚表</code>对应逻辑地址和物理地址。</p></li><li><p><strong>段式管理</strong> ： ⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意义。 段式管理把主存分为⼀段段的 。但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段X、数据段 D 及栈段 S 等。 段式管理通过<code>段表</code>对应逻辑地址和物理地址。</p></li><li><p><strong>段⻚式管理机制</strong> 。结合了上述两者的优点，<strong>先将内存划分为若干个段</strong>，每个段又被进一步划分为若干个页。段式管理解决了程序逻辑上不同部分的<strong>内存分配</strong>问题，而页式管理解决了物理内存的<strong>连续性</strong>问题。</p></li></ol><hr><h3 id="面试官：-快表和多级⻚表"><a href="#面试官：-快表和多级⻚表" class="headerlink" title="面试官： 快表和多级⻚表"></a><strong>面试官：</strong> 快表和多级⻚表</h3><p><strong>候选人：</strong></p><p><strong>1）快表</strong></p><p>为了解决<code>虚拟地址到物理地址的转换速度</code>，操作系统在 <strong>⻚表⽅案</strong> 基础之上引⼊了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。</p><blockquote><p>使⽤快表之后的地址转换流程是这样的：</p><ol><li><p>根据虚拟地址中的⻚号查快表</p></li><li><p>如果该⻚在快表中，直接从快表中读取相应的物理地址；</p></li><li><p>如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；</p></li><li><p>当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。</p></li></ol></blockquote><p><strong>2）多级⻚表</strong></p><p>引⼊多级⻚表的主要⽬的是<code>为了避免把全部⻚表⼀直放在内存中占⽤过多空间</code>，特别是那些根本就不需要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景。</p><hr><h3 id="面试官：-分⻚机制和分段机制有哪些共同点和区别呢？"><a href="#面试官：-分⻚机制和分段机制有哪些共同点和区别呢？" class="headerlink" title="面试官： 分⻚机制和分段机制有哪些共同点和区别呢？"></a><strong>面试官：</strong> 分⻚机制和分段机制有哪些共同点和区别呢？</h3><p><strong>候选人：</strong></p><ol><li><strong>共同点</strong> ：</li></ol><ul><li><p>分⻚机制和分段机制都是为了提⾼内存利⽤率，少内存碎⽚。</p></li><li><p>⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，每个⻚和段中的内存是连续的。</p></li></ul><ol start="2"><li><strong>区别</strong> ：</li></ol><ul><li><p>⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程序。</p></li><li><p>分页对用户不可见，分段对用户可见</p></li><li><p>分页的地址空间是一维的，分段的地址空间是二维的</p></li></ul><hr><h3 id="面试官：-逻辑-虚拟-地址和物理地址"><a href="#面试官：-逻辑-虚拟-地址和物理地址" class="headerlink" title="面试官： 逻辑(虚拟)地址和物理地址"></a><strong>面试官：</strong> 逻辑(虚拟)地址和物理地址</h3><p><strong>候选人：</strong> 我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥⾯存储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p><blockquote><p><strong>为什么要有虚拟地址空间呢？</strong></p><p>没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p><ol><li><p>⽤户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者⽆意）破坏操作系统，造成操作系统崩溃。</p></li><li><p>想要同时运⾏多个程序特别困难，⽐如你想同时运⾏⼀个微信和⼀个 QQ ⾳乐都不⾏。为什么呢？举个简单的例⼦：微信在运⾏的时候给内存地址 1xxx 赋值后，QQ ⾳乐也同样给内存地址 1xxx 赋值，那么 QQ ⾳乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃</p></li></ol><p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。</strong></p></blockquote><hr><h3 id="面试官：-什么是虚拟内存"><a href="#面试官：-什么是虚拟内存" class="headerlink" title="面试官： 什么是虚拟内存?"></a><strong>面试官：</strong> 什么是虚拟内存?</h3><p><strong>候选人：</strong> 虚拟地址是操作系统提供的一种抽象地址空间，它通过页表映射到实际的物理地址，其大小可以远远大于物理内存的大小。</p><p>虚拟内存通过将程序的地址空间划分成若干个固定大小的页或段，并将这些页或者段<strong>映射到物理内存中</strong>的不同位置,从而使得程序在运行时可以更高效地利用物理内存。</p><hr><h3 id="面试官：-说⼀下⻚⾯置换算法的作⽤-常⻅的⻚⾯置换算法有哪些"><a href="#面试官：-说⼀下⻚⾯置换算法的作⽤-常⻅的⻚⾯置换算法有哪些" class="headerlink" title="面试官： 说⼀下⻚⾯置换算法的作⽤?常⻅的⻚⾯置换算法有哪些?"></a><strong>面试官：</strong> 说⼀下⻚⾯置换算法的作⽤?常⻅的⻚⾯置换算法有哪些?</h3><p><strong>候选人：</strong> 地址映射过程中，若在⻚⾯中发现所要访问的⻚⾯不在内存中，则发⽣缺⻚中断 。</p><blockquote><p><strong>缺⻚中断</strong> 就是要访问的 <strong>⻚</strong> 不在主存，需要操作系统将其调⼊主存后再进⾏访问。 在这个时候，被内存映射的⽂件实际上成了⼀个分⻚交换⽂件。</p></blockquote><p>当发⽣缺⻚中断时，如果当前内存中并没有空闲的⻚⾯，操作系统就必须在内存选择⼀个⻚⾯将其移出内存，以便为即将调⼊的⻚⾯让出空间。⽤来选择淘汰哪⼀⻚的规则叫做⻚⾯置换算法，我们可以把⻚⾯置换算法看成是淘汰⻚⾯的规则。</p><ul><li><p><strong>OPT</strong> <strong>⻚⾯置换算法（最佳⻚⾯置换算法）</strong> ：最佳(OPT)置换算法所选择的被淘汰⻚⾯将是以后永不使⽤的，或者是在最⻓时间内不再被访问的⻚⾯,这样可以保证获得最低的缺⻚率。但由于⼈们⽬前⽆法预知进程在内存下的若千⻚⾯中哪个是未来最⻓时间内不再被访问的，因⽽该算法⽆法实现。⼀般作为衡量其他置换算法的⽅法。</p></li><li><p><strong>FIFO（First In First Out）⻚⾯置换算法（先进先出⻚⾯置换算法）</strong> : 总是淘汰最先进⼊内存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰。</p></li><li><p><strong>LRU（Least Currently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法）</strong> ：LRU算法赋予每个⻚⾯⼀个访问字段，⽤来记录⼀个⻚⾯⾃上次被访问以来所经历的时间 T，当须淘汰⼀个⻚⾯时，选择现有⻚⾯中其 T 值最⼤的，即最近最久未使⽤的⻚⾯予以淘汰。</p></li><li><p><strong>LFU（Least Frequently Used）⻚⾯置换算法（最少使⽤⻚⾯置换算法）</strong> : 该置换算法选择在之前时期使⽤最少的⻚⾯作为淘汰⻚。</p></li></ul><hr><h3 id="面试官：-解释一下进程同步和互斥，以及解决这些问题的办法"><a href="#面试官：-解释一下进程同步和互斥，以及解决这些问题的办法" class="headerlink" title="面试官： 解释一下进程同步和互斥，以及解决这些问题的办法"></a><strong>面试官：</strong> 解释一下进程同步和互斥，以及解决这些问题的办法</h3><p><strong>候选人：</strong></p><p><code>进程同步</code>是指多个并发执行的进程之间协调和管理它们的执行顺序，以确保它们<strong>按照一定的顺序或时间间隔执行</strong>。</p><p><code>进程互斥</code>指的是在<strong>某一时刻只允许一个进程访问某个共享资源</strong>。当一个进程正在使用共享资源时，其他进程不能同时访问该资源。</p><p>解决进程同步和互斥的问题有很多种方法，其中一种常见的方法是使用<strong>信号量</strong>和 <strong>PV 操作</strong>。信号量是一种特殊的变量，它表示系统中某种资源的数量或者状态。PV 操作是一种对信号量进行增加或者减少的操作，它们可以用来控制进程之间的同步或者互斥。</p><p>除此之外，下面的方法也可以解决进程同步和互斥问题:</p><ul><li><strong>临界区(Critical Section)</strong>: 将可能引发互斥问题的代码段称为临界区。为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。这确保同一时间只有一个进程可以进入临界区。</li><li><strong>互斥锁(Mutex)</strong>: 互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁进程在访问该资源前需要先获取互斥锁，使用完后释放锁。只有获得锁的进程才能访问共享资源。</li></ul><hr><h3 id="面试官：-介绍一下几种典型的锁"><a href="#面试官：-介绍一下几种典型的锁" class="headerlink" title="面试官： 介绍一下几种典型的锁"></a><strong>面试官：</strong> 介绍一下几种典型的锁</h3><p><strong>候选人：</strong></p><p>两个基础的锁：</p><ul><li><strong>互斥锁</strong>:互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。</li><li><strong>自旋锁</strong>:自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。</li></ul><p>其他的锁都是基于这两个锁的：</p><ul><li><strong>读写锁</strong>:允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读(共享)和写(排他)两种状态。</li><li><strong>悲观锁</strong>:认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁</li><li><strong>乐观锁</strong>:先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作。.</li></ul><hr><h3 id="面试官：死锁产生的条件是什么？（高频）"><a href="#面试官：死锁产生的条件是什么？（高频）" class="headerlink" title="面试官：死锁产生的条件是什么？（高频）"></a><strong>面试官</strong>：死锁产生的条件是什么？<code>（高频）</code></h3><p><strong>候选人</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁。</p><p>死锁必须具备以下四个条件：</p><ol><li><p><strong>互斥条件：</strong> 该资源任意⼀个时刻只由⼀个线程占⽤。</p></li><li><p><strong>请求与保持条件：</strong> ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</p></li><li><p><strong>不剥夺条件:</strong> 线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。</p></li><li><p><strong>循环等待条件:</strong> 若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</p></li></ol><hr><h3 id="面试官：如何避免线程死锁-（高频）"><a href="#面试官：如何避免线程死锁-（高频）" class="headerlink" title="面试官：如何避免线程死锁?（高频）"></a><strong>面试官</strong>：如何避免线程死锁?<code>（高频）</code></h3><p><strong>候选人：</strong> 我上⾯说了产⽣死锁的四个必要条件，为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个就可以了。现在我们来挨个分析⼀下：</p><ol><li><p><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong> ：⼀次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong> ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><blockquote><p><strong>那什么是资源有序分配法呢?</strong> 线程A和线程 B获取资源的顺序要一样，当线程A是先尝试获取资源 A, 然后尝试获取资源 B 的时候，线程B同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A和线程B总是以相同的顺序申请自己想要的资源。</p></blockquote><hr><h3 id="面试官：如何进行死锁诊断？（高频）"><a href="#面试官：如何进行死锁诊断？（高频）" class="headerlink" title="面试官：如何进行死锁诊断？（高频）"></a><strong>面试官</strong>：如何进行死锁诊断？<code>（高频）</code></h3><p><strong>候选人</strong>：这个也很容易，我们只需要通过jdk自动的工具就能搞定。</p><p>我们可以先通过<code>jps</code>来查看当前java程序运行的进程id，然后通过<code>jstack</code>来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p><blockquote><p><strong>拓展：</strong></p><p><code>jps</code>：输出JVM中运行的进程状态信息。</p><p><code>jstack</code>：查看java进程内线程的堆栈信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网相关面试题</title>
      <link href="/2025/03/27/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/27/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h3 id="⾯试官：-从输入URL到页面展示到底发生了什么？（高频）"><a href="#⾯试官：-从输入URL到页面展示到底发生了什么？（高频）" class="headerlink" title="⾯试官： 从输入URL到页面展示到底发生了什么？（高频）"></a><strong>⾯试官：</strong> 从输入URL到页面展示到底发生了什么？<code>（高频）</code></h3><p><strong>候选人：</strong></p><ol><li>浏览器接收到用户请求，先<strong>检查浏览器缓存</strong>里是否有缓存该资源，如果有直接返回;如果没有进入下一步网络请求。</li><li>网络请求前，进行 <strong>DNS解析</strong> ，以获取请求域名的IP地址 。如果请求协议是 HTTPS ，那么还需要建立TLS&#x2F;SSL 连接 。DNS查找过程：<strong>浏览器缓存、路由器缓存、DNS缓存</strong>。</li><li>浏览器与服务器IP建立<strong>TCP连接</strong>。连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，向服务器构建请求信息。</li><li>服务器接收到请求信息，根据请求<strong>生成响应数据</strong>。</li><li><strong>浏览器解析响应头</strong>。若响应头状态码为 301、302 ，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程</li><li>浏览器<strong>解析 HTML 文件</strong>，创建 DOM 树、解析 CSS 进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。</li></ol><hr><h3 id="面试官：-DNS域名解析的工作流程（超高频）"><a href="#面试官：-DNS域名解析的工作流程（超高频）" class="headerlink" title="面试官： DNS域名解析的工作流程（超高频）"></a><strong>面试官：</strong> DNS域名解析的工作流程<code>（超高频）</code></h3><p><strong>候选人：</strong> DNS(Domain Name System)域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和IP 地址的映射问题。</p><blockquote><h4 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h4><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的界限。</p><p>在域名中，<strong>越靠右</strong>的位置表示其<strong>层级越高</strong></p><p>根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。所以域名的层级关系类似一个树状结构:</p><ul><li><p>根 DNS 服务器</p></li><li><p>顶级域 DNS 服务器(com)</p></li><li><p>权威 DNS 服务器(server.com)</p></li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/32.jpg" alt="DNS 树状结构"></p></blockquote><ol><li>首先用户在浏览器输入URL地址后，会先<strong>查询浏览器缓存</strong>是否有该域名对应的IP地址。</li><li>如果浏览器缓存中没有，会去<strong>计算机本地的Host文件</strong>中查询是否有对应的缓存。</li><li>如果Host文件中也没有则会<strong>向本地的DNS解析器</strong>(通常由你的互联网服务提供商(ISP)提供)<strong>发送一个DNS查询请求</strong>。</li><li>如果本地DNS解析器<strong>没有缓存该域名的解析记录</strong>，它会<strong>向根DNS服务器发出查询请求</strong>。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域(.com&#x2F;.net&#x2F;.org)的DNS服务器继续查询。</li><li>本地DNS解析器接着向指定的顶级域DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但它能<strong>告诉本地DNS解析器应该前往哪个权威DNS服务器查询下一步的信息</strong>。</li><li>本地DNS解析器最后<strong>向权威DNS服务器发送查询请求</strong>。当权威DNS服务器收到查询请求时，它会查找域名对应的IP地址，并将结果返回给本地DNS解析器。</li><li>本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果<strong>缓存在本地</strong>，以便下次访问时更快地响应。</li></ol><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/33.jpg" alt="域名解析的工作流程"></p><blockquote><p>DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，<strong>只指路不带路</strong></p></blockquote><hr><h3 id="⾯试官：-三次握手的过程，以及为什么是三次，不是四次、两次？（超高频）"><a href="#⾯试官：-三次握手的过程，以及为什么是三次，不是四次、两次？（超高频）" class="headerlink" title="⾯试官： 三次握手的过程，以及为什么是三次，不是四次、两次？（超高频）"></a><strong>⾯试官：</strong> 三次握手的过程，以及为什么是三次，不是四次、两次？<code>（超高频）</code></h3><p><strong>候选人：</strong> 三次握手的过程如下:</p><ol><li>客户端向服务器发送 SYN 报文，然后客户端进入 <strong>同步发送</strong> 状态，等待服务器确认。</li><li>服务端发送 ACK 确认服务端的 SYN 报文，同时发出一个 SYN 报文，然后服务端进入 <strong>同步接收</strong> 状态。</li><li>客户端接收到服务端的 SYN、ACK 报文，发送 ACK报文 确认服务端的 SYN 报文，然后客户端和服务器端都进入 ESTABLISHED（连接已建立） 状态，完成 TCP 三次握手。</li></ol><p><img src="https://pic1.imgdb.cn/item/67e53c800ba3d5a1d7e52943.png" alt="image-20250305113636718"></p><blockquote><p><strong>为什么不是四次握手? 为什么不能两次握手?</strong></p><p>因为三次握手才能保证双方<strong>具有接收和发送的能力</strong>。 </p><ul><li>两次握手可能导致资源的浪费，由于没有第三次握手，服务端就无法确认客户端是否收到了自己的回复。</li><li>而四次握手可以优化为三次。</li></ul></blockquote><blockquote><p><strong>为什么要传回</strong> <strong>SYN ?</strong></p><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号。前后SYN报文的值是一样的。</p></blockquote><blockquote><p><strong>传了</strong> <strong>SYN,为啥还要传</strong> <strong>ACK ?</strong></p><p>双⽅通信⽆误必须是两者<strong>互相发送信息</strong>都⽆误。传了 SYN，证明发送⽅到接收⽅的通道没有问题，但是接收⽅到发送⽅的通道还需要 ACK 信号来进⾏验证。</p></blockquote><blockquote><h4 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h4><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。重传一定次数后，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p><h4 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h4><p>当第二次握手丢失了，客户端和服务端都会重传：</p><ul><li><p>客户端会重传 <strong>SYN</strong> 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code> 内核参数决定(如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了)。</p></li><li><p>服务端会重传 <strong>SYN-ACK</strong> 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定（如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文）。</p></li></ul><h4 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h4><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p></blockquote><hr><h3 id="⾯试官：-四次挥手的过程，以及为什么是四次？（超高频）"><a href="#⾯试官：-四次挥手的过程，以及为什么是四次？（超高频）" class="headerlink" title="⾯试官： 四次挥手的过程，以及为什么是四次？（超高频）"></a><strong>⾯试官：</strong> 四次挥手的过程，以及为什么是四次？<code>（超高频）</code></h3><p><strong>候选人：</strong> 断开⼀个 TCP 连接则需要“四次挥⼿”：</p><ol><li><p><strong>客户端发送⼀个 FIN</strong>，⽤来关闭客户端到服务器的数据传送</p></li><li><p><strong>服务器收到这个 FIN</strong>，它发回⼀个 ACK，确认序号为收到的序号加 1 </p></li><li><p><strong>服务器关闭与客户端的连接</strong>，发送⼀个FIN给客户端</p></li><li><p><strong>客户端发回 ACK 报⽂确认</strong>，并将确认序号设置为收到序号加 1</p></li></ol><p><img src="https://pic1.imgdb.cn/item/67e53c8d0ba3d5a1d7e52947.png" alt="image-20250305113651573"></p><blockquote><p><strong>为什么要四次挥⼿ ？</strong></p><p>任何⼀⽅都可以在数据传送结束后发出连接释放的通知，待对⽅确认后进⼊半关闭状态。当另⼀⽅也没有数据再发送的时候，则发出连接释放通知，对⽅确认后就完全关闭了TCP连接。</p><p>举个例⼦：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B可能还会有要说的话，A 不能要求 B 跟着⾃⼰的节奏结束通话，于是 B 可能⼜巴拉巴拉说了⼀通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p></blockquote><blockquote><h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h4><ul><li>如果第四次挥手的 ACK 报文丢失，服务端会重发 FIN 报文。客户端在 <code>TIME_WAIT</code> 状态期间仍然可以接收并响应这些重发的 FIN 报文。</li><li>2MSL 的时间足够长，可以确保客户端有足够的时间处理这些重传的 FIN 报文，并最终确认连接的关闭。</li><li>可以看到 <strong>2MSL时长</strong>，这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，一来一去正好 2 个 MSL，TIME_WAIT 状态的连接可以应对。</li></ul></blockquote><blockquote><h4 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h4><p>客户端重传 FIN 报文。达到最大重传次数后，客户端等待一段时间（上次超时时间的 2 倍），如果仍收不到 ACK，直接进入 <code>CLOSE</code> 状态。</p><h4 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h4><p>客户端重传 FIN 报文，直到收到服务端的 ACK 或达到最大重传次数。</p><h4 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h4><p>如果服务端迟迟收不到客户端的 ACK报文 ，服务端重发 FIN 报文。达到最大重传次数后，服务端等待一段时间（上次超时时间的 2 倍），如果仍收不到 ACK，断开连接。</p><h4 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h4><p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文,达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</p></blockquote><hr><h3 id="⾯试官：-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#⾯试官：-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="⾯试官： OSI与TCP&#x2F;IP各层的结构与功能,都有哪些协议?"></a><strong>⾯试官：</strong> OSI与TCP&#x2F;IP各层的结构与功能,都有哪些协议?</h3><p><strong>候选人：</strong></p><p><strong>物理层</strong>：“透明”传输比特流，尽可能地屏蔽不同传输媒体和通信手段的差异。解决使用何种信号来传输比特流的问题。</p><p><strong>数据链路层：</strong> 通常简称为链路层。<strong>两台主机之间的数据传输，总是在⼀段⼀段的链路上传送的</strong>，这就需要使⽤专⻔的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将⽹络层交下来的 IP 数据报<strong>封装成帧</strong>，在两个相邻节点间的链路上传送帧。解决分组在一个网络（或一段链路）上传输的问题。</p><p><strong>网络层：</strong> 在计算机⽹络中进⾏通信的两个计算机之间可能会经过<strong>很多个数据链路</strong>，也可能还要经过<strong>很多通信⼦⽹</strong>。⽹络层的任务就是选择合适的⽹间路由和交换结点， 确保数据及时传送。解决分组在多个网络上传输的问题。</p><p><strong>运输层：</strong> 主要解决进程间基于网络的通信问题。运输层主要使⽤两种协议：<strong>TCP和UDP</strong></p><p><strong>应用层：</strong> 通过应⽤进程间的交互来完成特定⽹络应⽤。</p><p><img src="https://pic1.imgdb.cn/item/67e53cf80ba3d5a1d7e52956.png" alt="image-20250305113705088"></p><hr><h3 id="⾯试官：-TCP和UDP的区别以及对应的使用场景？（高频）"><a href="#⾯试官：-TCP和UDP的区别以及对应的使用场景？（高频）" class="headerlink" title="⾯试官： TCP和UDP的区别以及对应的使用场景？（高频）"></a><strong>⾯试官：</strong> TCP和UDP的区别以及对应的使用场景？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>1）概念：</p><ul><li><strong>TCP(传输控制协议)</strong> 是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li><li><strong>UDP(用户数据报协议)</strong> 为应用程序提供了一种无需建立连接就可以发送封装的IP数据包的方法。</li></ul><p>2）区别</p><ul><li><code>是否面向连接</code>: TCP 是面向连接的传输，UDP 是无连接的传输。</li><li><code>是否是可靠传输</code>: TCP是可靠的传输服务，在传递数据之前，会有三次握手来建立连接；在数据传递时，有确认、窗口、重传、拥塞控制机制。 UDP是不可靠传输，数据传递不需要给出任何确认，且不保证数据不丢失及到达顺序。</li><li><code>是否有状态</code>：TCP 传输是有状态的，它会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等，而 UDP 是无状态的。</li><li><code>传输形式</code>:TCP 是面向字节流的，UDP 是面向数据报文的。</li><li><code>传输效率</code>:由于TCP 传输的时候多了<strong>连接、确认重传</strong>等机制，所以TCP 的传输效率要比UDP 低。</li><li><code>首部开销 </code>:TCP 首部开销(20~60字节)比UDP 首部开销 (8字节)要大。</li><li><code>是否提供广播或多播服务</code>: TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多。</li></ul><p>3）应用场景</p><ul><li>TCP常用于要求通信<strong>数据可靠</strong>场景(如网页浏览、文件传输、邮件传输、远程登录、数据库操作等)</li><li>UDP常用于要求通信<strong>速度快</strong>场景(如域名转换、视频直播、实时游戏等)</li></ul><p><img src="https://pic1.imgdb.cn/item/67e53cf30ba3d5a1d7e52955.png" alt="image-20250305113719003"></p><hr><h3 id="⾯试官：-TCP协议如何保证可靠传输？（高频）"><a href="#⾯试官：-TCP协议如何保证可靠传输？（高频）" class="headerlink" title="⾯试官： TCP协议如何保证可靠传输？（高频）"></a><strong>⾯试官：</strong> TCP协议如何保证可靠传输？<code>（高频）</code></h3><p><strong>候选人：</strong> TCP连接确保可靠性方法如下：</p><ol><li>TCP的<strong>序列号</strong>可以避免乱序的问题，保证收到的TCP报文都是有序的。</li><li>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个<strong>确认应答</strong>消息，表示已收到消息。</li><li>TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</li><li>使用滑动窗口实现<strong>流量控制</strong>。使用接收方确认报文中的窗口字段来控制发送方发送窗口大小，进而控制发送方的发送速率，使得接收方来得及接收。</li><li>使用基于窗口的<strong>拥塞控制</strong>，来尽量避免避免网络拥塞。</li></ol><p>相关阅读：<a href="https://blog.csdn.net/weixin_74199893/article/details/140638864">破解网络奥秘：一图胜千言，TCP重传、滑动窗口、流量与拥塞控制全解析</a></p><hr><h3 id="⾯试官：-流量控制是使用什么数据结构来实现的？"><a href="#⾯试官：-流量控制是使用什么数据结构来实现的？" class="headerlink" title="⾯试官： 流量控制是使用什么数据结构来实现的？"></a><strong>⾯试官：</strong> 流量控制是使用什么数据结构来实现的？</h3><p><strong>候选人：</strong></p><p>TCP传输协议中，流量控制是使用滑动窗口（Sliding Window）来实现的。滑动窗口是一种基于数据流的、动态调整的、可变大小的窗口，它通过协商双方的接收窗口和发送窗口大小，控制数据的传输速率。</p><p>滑动窗口的大小是可以动态调整的，它可以根据网络状况和双方的能力来自适应地调整，从而实现流量控制的功能。如果接收方的接收窗口变小，发送方会相应地减小自己的发送窗口，以避免过多的数据堆积在网络中导致拥塞。如果接收方的接收窗口变大，发送方会相应地增加自己的发送窗口，以提高数据传输速率。</p><hr><h3 id="⾯试官：-拥塞控制是怎么实现的？"><a href="#⾯试官：-拥塞控制是怎么实现的？" class="headerlink" title="⾯试官： 拥塞控制是怎么实现的？"></a><strong>⾯试官：</strong> 拥塞控制是怎么实现的？</h3><p><strong>候选人：</strong> 拥塞控制主要是四个算法：</p><ol><li><strong>慢启动（Slow Start）</strong>：<br>目的： 快速找出网络的最大容量。<br>方法： 开始时用很小的数据量发送，接收到确认后，发送量快速增加。就像在探测水深时，从小处开始，然后快速加深。</li><li><strong>拥塞避免（Congestion Avoidance）</strong>：<br>目的： 平稳增加发送数据量，避免网络拥堵。<br>方法： 当网络负担较重时，发送数据量的增加变得比较慢。就像在汽车进入拥堵区时，从加速驾驶改为平稳驾驶。</li><li><strong>快重传（Fast Retransmit）</strong>：<br>目的： 迅速重传丢失的数据包。<br>方法： 如果发现某个数据包的确认收不到，发送方会快速重传这个数据包，而不是等到超时。就像收到一个丢失的邮件后，立刻重新发送。</li><li><strong>快恢复（Fast Recovery）</strong>：<br>目的： 在发现丢包后快速恢复数据传输。<br>方法： 快重传后，拥塞窗口会减少到一半，然后逐渐恢复到正常速度。就像在堵车后，车速会先减慢，再慢慢恢复正常行驶。</li></ol><hr><h3 id="面试官：-TCP-Keepalive-和-HTTP-Keep-Alive是一个东西吗？"><a href="#面试官：-TCP-Keepalive-和-HTTP-Keep-Alive是一个东西吗？" class="headerlink" title="面试官： TCP Keepalive 和 HTTP Keep-Alive是一个东西吗？"></a><strong>面试官：</strong> TCP Keepalive 和 HTTP Keep-Alive是一个东西吗？</h3><p><strong>候选人：</strong></p><ul><li><p><code>HTTP 的 Keep-Alive</code>，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接。可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的<strong>多次 TCP 连接建立和释放的开销</strong>。</p></li><li><p><code>TCP 的 Keepalive</code>，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制。当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p></li></ul><hr><h3 id="⾯试官：-HTTP请求常见的状态码和字段（高频，特别注意：面试中为抽查）"><a href="#⾯试官：-HTTP请求常见的状态码和字段（高频，特别注意：面试中为抽查）" class="headerlink" title="⾯试官： HTTP请求常见的状态码和字段（高频，特别注意：面试中为抽查）"></a><strong>⾯试官：</strong> HTTP请求常见的状态码和字段<code>（高频，特别注意：面试中为抽查）</code></h3><p><strong>候选人：</strong></p><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><img src="https://pic1.imgdb.cn/item/67e53d1b0ba3d5a1d7e5295d.png" alt="image-20250305113738080"></p><p><strong>1xx 状态码表示请求已被接收，客户端可以继续请求。比如：</strong></p><ul><li><p><code>100 Continue</code>，代表服务器已收到请求的初始部分，客户端应继续发送剩余请求。</p></li><li><p><code>101 Switching Protocols</code>，代表服务器同意切换协议（如从 HTTP 切换到 WebSocket）。</p></li></ul><p><strong>2xx 状态码表示请求已被成功处理。比如：</strong></p><ul><li><p><code>200 OK</code>，代表请求成功，服务器返回了预期的响应数据。</p></li><li><p><code>201 Created</code>，代表请求成功，服务器已创建新资源（如 POST 请求创建用户）。</p></li><li><p><code>204 No Content</code>，代表请求成功，但服务器不返回任何内容（常见于 DELETE 请求）。</p></li></ul><p><strong>3xx 状态码表示客户端需要采取额外操作以完成请求，通常是跳转到新地址。比如：</strong></p><ul><li><p><code>301 Moved Permanently</code>，代表请求的资源已被永久移动，浏览器会自动跳转到新 URL。</p></li><li><p><code>302 Found</code>，代表资源暂时移动，通常用于临时重定向。</p></li><li><p><code>304 Not Modified</code>，代表资源未修改，客户端可以使用缓存的版本，减少带宽消耗。</p></li></ul><p><strong>4xx 状态码表示客户端请求有错误，需要修正后重新发送。比如：</strong></p><ul><li><p><code>400 Bad Request</code>，代表请求格式错误或参数不正确，服务器无法理解请求。</p></li><li><p><code>401 Unauthorized</code>，代表请求需要身份验证，通常用于 API 认证失败的情况。</p></li><li><p><code>403 Forbidden</code>，代表服务器拒绝请求，即使身份验证成功也无权访问该资源。</p></li><li><p><code>404 Not Found</code>，代表请求的资源不存在或 URL 书写错误。</p></li><li><p><code>405 Method Not Allowed</code>，代表请求的方法（如 POST、PUT）不被该资源允许。</p></li></ul><p><strong>5xx 状态码表示服务器端处理请求时发生错误。比如：</strong></p><ul><li><p><code>500 Internal Server Error</code>，代表服务器内部错误，可能是代码异常或配置错误。</p></li><li><p><code>502 Bad Gateway</code>，代表服务器作为网关或代理时，接收到无效响应。</p></li><li><p><code>503 Service Unavailable</code>，代表服务器暂时不可用，通常是维护或过载导致的。</p></li><li><p><code>504 Gateway Timeout</code>，代表服务器作为网关时，未能及时收到上游服务器的响应。</p></li></ul><h4 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h4><p><img src="https://pic1.imgdb.cn/item/67e53d240ba3d5a1d7e52962.png" alt="image-20250305113747218"></p><hr><h3 id="⾯试官：-常见的请求方式？GET和POST请求的区别？（超高频）"><a href="#⾯试官：-常见的请求方式？GET和POST请求的区别？（超高频）" class="headerlink" title="⾯试官： 常见的请求方式？GET和POST请求的区别？（超高频）"></a><strong>⾯试官：</strong> 常见的请求方式？GET和POST请求的区别？<code>（超高频）</code></h3><p><strong>候选人：</strong></p><p>1）<strong>作用不同</strong></p><ul><li>GET用于从服务端获取资源</li><li>POST一般用来向服务器端提交数据</li></ul><p>2）<strong>参数传递方式不同</strong></p><ul><li>GET请求的参数一般写在URL中，且只接受ASCII字符</li><li>POST请求参数一般放在请求体中，对于数据类型也没有限制</li></ul><p>3）<strong>安全性不同</strong></p><p>因为参数传递方式的不同，所以两者安全性不同，GET请求的参数直接暴露在URL中，所以更不安全，不能用来传递敏感信息。</p><p>4）<strong>参数长度限制不同</strong></p><ul><li>GET传送的数据量较小，不能大于2KB。</li><li>POST传送的数据量较大，一般被默认为不受限制。</li></ul><p>5）<strong>编码方式不同</strong></p><ul><li>GET 请求只能进行 URL 编码</li><li>POST 支持多种编码方式</li></ul><p>6）<strong>时间消耗不同</strong></p><ul><li>GET 产生一个 TCP 数据包</li><li>POST 产生两个 TCP 数据包</li></ul><p>7）<strong>幂等</strong></p><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p><ul><li>GET 方法就是<strong>安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</li><li>POST  因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以所以<strong>不是幂等</strong>的。</li></ul><hr><h3 id="⾯试官：-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#⾯试官：-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="⾯试官： HTTP 1.0和HTTP 1.1的主要区别是什么?"></a><strong>⾯试官：</strong> HTTP 1.0和HTTP 1.1的主要区别是什么?</h3><p><strong>候选人：</strong> HTTP1.0最早在⽹⻚中使⽤是在1996年，那个时候只是使⽤⼀些为简单的⽹⻚上和⽹络请求上，⽽HTTP1.1则在1999年才开始⼴泛应⽤于现在的各⼤浏览器⽹络请求中，同时<strong>HTTP1.1也是当前使⽤最为⼴泛的HTTP协议</strong>。 主要区别主要体现在：</p><ol><li><p><strong>长连接</strong></p><p><code>HTTP1.1 </code>支持长连接，每一个TCP连接上可以传送多个HTTP请求和响应，默认开启 <code>Connection:Keep-Alive</code></p><p><code>HTTP1.0</code> 默认为短连接，每次请求都需要建立一个TCP连接。</p></li><li><p><strong>缓存</strong></p><p><code>HTTP1.0</code>主要使用 <code>If-Modified-Since/Expires</code> 来做为缓存判断的标准</p><p><code>HTTP1.1</code>则引入了更多的缓存控制策略例如 <code>Entity tag / If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略</p></li><li><p><strong>管道化</strong></p><p>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p></li><li><p><strong>状态码</strong></p><p><code>HTTP1.1</code>新增了24个错误状态响应码</p></li><li><p><strong>带宽优化</strong></p><p><code>HTTP1.0</code> 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能</p><p><code>HTTP1.1</code> 则在请求头引入了 <strong>range 头域</strong>，它允许只请求资源的某个部分，即返回码是 206(Partial Content)</p></li></ol><hr><h3 id="⾯试官：-HTTP-2-0和HTTP-1-1-的区别是什么"><a href="#⾯试官：-HTTP-2-0和HTTP-1-1-的区别是什么" class="headerlink" title="⾯试官： HTTP 2.0和HTTP 1.1 的区别是什么?"></a><strong>⾯试官：</strong> HTTP 2.0和HTTP 1.1 的区别是什么?</h3><p><strong>候选人：</strong></p><ol><li><p><strong>二进制分帧</strong></p><p>在应用层<code>(HTTP/2.0)</code>和传输层<code>(TCP or UDP)</code>之间增加一个二进制分帧层，从而突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。</p></li><li><p><strong>多路复用(MultiPlexing)</strong></p><p><code>HTTP/1.1</code> 的实现是基于<strong>请求-响应模型</strong>的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的。而 <code>HTTP/2.0</code> 允许同时通过单一的连接发起多重的<strong>请求–响应消息</strong>。</p></li><li><p><strong>首部压缩</strong></p><p><code>HTTP1.1</code> 不支持 header数据的压缩，<code>HTTP/2.0</code> 使用 <code>HPACK</code> 算法对 <code>header</code>的数据进行压缩，这样数据体积小了，在网络上传输就会更快。高效的压缩算法可以很大的压缩 <code>header</code> ，减少发送包的数量从而降低延迟。</p></li><li><p><strong>服务端推送 (server push)</strong></p><p><code>HTTP/2</code> 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p></li></ol><p><img src="https://pic1.imgdb.cn/item/67e53d2c0ba3d5a1d7e52968.png" alt="image-20250305113802009"></p><hr><h3 id="⾯试官：-HTTP-和-HTTPS-的区别？（超高频）"><a href="#⾯试官：-HTTP-和-HTTPS-的区别？（超高频）" class="headerlink" title="⾯试官： HTTP 和 HTTPS 的区别？（超高频）"></a><strong>⾯试官：</strong> HTTP 和 HTTPS 的区别？<code>（超高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p>HTTP 是超文本传输协议，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 <strong>SSL&#x2F;TLS</strong> 安全协议，使得报文能够加密传输。</p></li><li><p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p></li><li><p>HTTPS 协议需要需要 <strong>SSL&#x2F;TLS 证书</strong>，由受信任的证书颁发机构**（CA）**签发；而 HTTP 不需要任何证书。</p></li><li><p>搜索引擎通常偏好使用 <strong>HTTPS 协议</strong>的网站，因为 HTTPS 提供更高的安全性和用户隐私保护。</p></li></ul><hr><h3 id="⾯试官：-HTTPS的工作原理？（https是怎么建立连接的？）"><a href="#⾯试官：-HTTPS的工作原理？（https是怎么建立连接的？）" class="headerlink" title="⾯试官： HTTPS的工作原理？（https是怎么建立连接的？）"></a><strong>⾯试官：</strong> HTTPS的工作原理？（https是怎么建立连接的？）</h3><p><strong>候选人：</strong></p><ol><li><strong>客户端发起HTTPS请求</strong>：第一次握手，客户端告诉服务端，它支持什么样的加密协议版本(TLS1.2)，使用什么样的加密套件（RSA），并且给出一个客户端随机数（<strong>明文</strong>）。</li><li><strong>服务器返回证书</strong>：第二次握手，服务端收到请求后，告诉客户端确定的加密方式等信息，服务器证书和服务器随机数（<strong>明文</strong>）。这个证书由受信任的证书颁发机构（CA）签署，确保其真实性。</li><li><strong>客户端验证证书</strong>：第三次握手，客户端收到服务端发送的数字证书后，会验证其合法性，包括证书的颁发机构、有效期等。如果证书可信，客户端会从证书里取出服务器公钥，同时再生成第三个随机数pre_master_key（<strong>服务器公钥加密</strong>）。客户端通过三个随机数用算法生成一个会话密钥。同时把迄今为止的通信数据内容生成一个摘要，也叫finished报文，用会话秘钥加密一下发给服务端做校验。</li><li><strong>客户端加密随机数</strong>：客户端使用服务端的公钥（也就是从CA取出的公钥解密CA证书得到）加密第三个随机数，并将加密后的第三个随机数发送给服务端。</li><li><strong>服务器解密会话密钥</strong>：第四次握手，服务端使用自己的服务器私钥解密得到第三个随机数。结合三个随机数，跟客户端一样通过同样的算法获得一个会话密钥。此时，客户端和服务端都拥有了相同的会话密钥。</li><li><strong>使用对称密钥进行加密通信</strong>：四次握手之后，客户端和服务器使用这个会话密钥（对称加密）进行后续的加密通信，确保数据传输的安全性。</li></ol><p><img src="https://pic1.imgdb.cn/item/67e53d350ba3d5a1d7e5296a.png" alt="在这里插入图片描述"></p><blockquote><h3 id="为什么公钥加密的数据不能用公钥解密？"><a href="#为什么公钥加密的数据不能用公钥解密？" class="headerlink" title="为什么公钥加密的数据不能用公钥解密？"></a>为什么公钥加密的数据不能用公钥解密？</h3><p>公钥加密和私钥解密是一对数学函数，它们是单向的。这意味着公钥只能用来加密数据，不能用来解密数据，只有私钥可以解密由公钥加密的数据。这种设计的目的是为了确保即使公钥是公开的，数据的解密只能由私钥持有者完成，从而保证数据的安全性。</p><h3 id="为什么不能直接传服务器公钥？"><a href="#为什么不能直接传服务器公钥？" class="headerlink" title="为什么不能直接传服务器公钥？"></a>为什么不能直接传服务器公钥？</h3><p>直接传输公钥时，接收方无法确定这个公钥是否真的属于声称的身份。一个恶意的第三方可以在传输过程中替换掉真实的公钥，插入自己的公钥，这样所有发往目标服务器的数据都会被这个第三方截获和解密，这就是中间人攻击。</p></blockquote><hr><h3 id="⾯试官：-Cookie和Session是什么？有什么区别？"><a href="#⾯试官：-Cookie和Session是什么？有什么区别？" class="headerlink" title="⾯试官： Cookie和Session是什么？有什么区别？"></a><strong>⾯试官：</strong> Cookie和Session是什么？有什么区别？</h3><p><strong>候选人：</strong> Cookie 和 Session 都用于管理用户的状态和身份，Cookie 通过在客户端记录信息确定用户身份， Session 通过在服务器端记录信息确定用户身份。</p><ol><li><p><strong>Cookie</strong> <strong>⼀般⽤来保存⽤户信息。</strong> </p><p>⽐如①我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；②⼀般的⽹站都会有保持登录也就是说下次你再访问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们可以存放了⼀个Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找⽤户即可(为了安全考虑，重新登录⼀般要将 Token 重写)；③登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。</p></li><li><p><strong>Session</strong> <strong>的主要作⽤就是通过服务端记录⽤户的状态。</strong> </p><p>典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了</p></li><li><p><strong>区别：</strong></p></li></ol><ul><li><strong>存储位置</strong>：Cookie 数据存储在用户的浏览器中，而 Session 数据存储在服务器上。</li><li><strong>数据容量</strong>：Cookie 存储容量较小，一般为几 KB。Session 存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</li><li><strong>安全性</strong>：由于 Cookie 存储在用户浏览器中，因此可以被用户读取和篡改。相比之下,Session 数据存储在服务器上，更难被用户访问和修改。</li><li><strong>传输方式</strong>：Cookie 在每次 HTTP 请求中都会被自动发送到服务器，而 Session ID 通常通过 Cookie 或 URL 参数传递。</li></ul><hr><h3 id="面试官：-服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#面试官：-服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="面试官： 服务端没有 listen，客户端发起连接建立，会发生什么？"></a><strong>面试官：</strong> 服务端没有 listen，客户端发起连接建立，会发生什么？</h3><p><strong>候选人：</strong></p><p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文中止这个连接。</p><blockquote><h4 id="服务端建立连接步骤"><a href="#服务端建立连接步骤" class="headerlink" title="服务端建立连接步骤"></a>服务端建立连接步骤</h4><ol><li><strong>Socket 创建 (<code>socket()</code>)</strong>：<ul><li>服务端首先需要创建一个套接字（socket），通过系统调用 <code>socket()</code> 创建，并指定协议类型（例如 TCP&#x2F;UDP），从而获得一个用于通信的文件描述符。</li></ul></li><li><strong>绑定地址 (<code>bind()</code>)</strong>：<ul><li>使用 <code>bind()</code> 将创建的套接字绑定到特定的 IP 地址和端口号上，使服务端在该地址上监听。<code>bind()</code> 允许服务端指定要处理的网络接口和端口，确保客户端可以在正确的 IP 和端口上找到服务。</li></ul></li><li><strong>监听连接请求 (<code>listen()</code>)</strong>：<ul><li>通过 <code>listen()</code> 设置套接字为被动模式，准备接受客户端连接。此时，服务端的 TCP 协议栈开始准备接受来自客户端的 <code>SYN（同步）</code>数据包。这是 TCP 三次握手的起点，虽然 <code>listen()</code> 本身不直接触发握手，但它让服务端进入了一种“被动等待连接”的状态，为三次握手的发生创造了条件。</li></ul></li><li><strong>接受连接 (<code>accept()</code>)</strong>：<ul><li>三次握手完成后，服务端的 TCP 协议栈会将这个已建立的连接放入 <code>listen()</code> 设置的连接队列中。<code>accept()</code> 则从这个队列中取出一个已完成的连接，生成了一个新的套接字，用于与该客户端的具体通信。</li></ul></li></ol></blockquote><hr><h3 id="面试官：-没有-listen，能建立-TCP-连接吗？"><a href="#面试官：-没有-listen，能建立-TCP-连接吗？" class="headerlink" title="面试官： 没有 listen，能建立 TCP 连接吗？"></a><strong>面试官：</strong> 没有 listen，能建立 TCP 连接吗？</h3><p><strong>候选人：</strong> 是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。</p><blockquote><h4 id="客户端步骤"><a href="#客户端步骤" class="headerlink" title="客户端步骤"></a>客户端步骤</h4><ol><li><strong>Socket 创建 (<code>socket()</code>)</strong>：<ul><li>客户端同样需要创建一个套接字，通过 <code>socket()</code> 调用生成一个文件描述符。</li></ul></li><li><strong>连接服务器 (<code>connect()</code>)</strong>：<ul><li>客户端调用 <code>connect()</code> 主动向服务端发起连接请求，指定目标 IP 地址和端口号。该步骤触发三次握手过程。</li></ul></li></ol></blockquote><hr><h3 id="面试官：ping-的工作原理"><a href="#面试官：ping-的工作原理" class="headerlink" title="面试官：ping 的工作原理"></a><strong>面试官</strong>：ping 的工作原理</h3><p><strong>候选人：</strong> ping 是一种网络诊断工具，用来测试本地设备与目标设备（通常是服务器）之间的网络连通性。它通过发送网络包并等待回复，来测量网络的延迟和丢包率。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li><p><strong>发送 ICMP Echo 请求</strong>：<code>ping</code> 使用的是 ICMP（Internet Control Message Protocol）协议。首先，源设备向目标设备发送一个请求数据包。</p></li><li><p><strong>接收 ICMP Echo 回复</strong>：目标设备接收到请求后，返回一个回复数据包，告诉源设备它已经成功收到了请求。</p></li><li><p><strong>延迟测量</strong>：<code>ping</code> 记录从发送请求到接收回复的时间，称为 RTT（Round-Trip Time），即往返时间。这可以帮助用户评估网络的延迟情况。</p></li></ul><blockquote><p><strong>ICMP 协议</strong>：ICMP 是一种无连接的网络层协议，主要用于传输网络错误信息和诊断消息。它工作在 IP 层，用于报告数据传输中的错误或提供诊断信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>破解网络奥秘：一图胜千言，TCP重传、滑动窗口、流量与拥塞控制全解析</title>
      <link href="/2025/03/25/TCP%E9%87%8D%E4%BC%A0%E7%AD%89/"/>
      <url>/2025/03/25/TCP%E9%87%8D%E4%BC%A0%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>TCP 是一个<strong>非常复杂</strong>且伟大的协议，它通过许多机制来确保传输的可靠性。为了实现这一目标，TCP需要处理各种问题，比如数据损坏、丢包、重复数据以及分片顺序混乱等。如果这些问题得不到解决，可靠传输就无从谈起。</p><p>众所周知，TCP 是一个可靠传输的协议，那么它是如何实现这种可靠性的呢？</p><p>为了实现可靠传输，需要考虑许多方面的问题，例如数据的破坏、丢包、重复传输以及分片顺序的混乱等。如果这些问题得不到解决，可靠传输就无从谈起。</p><p>TCP 是通过以下机制来实现可靠传输的：序列号、确认应答、重传控制、连接管理以及窗口控制。</p><p>今天，我们将重点介绍 TCP 的<strong>重传机制</strong>、<strong>滑动窗口</strong>、<strong>流量控制</strong>和<strong>拥塞控制</strong>。</p><p><img src="https://pic1.imgdb.cn/item/67e21b110ba3d5a1d7e2e659.png" alt="在这里插入图片描述"></p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p>TCP 实现可靠传输的一种方式是通过使用序列号和确认应答。</p><p>在 TCP 协议中，当发送端的数据到达接收端时，接收端会发送一个确认应答消息，表示已经成功接收到数据。</p><p><img src="https://pic1.imgdb.cn/item/67e21b270ba3d5a1d7e2e699.png" alt="在这里插入图片描述"></p><p>然而，在复杂的网络环境中，数据传输并不总是那么顺利。如果数据在传输过程中丢失了怎么办？</p><p>为了应对数据包丢失的情况，TCP 引入了<strong>重传机制</strong>。</p><p>接下来说说常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>重传机制的一种方式是在发送数据时设置一个定时器。如果在指定时间内没有收到对方的 <code>ACK </code>确认应答消息，发送端就会重新发送该数据包，这种方法被称为<strong>超时重传</strong>。</p><p>TCP 会在以下两种情况下触发超时重传：</p><ol><li>数据包丢失</li><li>确认应答丢失</li></ol><blockquote><p>超时时间应该设置为多少呢？</p></blockquote><p>我们先来了解一下什么是 <code>RTT</code>（Round-Trip Time 往返时延），从下图我们就可以知道：</p><p><img src="https://pic1.imgdb.cn/item/67e21b310ba3d5a1d7e2e6b7.png" alt="在这里插入图片描述"></p><p><code>RTT</code> 指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。</p><p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p><p>假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时，会发生什么事情呢？</p><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发速度慢，数据丢失后需要等待很长时间才会重传，效率低，性能差；</li><li>当超时时间 <strong>RTO 较小</strong>时，可能会导致未丢失的数据也被重传，重传过快会增加网络拥塞，进而引发更多的超时，导致更多的重传。</li></ul><p>精确测量超时时间 <code>RTO</code> 的值是非常重要的，这样可以使重传机制更加高效。</p><p>从上述情况可以看出，超时重传时间 <code>RTO</code> 的值应<strong>略大于</strong>数据报文的往返时间 <code>RTT</code>。</p><p><img src="https://pic1.imgdb.cn/item/67e21b3d0ba3d5a1d7e2e6e1.png" alt="在这里插入图片描述"></p><p>到这里，可能大家会觉得计算超时重传时间 <code>RTO</code> 的值似乎并不复杂。</p><p>似乎只需要在发送端发送数据包时记下时间 <code>t0</code>，然后在接收端收到 <code>ACK</code> 时再记下时间 <code>t1</code>，那么 <code>RTT = t1 - t0</code>。其实没那么简单，<strong>这只是一次采样，不能代表普遍情况</strong>。</p><p>实际上，”报文往返时间 RTT 的值” 经常变化，因为网络状况也是不断变化的。由于 “报文往返时间 RTT 的值” 经常波动，所以 “超时重传时间 RTO 的值” 也应该是一个<strong>动态变化的值</strong>。这里我不做过多讲解，感兴趣的朋友可以自行查阅相关资料。</p><p>尽管超时重传机制能确保丢失的数据最终被重传，但它的局限性在于可能会导致<strong>较长的延迟</strong>，因为发送端需要等待定时器超时后才能重传数据。为了解决这一问题，TCP 引入了<strong>快速重传机制</strong>。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>TCP 还引入了另一种称为<strong>快速重传（Fast Retransmit）<strong>的机制。这种机制</strong>不是依靠时间，而是依靠数据驱动来触发重传</strong>。</p><p>那么，快速重传机制是如何工作的呢？其实很简单，一图胜千言。</p><p><img src="https://pic1.imgdb.cn/item/67e21b470ba3d5a1d7e2e700.png" alt="在这里插入图片描述"></p><p>在上图中，发送方依次发出了 1，2，3，4，5 份数据：</p><ol><li>第一份 <code>Seq1</code> 先送到了接收方，因此接收方返回 <code>ACK 2</code>。</li><li><code>Seq2</code> 因为某些原因没有到达接收方，而 <code>Seq3</code> 到达了接收方，所以接收方仍然返回 <code>ACK 2</code>。</li><li>随后，<code>Seq4</code> 和 <code>Seq5</code> 也成功到达了接收方，但接收方还是返回 <code>ACK 2</code>，因为它还在等待 <code>Seq2</code>。</li><li><strong>发送方收到三个 <code>ACK 2</code> 后，意识到 <code>Seq2</code> 丢失了，因此在定时器过期之前重传 <code>Seq2</code></strong>。</li><li>最后，接收方收到了重传的 <code>Seq2</code>，由于之前的 <code>Seq3</code>，<code>Seq4</code> 和 <code>Seq5</code> 都已经收到了，于是接收方返回 <code>ACK 6</code>。</li></ol><p>因此，快速重传的工作方式是在接收方收到三个相同的 ACK 报文时，发送方会在定时器过期之前重传丢失的报文段。</p><p>快速重传机制虽然解决了超时时间的问题，但仍然面临另一个问题：<strong>在重传时，应该重传丢失的一个报文段，还是重传所有报文段</strong>。</p><p>例如，在上述例子中，是只重传 <code>Seq2</code> 还是重传 <code>Seq2</code>、<code>Seq3</code>、<code>Seq4</code> 和 <code>Seq5</code>？因为发送端无法确定这连续的三个 <code>ACK 2</code> 是哪个报文段传回的。</p><p>根据 TCP 的不同实现，这两种情况都是可能的。因此，快速重传机制有时会显得<strong>不够精确</strong>。</p><p>为了更好地解决这个问题，即明确知道该重传哪些报文段，TCP 引入了 <strong>SACK（Selective Acknowledgment，选择性确认）</strong> 方法。</p><h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p>这种方法需要在 TCP 头部的「选项」字段中增加一个 SACK 字段。SACK 能将<strong>接收方的缓存状态发送给发送方</strong>，使发送方明确哪些数据已经收到，哪些数据还没有收到。通过这些信息，发送方可以<strong>只重传丢失的数据</strong>。</p><p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p><h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong>。</p><p>下面举两个例子来说明 D-SACK 的作用。</p><p><em>例子一：ACK 丢包</em></p><p><img src="https://pic1.imgdb.cn/item/67e21b500ba3d5a1d7e2e71d.png" alt="在这里插入图片描述"></p><ul><li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）。</li><li><strong>接收方发现数据重复收到，于是回了一个 SACK &#x3D; 3000~3500</strong>，告知「发送方」3000~3500 的数据早已被接收了。由于 ACK 已经到了 4000，意味着 4000 之前的所有数据都已收到，因此这个 SACK 就代表着 <code>D-SACK</code>。</li><li>这样「发送方」就知道了，数据并没有丢失，丢失的是「接收方」的 ACK 确认报文。</li></ul><p><em>例子二：网络延迟</em></p><p><img src="https://pic1.imgdb.cn/item/67e21b5c0ba3d5a1d7e2e74a.png" alt="在这里插入图片描述"></p><ul><li>数据包（1000~1499）由于网络延迟，导致「发送方」没有收到 Ack 1500 的确认报文。</li><li>后续报文到达时，三个相同的 ACK 确认报文触发了快速重传机制。重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li><li><strong>接收方回了一个 SACK&#x3D;1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包</strong>。</li><li>这样，「发送方」就知道快速重传触发的原因不是发出去的包丢失，也不是回应的 ACK 包丢失，而是由于网络延迟。</li></ul><p>可见，<code>D-SACK</code> 有以下几个好处：</p><ul><li>可以让「发送方」知道是发送出去的包丢了，还是接收方回应的 ACK 包丢了。</li><li>可以识别出「发送方」的数据包是否被网络延迟了。</li><li>可以检测网络中是否出现了「发送方」的数据包被复制的情况。</li></ul><p>在 Linux 下，可以通过 <code>net.ipv4.tcp_dsack</code> 参数来开启或关闭这个功能（在 Linux 2.4 版本之后默认是开启的）。</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>我们都知道TCP协议采用了一种基于可靠传输的设计，其中包含了确认应答机制，确保每一个数据包都能得到接收方的确认。这类似于两个人之间的对话，一方发送信息后必须等待另一方的回应，确认信息已被正确接收，然后才能发送下一条信息。</p><p>然而，这种一对一的应答机制就像是一场严格交替的对话，其中一个人必须完全专注于对方的回应，才能继续发言。这就好像我们在交流时，你必须暂停直到我对你的话做出反应，你才能继续你的思路，这显然是低效且不符合日常交流习惯的。</p><p><img src="https://pic1.imgdb.cn/item/67e21b660ba3d5a1d7e2e76d.png" alt="在这里插入图片描述"></p><p>因此，这种传输方式存在一个缺点：<strong>数据包的往返时间越长，通信效率就越低</strong>。</p><p>为了解决这个问题，TCP 引入了<strong>窗口机制</strong>。即使在往返时间较长的情况下，窗口机制也能保持较高的通信效率。</p><p>有了窗口机制，可以指定窗口大小，窗口大小指的是<strong>无需等待确认应答</strong>即可<strong>继续发送数据的最大量</strong>。</p><p>窗口的实现实际上是在操作系统中开辟一个缓存空间，发送方主机在等待确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，数据就可以从缓存区清除。</p><p>假设窗口大小为 <strong>3</strong> 个 TCP 段，那么发送方就可以「连续发送」 <strong>3</strong> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="https://pic1.imgdb.cn/item/67e21b6d0ba3d5a1d7e2e784.png" alt="在这里插入图片描述"></p><p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><blockquote><p>窗口大小由哪一方决定？</p></blockquote><p>TCP头中有一个字段称为窗口大小（Window）。</p><p>这个字段由接收端用来告知发送端自身剩余的缓冲区容量。根据接收端的处理能力，发送端可以调整发送数据的速度，避免接收端因处理不过来而导致数据丢失。</p><p>因此，通常情况下，窗口大小由接收端决定。</p><p>发送端发送的数据量不能超过接收端的窗口大小，否则接收端将无法正常接收这些数据。</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>发送方不能盲目地发送数据给接收方，需要考虑接收方的处理能力。</p><p>如果发送方不停地发送数据而不考虑接收方的处理能力，会导致接收方无法处理，进而触发重传机制，从而造成网络资源的浪费。</p><p>为了解决这种问题，<strong>TCP 提供了一种机制，使得发送方可以根据接收方的实际接收能力来控制数据发送量，这就是所谓的流量控制</strong>。这主要是通过<strong>滑动窗口（Sliding Window）</strong> 机制实现的。</p><p>想象一下，发送方和接收方之间有一条管道，数据就像水流一样通过这条管道。滑动窗口机制就像是在这条管道的接收端设置了一个可调节的阀门，用来控制水流的速度，确保接收方能够顺利处理所有流进的数据。</p><h2 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h2><h3 id="操作系统缓冲区"><a href="#操作系统缓冲区" class="headerlink" title="操作系统缓冲区"></a>操作系统缓冲区</h3><p><strong>操作系统缓冲区</strong>是内存中用于暂时存储数据的区域，以便在数据传输过程中平衡生产和消费速率。操作系统在发送和接收数据时，都会用到缓冲区。</p><ol><li><strong>发送缓冲区</strong>：存储即将通过网络发送的数据。发送方应用程序将数据写入发送缓冲区，操作系统再根据网络状况和滑动窗口大小将数据发送出去。</li><li><strong>接收缓冲区</strong>：存储接收到的数据，等待应用程序读取。接收方从网络接收到的数据先存储在接收缓冲区，然后再由应用程序读取和处理。</li></ol><h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><p><strong>TCP滑动窗口</strong>是TCP协议用来控制数据流量和确保可靠传输的机制。它规定了在等待接收方确认（ACK）之前，发送方可以发送的数据量。</p><ol><li><strong>发送窗口</strong>：发送方维护一个发送窗口，包含已发送但未确认的数据量。这个窗口限制了发送方在等待ACK之前可以发送的数据量。</li><li><strong>接收窗口</strong>：接收方维护一个接收窗口，告诉发送方它可以接收的数据量。接收窗口大小通常由接收缓冲区的可用空间决定。</li></ol><h3 id="关系和协作"><a href="#关系和协作" class="headerlink" title="关系和协作"></a>关系和协作</h3><ol><li><p><strong>同步和协调</strong>：</p><ul><li><strong>发送缓冲区和发送窗口</strong>：发送缓冲区存储即将发送的数据，而发送窗口决定了在等待ACK之前可以发送的数据量。如果发送窗口变小（例如，接收方的接收缓冲区满了），发送方将减少发送速率，将更多数据留在发送缓冲区。</li><li><strong>接收缓冲区和接收窗口</strong>：接收缓冲区存储接收到但尚未被应用程序处理的数据。接收窗口大小通常反映了接收缓冲区的剩余空间。如果接收缓冲区快满了，接收窗口会变小，通知发送方减少发送速率。</li></ul></li><li><p><strong>窗口大小调整</strong>：</p><ul><li>接收方根据接收缓冲区的可用空间动态调整接收窗口大小，并通过ACK包通知发送方。发送方则根据接收窗口的大小调整发送数据的速率。</li><li>当接收缓冲区有足够空间时，接收方会增大接收窗口，允许发送方发送更多数据；当接收缓冲区空间不足时，接收方会减小接收窗口，限制发送方的数据传输速率。</li></ul></li><li><p><strong>数据流管理</strong>：</p><ul><li>操作系统通过缓冲区管理和滑动窗口机制，确保数据流在网络上传输时的平稳性和可靠性。缓冲区用来平衡发送方和接收方的处理速度，而滑动窗口用来控制数据传输的节奏，避免网络拥堵和数据丢失。</li></ul></li></ol><h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>在TCP流量控制中，“<strong>窗口关闭</strong>”是指接收窗口的大小变为零的情况。这意味着接收方目前没有可用缓冲区空间来接收更多的数据，因此它告诉发送方暂停发送新的数据包，直到缓冲区有空闲空间为止。这种情况可能发生在接收方的应用程序<strong>处理数据速度较慢</strong>或者<strong>系统资源不足</strong>时。</p><ol><li><strong>窗口关闭的触发</strong></li></ol><ul><li><strong>接收窗口为零</strong>：当接收方的缓冲区满了，接收窗口的大小就会变为零，通知发送方不要再发送数据。</li><li><strong>ACK 包中的窗口大小</strong>：接收方在发送ACK包时，会在窗口大小字段中填入0，表示当前无法接收更多的数据。</li></ul><ol start="2"><li><strong>发送方的反应</strong></li></ol><ul><li><strong>停止发送数据</strong>：发送方在接收到窗口大小为零的ACK包后，会停止发送新的数据包。</li><li><strong>Zero Window Probe</strong>：发送方会定期发送零窗口探测包（Zero Window Probe），询问接收方的窗口大小是否恢复。如果接收方的缓冲区有了新的可用空间，会回复一个窗口更新包。</li></ul><ol start="3"><li><strong>窗口重新开放</strong></li></ol><ul><li><strong>接收方缓冲区释放空间</strong>：接收方应用程序处理数据，释放缓冲区空间后，接收窗口会重新开放。</li><li><strong>更新窗口大小</strong>：接收方在下一次发送ACK包时，会更新窗口大小字段，通知发送方当前可以接收的数据量。</li><li><strong>恢复数据传输</strong>：发送方收到更新后的窗口大小后，继续发送数据。</li></ul><blockquote><p>窗口关闭潜在的危险</p></blockquote><p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p><p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p><p><img src="https://pic1.imgdb.cn/item/67e21b780ba3d5a1d7e2e7a1.png" alt="在这里插入图片描述"></p><p>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了<strong>死锁</strong>的现象。</p><blockquote><p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p></blockquote><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器</strong>。</p><p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p><img src="https://pic1.imgdb.cn/item/67e21b830ba3d5a1d7e2e7c3.png" alt="在这里插入图片描述"></p><ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li><li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li></ul><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p><h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><p>如果接收方太忙，没空处理数据，那么发送方的发送窗口就会越来越小。</p><p>到最后，<strong>接收方终于挤出一点时间，腾出了几个字节的空间，并通知发送方：“好了，现在有几个字节可以用了！” 结果，发送方二话不说就立即发送这几个字节的数据。这就是传说中的糊涂窗口综合症</strong>。</p><p>要知道，<code>TCP + IP</code> 的头部就占了 <code>40</code> 个字节，为了传输这几个字节的数据要耗费这么多资源，真是亏大了。</p><p>这就好比一辆能载 50 人的大巴车，每次只来了几个人就发车。除非司机是个土豪，不然这么干迟早要破产。其实，解决这个问题也不难。大巴司机只需要等乘客人数超过 25 人再发车，这样就不会浪费资源啦。</p><p>要不，司机还可以挂个牌子：“车不满，不发车！”</p><p>糊涂窗口综合症的现象是可以发生在发送方和接收方：</p><ul><li><strong>接收方可以通告一个小的窗口</strong></li><li><strong>而发送方可以发送小数据</strong></li></ul><p>于是，要解决糊涂窗口综合症，就解决上面两个问题就可以了</p><ul><li><strong>让接收方不通告小窗口给发送方</strong></li><li><strong>让发送方避免发送小数据</strong></li></ul><blockquote><p>怎么让接收方不通告小窗口呢？</p></blockquote><p>接收方就像餐厅的后厨，如果后厨的盘子（缓存空间）快放不下了（窗口小于 <strong>min( MSS, 缓存空间的一半 )</strong>），就会对前台（发送方）说：“别再接单了！” 相当于通告窗口为 0。</p><p>然后后厨开始忙着把盘子上的菜端出去（处理数据）。当盘子上有足够的空间（窗口大小 &gt;&#x3D; MSS 或者缓存空间的一半可以使用），后厨就会对前台说：“可以继续接单了！” 这样前台就可以继续接新的订单（发送数据）。</p><p>这样一来，后厨就不会被堆积的订单压垮，也不会因为只处理几个订单就浪费大量资源。所有人都轻松，生意也更好。</p><blockquote><p>怎么让发送方避免发送小数据呢？</p></blockquote><p><strong>Nagle 算法</strong>就像一个超级节约的快递公司老板，他有两个发货规则：</p><ul><li>如果车（窗口大小）能装满（&gt;&#x3D; <code>MSS</code>），或者快递包裹够大（&gt;&#x3D; <code>MSS</code>），就可以发货。</li><li>必须等到之前发出的快递收到回执（<code>ACK</code>）才能发下一批。</li></ul><p>如果这两个条件都没满足，老板就会一直囤积包裹，等到条件满足后再发货。</p><p>然而，对于一些需要快速小包裹来回跑的情况，比如送外卖（telnet 或 ssh），这种策略就不合适了。外卖小哥不能等满车再走，要不然客户早就饿晕了。这时，快递公司就会关闭节约模式（Nagle 算法），直接派人送餐（关闭 <code>TCP_NODELAY</code> 选项），保证外卖快速送达。</p><p>所以，不是所有情况下都需要节约模式，有时候迅速响应更重要！</p><p>可以在 <code>Socket</code> 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="type">char</span> *)&amp;value, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><blockquote><p>为什么要有拥塞控制呀，不是有流量控制了吗？</p></blockquote><p>流量控制是为了防止发送方的数据量超过接收方的缓存能力，确保接收方不会被过多数据淹没。然而，这种控制机制无法感知网络层的状况。</p><p>在计算机网络中，网络带宽是共享资源，其他主机的通信可能导致网络拥堵。<strong>网络拥堵时，如果继续发送大量数据包，会增加数据包的延迟和丢包率。TCP 会尝试重传这些丢失的数据，但这会进一步加重网络负担，从而导致更高的延迟和更多的丢包，形成恶性循环</strong>。</p><p>为了避免这种情况，TCP 引入了<strong>拥塞控制</strong>机制。拥塞控制的目的是防止发送方的数据填满整个网络。为此，TCP 使用了一个名为<strong>拥塞窗口</strong>的概念，该窗口用于限制发送方可以发送的数据量，从而降低网络拥塞的风险。拥塞窗口根据网络状况动态调整，确保数据传输既不超出接收方处理能力，也不会导致网络拥堵。</p><blockquote><p>什么是拥塞窗口？和发送窗口有什么关系呢？</p></blockquote><p><strong>拥塞窗口（Congestion Window，CWND）</strong> 是 TCP 协议中用于拥塞控制的一个重要概念。它表示发送方在不引发网络拥塞的情况下，能够发送的最大数据量。拥塞窗口的大小动态调整，以<strong>反映网络当前的拥塞状况</strong>。具体来说，拥塞窗口的大小基于网络的反馈信息（如延迟、丢包等）来增加或减少，从而控制数据的发送速率，避免过度拥塞。</p><p><strong>发送窗口（Send Window）</strong> 是流量控制的概念，表示发送方能够发送但尚未被接收方确认的数据量。<strong>发送窗口的大小由接收方的接收窗口（Receiver Window）和拥塞窗口（CWND）中较小者决定</strong>。接收窗口控制着发送方的最大发送数据量，以避免淹没接收方的缓存，而拥塞窗口则控制着网络的总负载，防止网络拥堵。</p><p>总的来说，发送窗口和拥塞窗口在数据传输中共同作用：<strong>发送窗口确保发送方不会超出接收方的处理能力，而拥塞窗口则防止发送方的数据过多地填满网络造成拥堵</strong>。最终，TCP 发送方会根据这<strong>两个窗口的最小值</strong>来决定实际可以发送的数据量。</p><blockquote><p>那么怎么知道当前网络是否出现了拥塞呢？</p></blockquote><p>其实，如果发送方在规定时间内没有收到 ACK 确认报文，也就是说发生了<strong>超时重传，发送方就会认为网络出现了拥塞</strong>。这是因为超时通常表明网络传输出现了问题，可能是由于网络拥堵或丢包造成的。因此，发送方会把这种超时情况视作网络拥塞的信号，并调整其发送策略以缓解拥塞。</p><blockquote><p>拥塞控制有哪些控制算法？</p></blockquote><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h2 id="1-慢启动（Slow-Start）："><a href="#1-慢启动（Slow-Start）：" class="headerlink" title="1. 慢启动（Slow Start）："></a>1. <strong>慢启动（Slow Start）：</strong></h2><ul><li><strong>目的：</strong> 快速找出网络的最大容量。</li><li><strong>方法：</strong> 开始时用很小的数据量发送，接收到确认后，发送量快速增加。就像在探测水深时，从小处开始，然后快速加深。</li></ul><h2 id="2-拥塞避免（Congestion-Avoidance）："><a href="#2-拥塞避免（Congestion-Avoidance）：" class="headerlink" title="2. 拥塞避免（Congestion Avoidance）："></a>2. <strong>拥塞避免（Congestion Avoidance）：</strong></h2><ul><li><strong>目的：</strong> 平稳增加发送数据量，避免网络拥堵。</li><li><strong>方法：</strong> 当网络负担较重时，发送数据量的增加变得比较慢。就像在汽车进入拥堵区时，从加速驾驶改为平稳驾驶。</li></ul><h2 id="3-快重传（Fast-Retransmit）："><a href="#3-快重传（Fast-Retransmit）：" class="headerlink" title="3. 快重传（Fast Retransmit）："></a>3. <strong>快重传（Fast Retransmit）：</strong></h2><ul><li><strong>目的：</strong> 迅速重传丢失的数据包。</li><li><strong>方法：</strong> 如果发现某个数据包的确认收不到，发送方会快速重传这个数据包，而不是等到超时。就像收到一个丢失的邮件后，立刻重新发送。</li></ul><h2 id="4-快恢复（Fast-Recovery）："><a href="#4-快恢复（Fast-Recovery）：" class="headerlink" title="4. 快恢复（Fast Recovery）："></a>4. <strong>快恢复（Fast Recovery）：</strong></h2><ul><li><strong>目的：</strong> 在发现丢包后快速恢复数据传输。</li><li><strong>方法：</strong> 快重传后，拥塞窗口会减少到一半，然后逐渐恢复到正常速度。就像在堵车后，车速会先减慢，再慢慢恢复正常行驶。</li></ul><h2 id="拥塞算法示意图"><a href="#拥塞算法示意图" class="headerlink" title="拥塞算法示意图"></a>拥塞算法示意图</h2><p><img src="https://pic1.imgdb.cn/item/67e21b900ba3d5a1d7e2e7f2.png" alt="在这里插入图片描述"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><strong>小林coding</strong>——TCP 重传、滑动窗口、流量控制、拥塞控好难？看完图解就不愁了（重制）<br><img src="https://pic1.imgdb.cn/item/67e21b9e0ba3d5a1d7e2e820.png" alt="在这里插入图片描述"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>啊哈，让我们以一种轻松愉快的方式总结一下TCP的那些事儿吧！</p><p>想象一下，你和你的朋友在玩“扔沙包”游戏，但是你们俩中间隔着一个特别长的隧道。为了让游戏进行得既公平又有趣，你们发明了一套规则：</p><ol><li><p><strong>TCP重传</strong> —— 如果你扔过去的沙包，你的朋友没接到，他会喊一声：“没接到，再扔一次！”于是你就得重新扔过去。这就是TCP重传，确保数据包准确无误地到达目的地。</p></li><li><p><strong>滑动窗口</strong> —— 假设你朋友的口袋只能装三个沙包，他告诉你：“一次扔三个，多了我接不住。”这就是滑动窗口，它控制了你一次能扔多少沙包，确保你的朋友能处理得过来。</p></li><li><p><strong>流量控制</strong> —— 有时候你的朋友在忙别的事，他就说：“慢点扔，我这忙着呢。”这就是流量控制，它确保你的朋友不会被沙包淹没，也就是防止数据溢出。</p></li><li><p><strong>拥塞控制</strong> —— 如果隧道里有很多人在玩这个游戏，大家都扔沙包，那隧道就会堵住。所以你们得聪明点，看看隧道里情况怎么样，适当调整扔沙包的频率，这就是拥塞控制，避免整个网络被数据包堵死。</p></li></ol><p>所以，TCP协议就是你们玩“扔沙包”游戏时制定的一系列规则，确保游戏既好玩又不会让任何人受伤，或者让隧道变成沙包海洋。记住，无论游戏多么复杂，只要规则清晰，每个人都能玩得开心！</p><p>这就是TCP协议背后的“扔沙包”哲学，你get到了吗？下次当你在网络的海洋中遨游时，不妨想想你其实是在玩一场高级的“扔沙包”游戏哦！每一次点击、每一次加载，都是一次精准投掷和默契接应的展现！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis相关面试题</title>
      <link href="/2025/03/25/Redis%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/25/Redis%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h3 id="面试官：-分布式缓存常⻅的技术选型⽅案有哪些？"><a href="#面试官：-分布式缓存常⻅的技术选型⽅案有哪些？" class="headerlink" title="面试官： 分布式缓存常⻅的技术选型⽅案有哪些？"></a><strong>面试官：</strong> 分布式缓存常⻅的技术选型⽅案有哪些？</h3><p><strong>候选人</strong>：</p><p>分布式缓存的话，使⽤的⽐多的主要是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项⽬使⽤ <strong>Memcached</strong> 来做缓存，都是直接⽤ <strong>Redis</strong>。</p><h3 id="面试官：-说⼀下-Redis-和-Memcached-的区别和共同点"><a href="#面试官：-说⼀下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="面试官：  说⼀下 Redis 和 Memcached 的区别和共同点"></a><strong>面试官：</strong>  说⼀下 Redis 和 Memcached 的区别和共同点</h3><p><strong>共同点</strong> ：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong> ：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash，string 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</li><li><strong>Memcached 没有原生的集群模式</strong>，需要依靠客户端来实现往集群中分片写入数据；但是 <strong>Redis 目前是原生支持集群模式的</strong>。</li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> </li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。</li><li>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li></ol><h3 id="面试官：-Redis-五种常见数据结构以及使用场景分析（高频）"><a href="#面试官：-Redis-五种常见数据结构以及使用场景分析（高频）" class="headerlink" title="面试官： Redis 五种常见数据结构以及使用场景分析（高频）"></a><strong>面试官：</strong> Redis 五种常见数据结构以及使用场景分析<code>（高频）</code></h3><p><strong>候选人：</strong></p><blockquote><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。</p></blockquote><h4 id="1-string（SDS与C字符串）"><a href="#1-string（SDS与C字符串）" class="headerlink" title="1. string（SDS与C字符串）"></a>1. string（SDS与C字符串）</h4><p>它是 Redis 最基础的数据结构，它可以存储文本、数字或二进制数据。它的特点是一个键对应一个值，且支持原子操作，比如递增（INCR）、递减（DECR）等，主要用于缓存简单的键值对数据，比如用户会话信息或计数器。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。</p><p><img src="https://pic1.imgdb.cn/item/67e166dd0ba3d5a1d7e2a5fd.png" alt="image-20250220231134849"></p><blockquote><p>拓展：SDS与C字符串的区别（源自《Redis设计与实现》 2.2节）</p><ol><li><strong>常数时间获取长度</strong>：C字符串需要遍历整个字符串来计算长度，复杂度为O(N)。而SDS通过<code>len</code>属性记录长度，获取长度只需O(1)。</li><li><strong>防止缓冲区溢出</strong>：SDS在修改前会检查空间是否足够，若不足则自动扩展空间，避免了C字符串因空间不足导致的缓冲区溢出问题。</li><li><strong>减少内存重分配</strong>：C字符串修改时总需重分配数组（长度与字符数直接相关），而SDS通过<code>free</code>属性记录未使用空间，解耦了字符串长度与数组长度的关联，减少了修改时的内存重分配次数。</li></ol></blockquote><h4 id="2-list"><a href="#2-list" class="headerlink" title="2. list"></a>2. list</h4><p>它是一个有序的字符串集合，支持从两端插入和删除元素。它的特点是底层采用<strong>双向链表</strong>，插入和删除操作非常高效。另外，支持队列和栈的操作，比如先进先出（FIFO）或后进先出（LIFO）。常用于消息队列、任务调度等场景。</p><h4 id="3-hash"><a href="#3-hash" class="headerlink" title="3. hash"></a>3. hash</h4><p>它是一种键值对集合，适合<strong>存储对象</strong>。它的特点是允许在一个键下存储多个字段和值，类似于 Java 中的 Map。其底层实现为哈希表，适合存储结构化数据，比如用户信息。它支持对单个字段的操作，比如 <code>HGET</code> 和 <code>HSET</code>。</p><h4 id="4-set"><a href="#4-set" class="headerlink" title="4. set"></a>4. set</h4><p>它是一个无序且不允许重复元素的字符串集合。它的特点是底层<strong>采用哈希表</strong>，在查找和插入操作的时间复杂度为 O(1)。且支持集合运算，比如交集（SINTER）、并集（SUNION）和差集（SDIFF）。常用于去重、标签系统等场景。</p><h4 id="5-zset（跳表）"><a href="#5-zset（跳表）" class="headerlink" title="5. zset（跳表）"></a>5. zset（跳表）</h4><p>它也是一种集合，但它的每个元素都关联一个分数，元素按照分数排序。它的特点是在底层实现结合了<strong>跳表和哈希表</strong>，支持高效的范围查询。且元素唯一且有序，适合需要排序的场景，比如<strong>排行榜</strong>。还支持按分数范围获取元素，比如 <code>ZRANGE</code> 和 <code>ZRANGEBYSCORE</code>。</p><blockquote><h3 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p>那跳表长什么样呢？这里举个例子，下图展示了一个层级为 3 的跳表。</p><p><img src="https://pic1.imgdb.cn/item/67e166e60ba3d5a1d7e2a602.png" alt="image-20250220231507561"></p><p><img src="https://pic1.imgdb.cn/item/67e166ec0ba3d5a1d7e2a605.png" alt="image-20250311091842807"></p><p><code>zset</code> 的插入操作：</p><ol><li><strong>检查是否已存在</strong>：先查哈希表，若存在，则更新分数并调整跳表位置；若不存在，则在跳表中新增节点。</li><li><strong>跳表插入</strong>：生成一个<strong>随机层数</strong>（Redis 使用幂次分布，最高层数 <code>ZSKIPLIST_MAXLEVEL=32</code>）。从头节点开始，逐层寻找合适的插入位置。在找到的位置插入新节点，并连接前后指针。</li><li><strong>哈希表更新</strong>：将 <code>value</code> 和 <code>score</code> 插入哈希表，保证快速查询。</li></ol><p><code>zset</code> 的删除操作：</p><ol><li><strong>从哈希表中删除该元素</strong></li><li><strong>在跳表中删除该元素：</strong> 遍历跳表，找到待删除元素的前驱节点；解除节点的前后指针链接，释放内存。</li></ol><table><thead><tr><th align="center">操作</th><th align="center">主要数据结构</th><th align="center">复杂度</th></tr></thead><tbody><tr><td align="center">插入 (<code>ZADD</code>)</td><td align="center">跳表 + 哈希表</td><td align="center">O(log n)</td></tr><tr><td align="center">删除 (<code>ZREM</code>)</td><td align="center">跳表 + 哈希表</td><td align="center">O(log n)</td></tr><tr><td align="center">查找 (<code>ZSCORE</code>)</td><td align="center">哈希表</td><td align="center">O(1)</td></tr><tr><td align="center">排序 (<code>ZRANGE</code>)</td><td align="center">跳表</td><td align="center">O(log n + k)</td></tr><tr><td align="center">计算排名 (<code>ZRANK</code>)</td><td align="center">跳表</td><td align="center">O(log n)</td></tr></tbody></table></blockquote><hr><h3 id="面试官：-微博上的热度排行榜用什么数据结构"><a href="#面试官：-微博上的热度排行榜用什么数据结构" class="headerlink" title="面试官： 微博上的热度排行榜用什么数据结构"></a><strong>面试官：</strong> 微博上的热度排行榜用什么数据结构</h3><p><strong>候选人：</strong></p><p>在设计微博排行榜时，可以利用 Redis 的 ZSet（有序集合）来实现高效的分数排序和管理。ZSet 允许以用户的得分作为分数（Score），用户ID作为元素的值，支持按照分数从高到低的排序。</p><blockquote><p><strong>如果分数相同，按照默认的排序规则会按照value值排序，但希望按照时间顺序排序，也就是分数相同的情况下先上榜的排在前面。</strong></p><p>为了应对分数相同的情况，并满足“分数相同的用户按时间顺序排序”的需求，可以通过在分数中嵌入时间戳来解决。具体方法是将分数设置为一个浮点数，计算公式为：<code>score = 分数 + 1 - 时间戳 / 1e13</code>。其中，整数部分表示用户的实际得分，小数部分通过时间戳缩放后形成一个微小的值。由于时间早的时间戳较小，经过 <code>1 - 时间戳 / 1e13</code> 处理后，时间越早的小数部分越大，从而确保了在分数相同的情况下先上榜的用户排在前面。</p></blockquote><hr><h3 id="面试官：-Redis为什么用跳表而不用平衡树？"><a href="#面试官：-Redis为什么用跳表而不用平衡树？" class="headerlink" title="面试官： Redis为什么用跳表而不用平衡树？"></a><strong>面试官：</strong> Redis为什么用跳表而不用平衡树？</h3><p><strong>候选人：</strong>（相关阅读：<a href="https://blog.csdn.net/weixin_74199893/article/details/140401043?spm=1001.2014.3001.5501">揭秘！MySQL索引背后的秘密武器：B+树为何力压跳表，独领风骚？</a>）</p><blockquote><p>对于这个问题，Redis的作者 @antirez 是这么说的：</p><ul><li><p>它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 BTree 占用更少的内存。</p></li><li><p>Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。</p></li><li><p>它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N)) 中实现了 ZRANK。它只需要对代码进行少量修改。</p></li></ul></blockquote><p><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</p><p><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</p><p><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><hr><h3 id="面试官：-Redis-事务支持回滚吗？"><a href="#面试官：-Redis-事务支持回滚吗？" class="headerlink" title="面试官： Redis 事务支持回滚吗？"></a><strong>面试官：</strong> Redis 事务支持回滚吗？</h3><p><strong>候选人：</strong></p><p><strong>Redis 中并没有提供回滚机制</strong>，虽然 Redis 提供了 <code>DISCARD</code> 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p><p>你可以将Redis中的事务就理解为 ：<strong>Redis事务提供了⼀种将多个命令请求打包的功能。然后，再按顺序执⾏打包的所有命令，并且不会被中途打断。</strong></p><p><em>然而，需要注意的是Redis的事务并非传统意义上的ACID事务，它并不保证原子性、一致性、隔离性和持久性。相反，Redis事务主要用于确保命令执行的顺序性。</em></p><blockquote><p>拓展：<strong>Redis事务实现</strong></p><p>Redis 可以通过 <code>MULTI</code><strong>，</strong><code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code> 等命令来实现事务(transaction)功能。</p><p>使用 <code>MULTI</code> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code> 命令将执行所有命令。</p><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）。</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol><p>你也可以通过 <code>DISCARD</code> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p><p><code>WATCH</code> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p></blockquote><hr><h3 id="面试官：什么是缓存穿透-怎么解决-（高频）"><a href="#面试官：什么是缓存穿透-怎么解决-（高频）" class="headerlink" title="面试官：什么是缓存穿透 ? 怎么解决 ?（高频）"></a><strong>面试官</strong>：什么是缓存穿透 ? 怎么解决 ?<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>缓存穿透是指查询一个一定<strong>不存在</strong>的数据，如果在缓存和数据库中都不存在，每次这个值的查询请求都会穿透到数据库，可能导致数据库挂掉。</p><p>解决方案的话，我们通常都会用<strong>布隆过滤器</strong>来解决它，或者给缓存设个空值（null），并设置较短的过期时间。这样可以避免重复查询数据库。</p><hr><h3 id="面试官：好的，你能介绍一下布隆过滤器吗？（高频）"><a href="#面试官：好的，你能介绍一下布隆过滤器吗？（高频）" class="headerlink" title="面试官：好的，你能介绍一下布隆过滤器吗？（高频）"></a><strong>面试官</strong>：好的，你能介绍一下布隆过滤器吗？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>布隆过滤器主要是用于检索一个元素是否在一个集合中。</p><p>它的底层主要是先去<strong>初始化一个比较大数组</strong>，里面存放的二进制0或1。在一开始都是0，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。</p><p>当然是有缺点的，布隆过滤器有<strong>可能会产生一定的误判</strong>，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p><hr><h3 id="面试官：什么是缓存击穿-怎么解决-（高频）"><a href="#面试官：什么是缓存击穿-怎么解决-（高频）" class="headerlink" title="面试官：什么是缓存击穿 ? 怎么解决 ?（高频）"></a><strong>面试官</strong>：什么是缓存击穿 ? 怎么解决 ?<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>缓存击穿的意思是对于设置了过期时间的key，<strong>缓存在某个时间点过期的时候</strong>，恰好这时间点对这个Key<strong>有大量的并发请求过来</strong>，这些请求发现缓存过期一般都会从数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把数据库压垮。</p><p>解决方案有两种方式：</p><p>第一可以使用互斥锁：当缓存失效时，不立即去加载数据库，用 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行加载数据库的操作并回设缓存，否则重试get缓存的方法。</p><p>第二种方案可以设置当前key逻辑过期，大概是思路如下：</p><ol><li><strong>缓存数据带有过期时间</strong>：在缓存数据时，除了存储数据，还会存储一个<code>逻辑上的过期时间</code>。</li><li><strong>判断逻辑过期</strong>：当请求过来时，首先从缓存取数据。如果缓存还没到过期时间，直接返回数据。如果过期了，就返回旧数据（不是最新的），<strong>不马上查数据库</strong>。</li><li><strong>后台更新缓存</strong>：当缓存过期时，系统会开启一个后台线程去从数据库重新加载数据，更新缓存。这样不会让多个请求同时去打数据库，避免冲击。</li></ol><p>当然两种方案各有利弊：</p><p>如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题。</p><p>如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</p><hr><h3 id="面试官：什么是缓存雪崩-怎么解决-（高频）"><a href="#面试官：什么是缓存雪崩-怎么解决-（高频）" class="headerlink" title="面试官：什么是缓存雪崩 ? 怎么解决 ?（高频）"></a><strong>面试官</strong>：什么是缓存雪崩 ? 怎么解决 ?<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>缓存雪崩意思是设置缓存时<strong>采用了相同的过期时间</strong>，导致缓存在某一时刻同时失效，请求全部转发到数据库，数据库瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。</p><p><strong>解决方案：</strong></p><p>主要是可以将缓存失效时间分散开，设置不同的失效时间⽐如随机设置缓存的失效时间；</p><p>采⽤ Redis 集群，避免单机出现问题整个缓存服务都没办法使⽤；</p><p>采用是多级缓存，使用本地缓存作为一级缓存，Redis 作为二级缓存，减少对数据库的直接访问。</p><hr><h3 id="面试官：-说下三种缓存读写策略？"><a href="#面试官：-说下三种缓存读写策略？" class="headerlink" title="面试官： 说下三种缓存读写策略？"></a><strong>面试官：</strong> 说下三种缓存读写策略？</h3><p><strong>候选人：</strong></p><h4 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h4><p>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合<strong>读请求比较多</strong>的场景。</p><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p><p><strong>写</strong> ：</p><ul><li>先更新 DB</li><li>然后直接删除 cache 。</li></ul><p><strong>读</strong> :</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 DB 中读取数据返回</li><li>再把数据放到 cache 中。</li></ul><blockquote><p>“<strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong>”</p><p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。为什么呢？比如说现在有两个请求，请求一和请求二。请求一写入数据先删除cache，然后去更新DB；请求二去读取数据时发现没有在cache中找到（因为被请求一删掉了），这个时候请求二就会读取DB中的数据。恰好这时， <strong>请求一正在更新DB的过程中，请求二读取到了旧数据，并且返回旧数据到cache当中。</strong> 这样就导致了DB（新）和cache（旧）不一致的问题。</p></blockquote><blockquote><p>“<strong>在写数据的过程中，先更新 DB，后删除 cache 就没有问题了么？</strong>”</p><p><strong>答案</strong>：理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为<strong>缓存的写入速度</strong>是比<strong>数据库的写入速度</strong>快很多！在并发场景下，如果请求1更新数据库后未能成功删除缓存中的数据A，而请求2在此期间尝试读取数据A，可能会发生以下情况：</p><ul><li><strong>请求1更新数据库成功，但删除缓存失败</strong>。</li><li><strong>请求2尝试读取数据A，发现缓存中有旧数据A</strong>。</li><li><strong>请求2返回旧数据A，而不是最新的数据A</strong>。</li></ul></blockquote><p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p><p><strong>缺陷 1：首次请求数据一定不存在 cache 的问题</strong></p><p>解决办法：可以将热点数据可以提前放入 cache 中。</p><p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景 ：更新 DB 的时候同样更新 cache，不过我们需要<code>加一个锁/分布式锁</code>来保证更新 cache 的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新 DB 的时候同样更新 cache，但是<code>给缓存加一个比较短的过期时间</code>，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul><h4 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h4><p>Read&#x2F;Write Through Pattern 中服务端把 <strong>cache 视为主要数据存储</strong>，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p><p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 DB 的功能。</p><p><img src="https://pic1.imgdb.cn/item/67e166ff0ba3d5a1d7e2a60e.png" alt="image-20250220231606531"></p><p><img src="https://pic1.imgdb.cn/item/67e167060ba3d5a1d7e2a611.png" alt="image-20250220231618183"></p><p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，<strong>如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache</strong>，而 Read Through Pattern 则是 <strong>cache 服务自己来写入缓存</strong>的，这对客户端是透明的。</p><p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不存在 cache 的问题，对于热点数据可以提前放入缓存中。</p><h4 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h4><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 <strong>cache 服务来负责 cache 和 DB 的读写</strong>。</p><p>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p><p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 DB 的话，cache 服务可能就挂掉了。</p><p>这种策略在我们平时开发过程中也非常少见，但是不代表它的应用场景少，比如<strong>消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制</strong>都用到了这种策略。</p><p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p><hr><h3 id="面试官：如何保证Redis与MySQL的数据一致性？（超高频）"><a href="#面试官：如何保证Redis与MySQL的数据一致性？（超高频）" class="headerlink" title="面试官：如何保证Redis与MySQL的数据一致性？（超高频）"></a><strong>面试官</strong>：如何保证Redis与MySQL的数据一致性？<code>（超高频）</code></h3><p><strong>候选人</strong>：</p><p>首先是<strong>直接操作数据库和Redis</strong>，它们实现简单，但可能在高并发场景中面临一致性问题，且影响系统性能。</p><ul><li><strong>先写MySQL，再删除Redis</strong>，虽然保证了数据库一致性，但可能会出现缓存未及时更新的情况，导致短时间内缓存数据过期，影响系统的响应速度。</li><li><strong>通过Binlog异步更新Redis</strong>，这种方案保证了高一致性，并且由于是异步的，可以较少地影响性能，适合对一致性要求较高的场景。</li></ul><p>然后是使用<strong>Redis + Kafka实现缓存与数据库的一致性</strong>，在写入数据时，可以将操作信息发送到Kafka等消息队列，然后由消费者（可以是一个专门的服务）来处理数据库和缓存的同步。这种方案通过消息队列解耦了数据库和缓存的操作，确保两者的一致性。Kafka的可靠性保证了消息不丢失，因此可以保障一致性。</p><p>其次是使用<strong>Redis + TCC事务管理</strong>，TCC（Try-Confirm-Cancel）事务模型适用于分布式事务管理。在写入Redis和MySQL时，可以先在Redis进行预写操作（Try），然后确认MySQL的数据更新（Confirm），如果遇到失败，可以取消Redis的操作（Cancel）。这种方式通过分布式事务的处理，能够确保两者一致性，但需要额外的事务管理中间件，增加系统复杂度。</p><p>最后是使用<strong>分布式数据库中间件（如Sentinel, Canal等）</strong>，Redis的高可用架构可以借助Sentinel实现主从复制，保证缓存的高可用性和一致性。与此同时，Canal可以作为MySQL的增量数据订阅工具，实时同步数据库变更到Redis缓存。通过这种方式，可以实现高效的数据一致性保障，但配置和维护较为复杂。</p><hr><h3 id="面试官：你听说过延时双删吗？为什么不用它呢？"><a href="#面试官：你听说过延时双删吗？为什么不用它呢？" class="headerlink" title="面试官：你听说过延时双删吗？为什么不用它呢？"></a><strong>面试官</strong>：你听说过延时双删吗？为什么不用它呢？</h3><p><strong>候选人</strong>：延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。</p><hr><h3 id="面试官：redis做为缓存，数据的持久化是怎么做的？-怎么保证-Redis-挂掉之后再重启数据可以进⾏恢复-（高频）"><a href="#面试官：redis做为缓存，数据的持久化是怎么做的？-怎么保证-Redis-挂掉之后再重启数据可以进⾏恢复-（高频）" class="headerlink" title="面试官：redis做为缓存，数据的持久化是怎么做的？(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)（高频）"></a><strong>面试官</strong>：redis做为缓存，数据的持久化是怎么做的？(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>在Redis中提供了三种数据持久化的方式：<strong>1、RDB  2、AOF</strong>  <strong>3、混合持久化</strong></p><p>1）RDB是快照文件，它是把redis在内存中的数据库保存到磁盘里面，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsava 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><p>2）AOF是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 <code>redis.conf</code> 配置文件中的以下参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// redis.conf</span><br><span class="line">appendonly<span class="built_in">yes</span> //表示是否开启A0F持久化(默认 no，关闭)</span><br><span class="line">appendfilename<span class="string">&quot;appendonly.aof&quot;</span> // AOF持久化文件的名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Redis 的配置⽂件中存在三种不同的 AOF 持久化⽅式，它们分别是：</p><p><img src="https://pic1.imgdb.cn/item/67e167100ba3d5a1d7e2a614.png" alt="image-20250220231711198"></p><ul><li>如果要高性能，就选择 No策略:</li><li>如果要高可靠，就选择 Always 策略;.</li><li>如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。</li></ul><p>随着执行的命令越多，AOF 文件的体积自然也会越来越大，为了避免日志文件过大， Redis 提供了 <strong>AOF 重写机制</strong>，它会直接扫描数据中所有的键值对数据，然后为每一个键值对生成一条写操作命令，接着将该命令写入到新的 AOF 文件，重写完成后，就替换掉现有的 AOF 日志。<strong>重写的过程是由后台子进程完成的</strong>，这样可以使得主进程可以继续正常处理命令。</p><p>3）<strong>为什么会有混合持久化？<strong>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。AOF 优点是丢失数据少，但是数据恢复不快。为了集成了两者的优点， Redis 4.0 提出了</strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><hr><h3 id="面试官：这两种持久化方式有什么区别呢？"><a href="#面试官：这两种持久化方式有什么区别呢？" class="headerlink" title="面试官：这两种持久化方式有什么区别呢？"></a><strong>面试官</strong>：这两种持久化方式有什么区别呢？</h3><p><strong>候选人</strong>：</p><table><thead><tr><th>持久化方式</th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td align="center">定时对整个内存做快照</td><td align="center">记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td align="center">不完整，两次备份之间会丢失</td><td align="center">相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td align="center">会有压缩，文件体积小</td><td align="center">记录命令，文件体积很大</td></tr><tr><td>客户端恢复速度</td><td align="center">很快</td><td align="center">慢</td></tr><tr><td>数据恢复优先级</td><td align="center">低，因为数据完整性不如AOF</td><td align="center">高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td align="center">高，CPU的内存消耗大</td><td align="center">低，主要是硬盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td align="center">可以容忍几分钟的数据丢失，追求更快的启动速度</td><td align="center">对数据完整性要求较高，常见</td></tr></tbody></table><hr><h3 id="面试官：这两种方式，哪种恢复的比较快呢？"><a href="#面试官：这两种方式，哪种恢复的比较快呢？" class="headerlink" title="面试官：这两种方式，哪种恢复的比较快呢？"></a><strong>面试官</strong>：这两种方式，哪种恢复的比较快呢？</h3><p><strong>候选人</strong>：RDB文件是一个经过压缩的二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据。我们通常在项目中使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令。</p><hr><h3 id="面试官：Redis的过期删除策略有哪些-（高频）"><a href="#面试官：Redis的过期删除策略有哪些-（高频）" class="headerlink" title="面试官：Redis的过期删除策略有哪些 ? （高频）"></a><strong>面试官</strong>：Redis的过期删除策略有哪些 ? <code>（高频）</code></h3><p><strong>候选人</strong>：（源自《Redis设计与实现》 9.5节）</p><p>在redis中提供了三种数据过期删除策略：</p><p>第一种是定时删除，在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。<strong>对内存是最友好的，对CPU时间是最不友好的，影响服务器的响应时间和吞吐量。</strong></p><p>第二种是惰性删除，放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键；如果没有过期，就返回该键。<strong>对CPU时间是最友好的，对内存是最不友好的，有内存泄漏的风险。</strong></p><p>第三种是定期删除，每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。<strong>定期删除是前两种策略的一种整合和折中。</strong></p><blockquote><p>定期删除策略的难点是<strong>确定删除操作执行的时长和频率</strong>：</p><ul><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将 CPU 时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li></ul><p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p></blockquote><p>Redis的过期删除策略：<strong>惰性删除 + 定期删除</strong>两种策略进行配合使用。</p><blockquote><p><strong>Redis是如何判断数据是否过期的呢？</strong></p><p>每当我们对一个 key 设置了过期时间时，Redis  会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p>过期字典存储在 redisDb 结构中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;    <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span></span><br><span class="line">    dict *expires; <span class="comment">/* 键的过期时间 */</span></span><br><span class="line">    ....</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="面试官：Redis的数据淘汰策略有哪些-（MySQL-⾥有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据-）"><a href="#面试官：Redis的数据淘汰策略有哪些-（MySQL-⾥有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据-）" class="headerlink" title="面试官：Redis的数据淘汰策略有哪些 ? （MySQL ⾥有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?）"></a><strong>面试官</strong>：Redis的数据淘汰策略有哪些 ? （MySQL ⾥有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?）</h3><p><strong>候选人</strong>：</p><blockquote><p>仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在<strong>定期删除和惰性删除</strong>漏掉了很多过期 key 的情况。这样就导致⼤量过期 key 堆积在内存⾥，然后就OOM了。怎么解决这个问题呢？答案就是：<strong>Redis</strong> <strong>内存淘汰机制</strong>。</p></blockquote><p><img src="https://pic1.imgdb.cn/item/67e167190ba3d5a1d7e2a617.png" alt="image-20250220231802566"></p><p>这个在redis中提供了很多种，默认是<strong>noeviction</strong>，不删除任何数据，内部不足直接报错。</p><p>这是可以在redis的配置文件中进行设置的，里面有两个非常重要的概念，一个是<strong>LRU</strong>，另外一个是<strong>LFU</strong></p><p>LRU的意思是最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>LFU的意思是最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</p><p>我们在项目设置的<code>allkeys-lru</code>，挑选最近最少使用的数据淘汰，把一些经常访问的key留在redis中。</p><blockquote><p>可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">2) <span class="string">&quot;noeviction&quot;</span></span><br></pre></td></tr></table></figure><p>通过“<code>config set maxmemory-policy &lt;策略&gt;</code>”命令设置Redis 内存淘汰策略。</p></blockquote><hr><h3 id="面试官：Redis的内存用完了会发生什么？"><a href="#面试官：Redis的内存用完了会发生什么？" class="headerlink" title="面试官：Redis的内存用完了会发生什么？"></a><strong>面试官</strong>：Redis的内存用完了会发生什么？</h3><p><strong>候选人</strong>：</p><p>嗯~，这个要看redis的数据淘汰策略是什么，如果是默认的配置，redis内存用完以后则直接报错。我们当时设置的 <strong>allkeys-lru</strong> 策略。把最近最常访问的数据留在缓存中。</p><hr><h3 id="面试官：热-key-是什么-怎么解决"><a href="#面试官：热-key-是什么-怎么解决" class="headerlink" title="面试官：热 key 是什么?怎么解决?"></a><strong>面试官</strong>：热 key 是什么?怎么解决?</h3><p>Redis热key是指被频繁访问的key，可能会导致单个key的访问量过大，影响系统性能。解决方法包括:</p><p>• 开启内存淘汰机制，并选择使用LRU算法来淘汰不常用的key,保证内存中存储的是最热门的数据。</p><p>• 设置key的过期时间，确保key在一段时间后自动删除,防止长时间占用内存。</p><p>• 对热点key进行分片，将数据分散存储在不同的节点上,减轻单个key的压力。</p><hr><h3 id="面试官：普通的Redis分布式锁如何实现-（高频）"><a href="#面试官：普通的Redis分布式锁如何实现-（高频）" class="headerlink" title="面试官：普通的Redis分布式锁如何实现 ? （高频）"></a><strong>面试官</strong>：普通的Redis分布式锁如何实现 ? <code>（高频）</code></h3><p><strong>候选人</strong>：Redis 分布式锁实现步骤：</p><ol><li><p><strong>使用 <code>SETNX</code> 命令（SET if Not Exists）</strong>：</p><ul><li><code>SETNX</code> 是 Redis 的一个命令，用来在一个键不存在的情况下设置其值。这个命令可以保证只有一个客户端能够成功地设置值，其他客户端会失败。这相当于锁的加锁操作。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SETNX lockKey <span class="title function_">uniqueValue</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">&gt; SETNX lockKey <span class="title function_">uniqueValue</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当 <code>setnx</code> 返回 1 时，表示获取到锁；如果返回 0，表示锁已存在，未能获取到锁。</p></li><li><p><strong>给锁设置过期时间，防止死锁</strong>：</p><ul><li>如果客户端在持有锁期间发生崩溃或者网络异常，没有及时释放锁，其他客户端将永远无法获取到锁。这时可以设置一个自动释放锁的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET lockKey uniqueValue EX <span class="number">3</span> NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><strong>EX</strong>：过期时间设置（秒为单位）<code>EX 3</code> 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li></ul></li><li><p><strong>释放锁（DEL）</strong>：</p><ul><li>当客户端完成操作后，需要释放锁，通常通过 <code>DEL</code> 命令删除锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; DEL <span class="title function_">lockKey</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防止误删其他客户端的锁</strong>：</p><ul><li>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><p>普通的Redis 分布式锁可以通过 <code>SETNX</code> 实现，配合设置过期时间防止死锁，并使用 Lua 脚本确保只有锁的持有者才能释放锁，保证<strong>释放锁</strong>的原子性。</p><hr><h3 id="面试官：那你如何控制Redis实现分布式锁有效时长呢？（高频）"><a href="#面试官：那你如何控制Redis实现分布式锁有效时长呢？（高频）" class="headerlink" title="面试官：那你如何控制Redis实现分布式锁有效时长呢？（高频）"></a><strong>面试官</strong>：那你如何控制Redis实现分布式锁有效时长呢？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><blockquote><p><strong>普通的 Redis 分布式锁的缺陷:</strong></p><p>我们在网上看到的redis分布式锁的工具方法，大都满足互斥、防止死锁的特性，有些工具方法会满足可重入特性。</p><p>如果只满足上述3种特性会有哪些隐患呢？<strong>redis分布式锁无法自动续期</strong>，比如，一个锁设置了1分钟超时释放，如果拿到这个锁的线程在一分钟内没有执行完毕，那么这个锁就会被其他线程拿到，可能会导致严重的线上问题，比如超卖。</p></blockquote><p>的确，redis的setnx指令不好控制这个问题，我们当时采用的redis的一个框架redisson实现的。</p><p>在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在redisson中引入了一个<strong>看门狗机制</strong>，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了。</p><p>还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。</p><p><img src="https://pic1.imgdb.cn/item/67e167230ba3d5a1d7e2a61a.png" alt="image-20250225095502987"></p><hr><h3 id="面试官：-Redisson分布式锁如何实现？（高频）"><a href="#面试官：-Redisson分布式锁如何实现？（高频）" class="headerlink" title="面试官： Redisson分布式锁如何实现？（高频）"></a><strong>面试官：</strong> Redisson分布式锁如何实现？<code>（高频）</code></h3><p><strong>候选人：</strong></p><h4 id="核心实现步骤："><a href="#核心实现步骤：" class="headerlink" title="核心实现步骤："></a>核心实现步骤：</h4><ol><li><strong>创建 Redisson 客户端</strong>：通过 Redisson 配置连接 Redis。</li><li><strong>获取锁</strong>：使用 <code>RLock</code> 获取分布式锁。</li><li><strong>执行业务逻辑</strong>：在锁保护的临界区内处理业务。</li><li><strong>释放锁</strong>：业务完成后，手动释放锁。</li></ol><h4 id="核心代码实现（Java）："><a href="#核心代码实现（Java）：" class="headerlink" title="核心代码实现（Java）："></a>核心代码实现（Java）：</h4><ol><li>引入依赖：</li></ol><p>确保在你的 <code>pom.xml</code> 中已经添加了 Redisson 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.22.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请根据需要选择最新版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>实现分布式锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 配置 Redisson 客户端</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);  </span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 尝试加锁</span></span><br><span class="line">            <span class="keyword">if</span> (lock.lock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 临界区 - 执行你的业务逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock acquired, performing sensitive operations.&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);  <span class="comment">// 模拟处理时间</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 5. 释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock released.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭 Redisson 客户端</span></span><br><span class="line">            redissonClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a>代码说明：</h4><ol><li><p><strong>连接 Redis</strong>：通过 <code>Config</code> 配置 Redis 服务器地址，创建 <code>RedissonClient</code> 实例。</p></li><li><p><strong>获取锁</strong>：使用 <code>getLock(&quot;myLock&quot;)</code> 获取一个分布式锁对象 <code>RLock</code>，其中 <code>&quot;myLock&quot;</code> 是锁的名称，不同线程和服务可以通过相同的名称竞争该锁。</p></li><li><p><strong>尝试加锁</strong>：使用 <code>lock()</code>，表示拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>执行业务逻辑</strong>：模拟业务逻辑操作（如数据库操作、文件操作等）。</p></li><li><p><strong>释放锁</strong>：通过 <code>unlock()</code> 手动释放锁。即使在业务执行时发生异常，<code>finally</code> 块确保锁能正常释放。</p></li><li><p><strong>关闭 Redisson 客户端</strong>：在程序结束时调用 <code>shutdown()</code> 关闭 Redis 客户端，释放资源。</p></li></ol><hr><h3 id="面试官：好的，redisson实现的分布式锁是可重入的吗？"><a href="#面试官：好的，redisson实现的分布式锁是可重入的吗？" class="headerlink" title="面试官：好的，redisson实现的分布式锁是可重入的吗？"></a><strong>面试官</strong>：好的，redisson实现的分布式锁是可重入的吗？</h3><p><strong>候选人</strong>：是的，<strong>Redisson 实现的分布式锁是可重入的</strong>。这意味着同一个线程可以多次获取相同的锁，而不会被阻塞。每次获取锁时，锁的计数器会增加；当线程释放锁时，计数器会减少。只有当计数器降到 0 时，锁才真正释放，这样可以确保锁的持有者能够完成其工作，而不会被意外释放。</p><p><strong>代码验证：</strong></p><p>首先需要在pom.xml文件中添加redisson依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.22.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 根据需要选择最新版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置 Redisson</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6380&quot;</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取可重入锁</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;reentrantLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次获取锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock acquired once&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在同一线程中再次获取锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock acquired twice&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Processing critical section...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁，计数器减少</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock released once&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再次释放锁，彻底释放</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock released completely&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 Redisson 客户端</span></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://pic1.imgdb.cn/item/67e1672d0ba3d5a1d7e2a624.png" alt="image-20250225095520963"></p><hr><h3 id="面试官：-redisson实现的分布式锁能解决主从一致性的问题吗"><a href="#面试官：-redisson实现的分布式锁能解决主从一致性的问题吗" class="headerlink" title="面试官： redisson实现的分布式锁能解决主从一致性的问题吗"></a><strong>面试官</strong>： redisson实现的分布式锁能解决主从一致性的问题吗</h3><p><strong>候选人</strong>：这个是不能的，比如，当线程1加锁成功后，master节点数据会<strong>异步复制</strong>到slave节点，此时当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现<strong>两个节点同时持有一把锁</strong>的问题。</p><p>我们可以利用redisson提供的红锁来解决这个问题，它的主要作用是在多个redis实例上创建锁，并且要求在大多数redis节点上都成功创建锁，红锁中要求是redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。</p><p>但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁。</p><hr><h3 id="面试官：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？"><a href="#面试官：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？" class="headerlink" title="面试官：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？"></a><strong>面试官</strong>：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？</h3><p><strong>候选人：</strong> redis本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用zookeeper实现的分布式锁，它是可以保证强一致性的。</p><hr><h3 id="面试官：Redis集群有哪些方案-知道嘛"><a href="#面试官：Redis集群有哪些方案-知道嘛" class="headerlink" title="面试官：Redis集群有哪些方案, 知道嘛 ?"></a><strong>面试官</strong>：Redis集群有哪些方案, 知道嘛 ?</h3><p><strong>候选人</strong>：在Redis中提供的集群方案总共有三种：主从复制、哨兵模式、Redis分片集群。</p><hr><h3 id="面试官：那你来介绍一下主从复制"><a href="#面试官：那你来介绍一下主从复制" class="headerlink" title="面试官：那你来介绍一下主从复制"></a><strong>面试官</strong>：那你来介绍一下主从复制</h3><p><strong>候选人</strong>：嗯，是这样的，单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中。</p><p><img src="https://pic1.imgdb.cn/item/67e1684a0ba3d5a1d7e2a6e8.png" alt="图片"></p><hr><h3 id="面试官：说一下主从复制？（高频）"><a href="#面试官：说一下主从复制？（高频）" class="headerlink" title="面试官：说一下主从复制？（高频）"></a><strong>面试官</strong>：说一下主从复制？<code>（高频）</code></h3><p><strong>候选人</strong>：主从复制共有三种模式：<strong>全量复制、基于长连接的命令传播、增量复制</strong>。</p><p>1）全量复制是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：</p><p>第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id和offset偏移量。</p><p>第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。</p><p>第三：在同时主节点会执行bgsave，生成rdb文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这样就保持了一致。</p><p>当然，如果在rdb生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步。</p><p><img src="https://pic1.imgdb.cn/item/67e168520ba3d5a1d7e2a6fd.png" alt="image-20250225095536335"></p><p>2）命令传播指的是主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p><p>3）增量复制指的是，如果主从服务器间的<strong>网络连接断开了</strong>，那么就无法进行命令传播了，当网络恢复正常之后，数据就不一致了。所以这个时候，从节点会请求主节点同步数据，主节点还是判断是不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。</p><blockquote><p>拓展：<strong>怎么判断要执行的是全量同步还是增量同步呢？</strong></p><p>在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 <code>repl_backlog_buffer 缓冲区</code>里，因此这个缓冲区里会保存着最近传播的写命令。</p><p>网络断开后，当从服务器重新连上主服务器时，<strong>主从服务器</strong>会根据两者的 offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p><ul><li><p>如果判断出从服务器要读取的数据还在 <code>repl_backlog_buffer 缓冲区</code>里，那么主服务器将采用<strong>增量同步</strong>的方式；</p></li><li><p>相反，如果判断出从服务器要读取的数据已经不存在 <code>repl_backlog_buffer 缓冲区</code>里，那么主服务器将采用<strong>全量同步</strong>的方式。</p></li></ul></blockquote><hr><h3 id="面试官：怎么保证Redis的高并发高可用"><a href="#面试官：怎么保证Redis的高并发高可用" class="headerlink" title="面试官：怎么保证Redis的高并发高可用"></a><strong>面试官</strong>：怎么保证Redis的高并发高可用</h3><p><strong>候选人</strong>：首先可以搭建主从集群，再加上使用redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证redis的高并发高可用。</p><p><img src="https://pic1.imgdb.cn/item/67e168680ba3d5a1d7e2a72a.png" alt="图片"></p><hr><h3 id="面试官：redis集群脑裂，该怎么解决呢？"><a href="#面试官：redis集群脑裂，该怎么解决呢？" class="headerlink" title="面试官：redis集群脑裂，该怎么解决呢？"></a><strong>面试官</strong>：redis集群脑裂，该怎么解决呢？</h3><p><strong>候选人</strong>：嗯！ 这个在项目很少见，不过脑裂的问题是这样的，我们现在用的是redis的哨兵模式集群的</p><p>有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old master降为salve，这时再从新master同步数据，这会导致old master中的大量数据丢失。</p><p>关于解决的话，我记得在redis的配置中可以设置：第一可以设置最少的salve节点个数，比如设置至少要有一个从节点才能同步数据；第二个可以设置主从数据复制和同步的延迟时间不能超过xx秒，如果超过，主节点会禁止写数据。</p><hr><h3 id="面试官：redis的分片集群有什么作用"><a href="#面试官：redis的分片集群有什么作用" class="headerlink" title="面试官：redis的分片集群有什么作用"></a><strong>面试官</strong>：redis的分片集群有什么作用</h3><p><strong>候选人</strong>：分片集群主要解决的是，<strong>海量数据存储的问题</strong>，集群中有多个master，每个master保存不同数据，并且还可以给每个master设置多个slave节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点。</p><p><img src="https://pic1.imgdb.cn/item/67e1686f0ba3d5a1d7e2a73b.png" alt="图片"></p><hr><h3 id="面试官：Redis分片集群中数据是怎么存储和读取的？"><a href="#面试官：Redis分片集群中数据是怎么存储和读取的？" class="headerlink" title="面试官：Redis分片集群中数据是怎么存储和读取的？"></a><strong>面试官</strong>：Redis分片集群中数据是怎么存储和读取的？</h3><p><strong>候选人</strong>：</p><p>Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。</p><p>取值的逻辑是一样的。</p><hr><h3 id="面试官：-Redis-没有使⽤多线程？为什么不使⽤多线程？"><a href="#面试官：-Redis-没有使⽤多线程？为什么不使⽤多线程？" class="headerlink" title="面试官： Redis 没有使⽤多线程？为什么不使⽤多线程？"></a><strong>面试官：</strong> Redis 没有使⽤多线程？为什么不使⽤多线程？</h3><p><strong>候选人：</strong></p><p>虽然说 Redis 是单线程模型，但是， 实际上，<strong>Redis在4.0之后的版本中就已经加⼊了对多线程的⽀持。</strong></p><p><img src="https://pic1.imgdb.cn/item/67e168730ba3d5a1d7e2a742.png" alt="image-20250225095604217"></p><p>不过，Redis 4.0 增加的多线程主要是针对⼀些⼤键值对的删除操作的命令，使⽤这些命令就会使⽤主处理之外的其他线程来“异步处理”。</p><p>⼤体上来说，<strong>Redis 6.0</strong> <strong>之前主要还是单线程处理。那Redis6.0之前 为什么不使⽤多线程？</strong></p><p>主要原因有下⾯ 3 个：</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不再 CPU ，主要在内存和⽹络；</li><li>多线程就会存在死锁、线程上下⽂切换等问题，甚⾄会影响性能。</li></ol><hr><h3 id="面试官：Redis是单线程的，但是为什么还那么快？"><a href="#面试官：Redis是单线程的，但是为什么还那么快？" class="headerlink" title="面试官：Redis是单线程的，但是为什么还那么快？"></a><strong>面试官</strong>：Redis是单线程的，但是为什么还那么快？</h3><p><strong>候选人</strong>：</p><blockquote><p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W&#x2F;每秒</strong>，如下图所示：</p><p><img src="https://pic1.imgdb.cn/item/67e1687c0ba3d5a1d7e2a753.png" alt="图片"></p></blockquote><p>1、完全基于内存的，C语言编写</p><p>2、采用单线程，避免不必要的上下文切换可竞争条件</p><p>3、使用多路I&#x2F;O复用模型，非阻塞IO</p><hr><h3 id="面试官：能解释一下I-O多路复用模型？（高频）"><a href="#面试官：能解释一下I-O多路复用模型？（高频）" class="headerlink" title="面试官：能解释一下I&#x2F;O多路复用模型？（高频）"></a><strong>面试官</strong>：能解释一下I&#x2F;O多路复用模型？<code>（高频）</code></h3><p><strong>候选人</strong>：I&#x2F;O多路复用是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I&#x2F;O多路复用都是采用的<code>epoll模式</code>实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。</p><p>其中Redis的网络模型就是使用<strong>I&#x2F;O多路复用结合事件的处理器</strong>来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；</p><p><strong>在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</strong>。</p><hr><h3 id="面试官：-select、poll、epoll-的区别是什么？（高频）"><a href="#面试官：-select、poll、epoll-的区别是什么？（高频）" class="headerlink" title="面试官： select、poll、epoll 的区别是什么？（高频）"></a><strong>面试官：</strong> select、poll、epoll 的区别是什么？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><code>select</code>、<code>poll</code> 和 <code>epoll</code> 都用于 I&#x2F;O 多路复用，但它们在实现方式和性能上存在明显区别。<code>select</code> 采用固定大小的 fd 集合（默认 1024，可调），每次调用都需要遍历整个集合，导致性能随 fd 数量增加而下降。<code>poll</code> 虽然去除了 fd 数量的限制，改用链表存储，但仍然需要线性遍历所有 fd，效率并未本质提升。</p><p><code>epoll</code> 采用事件驱动模型，利用 <strong>红黑树</strong> 维护 fd，并通过 <strong>回调机制</strong> 仅监听活跃的 fd，避免了无意义的遍历，查询复杂度从 <code>O(n)</code> 降至 <code>O(1)</code>，适合大并发场景。此外，<code>epoll</code> 提供 <code>LT</code>（水平触发）和 <code>ET</code>（边缘触发）两种模式，<code>ET</code> 需要开发者处理可能的 <strong>数据丢失问题</strong>，但在高并发下性能更优。</p><blockquote><p>举个例子,你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是<code>边缘触发</code>；如果快递箱发现你的快递没有被取出, 它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是<code>水平触发</code>的方式。</p></blockquote><hr><h3 id="面试官：-Redis-如何实现延迟队列？"><a href="#面试官：-Redis-如何实现延迟队列？" class="headerlink" title="面试官： Redis 如何实现延迟队列？"></a><strong>面试官：</strong> Redis 如何实现延迟队列？</h3><p><strong>候选人：</strong></p><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p><ul><li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li><li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li><li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li></ul><p>在 Redis 可以使用 <strong>有序集合（ZSet）</strong> 的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p><p>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p><p><img src="https://pic1.imgdb.cn/item/67e168800ba3d5a1d7e2a75e.png" alt="image-20250225095627187"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端高频笔试题（非常规LC题）</title>
      <link href="/2025/03/24/%E5%90%8E%E7%AB%AF%E9%AB%98%E9%A2%91%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/24/%E5%90%8E%E7%AB%AF%E9%AB%98%E9%A2%91%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><strong>1. 常见的五种单例模式的实现⽅式<br>2. 约瑟夫环 （递归）<br>3. 交替打印奇偶数 （Semaphore、synchronized搭配wait、notify）<br>4. 交替打印 ABC （Semaphore）<br>5. 三个线程交替打印 1 到 99 （Semaphore、AtomicInteger）<br>6. 实现⼀个线程安全的计数器 （ThreadPool、AtomicInteger &#x2F; LongAdder）<br>7. 控制三个线程的执⾏顺序 （CountDownLatch、join）<br>8. 五⼈赛跑裁判 （ThreadPool、AtomicInteger、CountDownLatch）<br>9. LRU缓存（升级版：带缓存过期时间）</strong></p><h2 id="常见的五种单例模式的实现⽅式"><a href="#常见的五种单例模式的实现⽅式" class="headerlink" title="常见的五种单例模式的实现⽅式"></a>常见的五种单例模式的实现⽅式</h2><h3 id="1、枚举（推荐）"><a href="#1、枚举（推荐）" class="headerlink" title="1、枚举（推荐）:"></a>1、枚举（推荐）:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>《Effective Java》</strong> 作者推荐的⼀种单例实现⽅式，简单⾼效，⽆需加锁，线程安全，可以避免通过反射破坏枚举单例。</p><h3 id="2、静态内部类（推荐）"><a href="#2、静态内部类（推荐）" class="headerlink" title="2、静态内部类（推荐）:"></a>2、静态内部类（推荐）:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供获取实例的公共⽅法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部类 <code>Singleton</code> 被加载的时候，并不会创建静态内部类 <code>SingletonInner</code> 的实例对象。只有当调⽤ <code>getInstance()</code> ⽅法时， <code>SingletonInner</code> 才会被加载，这个时候才会创建单例对象<code>INSTANCE</code> 。<code>INSTANCE</code> 的唯⼀性、创建过程的线程安全性，都由 JVM 来保证。</p><p>这种⽅式同样简单⾼效，⽆需加锁，线程安全，并且⽀持延时加载。</p><h3 id="3、双重校验锁"><a href="#3、双重校验锁" class="headerlink" title="3、双重校验锁:"></a>3、双重校验锁:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">singlton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采⽤ <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code></p><p>这段代码其实是分为三步执⾏：</p><ol><li>为 <strong>uniqueInstance</strong> 分配内存空间</li><li>初始化 <strong>uniqueInstance</strong></li><li>将 <strong>uniqueInstance</strong> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 <code>1-&gt;3-&gt;2</code>。指令排在单线程环境下不会出现问题，但是在<strong>多线程</strong>环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ <code>getUniqueInstance ()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code> ，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>这种⽅式实现起来较麻烦，但同样线程安全，⽀持延时加载。</p><h3 id="4、饿汉式："><a href="#4、饿汉式：" class="headerlink" title="4、饿汉式："></a>4、饿汉式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="comment">// 类加载时就创建实例，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利⽤ Java 的静态特性，在类加载时就创建实例，天然线程安全，但可能会导致资源浪费。</p><h3 id="5、懒汉式："><a href="#5、懒汉式：" class="headerlink" title="5、懒汉式："></a>5、懒汉式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全的懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第⼀次使⽤时才创建实例。在多线程环境下，可能会出现多个线程同时进入 <code>if (instance == null)</code>语句块，导致创建多个实例，不符合单例模式的设计。</p><h3 id="五种单例模式对比"><a href="#五种单例模式对比" class="headerlink" title="五种单例模式对比"></a><strong>五种单例模式对比</strong></h3><table><thead><tr><th><strong>方式</strong></th><th><strong>线程安全性</strong></th><th><strong>是否懒加载</strong></th><th><strong>实现难度</strong></th><th><strong>性能</strong></th></tr></thead><tbody><tr><td><strong>饿汉式</strong></td><td>✅ 线程安全</td><td>❌ 不是懒加载</td><td>⭐⭐ 易实现</td><td>⭐⭐⭐ 访问快</td></tr><tr><td><strong>懒汉式（非线程安全）</strong></td><td>❌ 线程不安全</td><td>✅ 懒加载</td><td>⭐⭐ 易实现</td><td>⭐⭐⭐ 访问快</td></tr><tr><td><strong>懒汉式（DCL双重检查锁）</strong></td><td>✅ 线程安全</td><td>✅ 懒加载</td><td>⭐⭐⭐ 代码复杂</td><td>⭐ 访问需加锁</td></tr><tr><td><strong>静态内部类</strong></td><td>✅ 线程安全</td><td>✅ 懒加载</td><td>⭐⭐ 易实现</td><td>⭐⭐⭐ 访问快</td></tr></tbody></table><hr><h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><p>约瑟夫环问题的核心思想是：<strong>一群人围成一圈，从某个起点开始依次报数，报到特定数字的人出局，直到只剩下最后一个人为止</strong>。  </p><h3 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a><strong>求解思路</strong></h3><p>这个问题可以用 <strong>递推公式</strong> 来表示：</p><p><em>f(n,k)&#x3D;(f(n−1,k)+k-1)%n+1</em></p><p>其中：</p><ul><li><code>f(n, k)</code> 代表 <strong>n 个人围成一圈</strong>，每次报数到 <code>k</code> 的人出局，最终<strong>留下的人的编号</strong>。</li><li>递归的<strong>终止条件</strong>是当 <code>n = 1</code> 时，唯一的那个人自然是编号 1（即 <code>f(1, k) = 1</code>)。</li><li>递推公式的含义是：在 <strong>n - 1 个人的情况下找到安全位置</strong>，然后<strong>映射到当前 n 个人的编号</strong>。</li></ul><hr><h3 id="换个更直观的理解"><a href="#换个更直观的理解" class="headerlink" title="换个更直观的理解"></a><strong>换个更直观的理解</strong></h3><p>想象有 <strong>n 个人站成一个圈</strong>，他们按顺序报数，每报到 <strong>k</strong> 的人出局。我们希望知道最终谁能存活下来。</p><ul><li><strong>从 1 个人开始</strong>（显然他是幸存者）。</li><li><strong>增加到 2 个人</strong>，谁存活取决于前一个人的位置加上 <code>k</code>，再取模计算位置。</li><li><strong>每次增加 1 个人</strong>，都要重新计算安全位置。</li></ul><p>这就像我们 <strong>不断从后往前推导，找到一个人站在“安全位置”</strong>。最终，我们得到了 <strong>最后留下的那个人的编号</strong>。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JosephusProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">josephus</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果只有⼀个⼈，则返回 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (josephus(n - <span class="number">1</span>, k) + k - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后留下的人的编号是：&quot;</span> + josephus(n, k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后留下的人的编号是：<span class="number">4</span></span><br></pre></td></tr></table></figure><hr><h2 id="交替打印奇偶数"><a href="#交替打印奇偶数" class="headerlink" title="交替打印奇偶数"></a>交替打印奇偶数</h2><p><strong>问题描述：写两个线程打印 1-100，⼀个线程打印奇数，⼀个线程打印偶数。</strong></p><p>这道题的实现⽅式还是挺多的，线程的等待&#x2F;通知机制 <strong>（ wait() 和 notify() ）</strong> 、信号<code>Semaphore</code> 等都可以实现。</p><h3 id="synchronized-wait-notify-实现"><a href="#synchronized-wait-notify-实现" class="headerlink" title="synchronized+wait&#x2F;notify 实现"></a>synchronized+wait&#x2F;notify 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * synchronized+wait/notify 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParityPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="comment">// 从1开始计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParityPrinter</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> isOdd)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (isOdd == (count % <span class="number">2</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + count++);</span><br><span class="line">                    lock.notify();  <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有正确的线程才能打印，错误的线程会 lock.wait() 进入等待状态</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddAndEven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印 1-100</span></span><br><span class="line">        <span class="type">ParityPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParityPrinter</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 创建打印奇数和偶数的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printOdd, <span class="string">&quot;Odd&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printEven, <span class="string">&quot;Even&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Odd : <span class="number">1</span></span><br><span class="line">Even : <span class="number">2</span></span><br><span class="line">Odd : <span class="number">3</span></span><br><span class="line">Even : <span class="number">4</span></span><br><span class="line">Odd : <span class="number">5</span></span><br><span class="line">...</span><br><span class="line">Odd : <span class="number">95</span></span><br><span class="line">Even : <span class="number">96</span></span><br><span class="line">Odd : <span class="number">97</span></span><br><span class="line">Even : <span class="number">98</span></span><br><span class="line">Odd : <span class="number">99</span></span><br><span class="line">Even : <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="Semaphore-实现"><a href="#Semaphore-实现" class="headerlink" title="Semaphore 实现"></a>Semaphore 实现</h3><p>如果想要把上⾯的代码修改为基于 <code>Semaphore</code> 实现也挺简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Semaphore 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParityPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreOdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreEven</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParityPrinter</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreOdd, semaphoreEven);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreEven, semaphoreOdd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Semaphore cur, Semaphore next)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 信号量 -1 </span></span><br><span class="line">                cur.acquire();</span><br><span class="line">                <span class="comment">// 防止 max 取值导致多打印或者死锁</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">                    next.release();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + count++);</span><br><span class="line">                <span class="comment">// 信号量 +1 </span></span><br><span class="line">                next.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddAndEven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印 1-100</span></span><br><span class="line">        <span class="type">ParityPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParityPrinter</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 创建打印奇数和偶数的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printOdd, <span class="string">&quot;Odd&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printEven, <span class="string">&quot;Even&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们这⾥使⽤两个信号 <code>semaphoreOdd</code> 和 <code>semaphoreEven</code> 来确保两个线程交替执⾏。<code>semaphoreOdd</code> 信号先获取，也就是先执⾏奇数输出。⼀个线程执⾏完之后，就释放下⼀个信号。</p><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Odd : <span class="number">1</span></span><br><span class="line">Even : <span class="number">2</span></span><br><span class="line">Odd : <span class="number">3</span></span><br><span class="line">Even : <span class="number">4</span></span><br><span class="line">Odd : <span class="number">5</span></span><br><span class="line">Even : <span class="number">6</span></span><br><span class="line">Odd : <span class="number">7</span></span><br><span class="line">Even : <span class="number">8</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Odd : <span class="number">95</span></span><br><span class="line">Even : <span class="number">96</span></span><br><span class="line">Odd : <span class="number">97</span></span><br><span class="line">Even : <span class="number">98</span></span><br><span class="line">Odd : <span class="number">99</span></span><br><span class="line">Even : <span class="number">100</span></span><br></pre></td></tr></table></figure><hr><h2 id="交替打印-ABC"><a href="#交替打印-ABC" class="headerlink" title="交替打印 ABC"></a>交替打印 ABC</h2><p><strong>问题描述：写三个线程打印 “ABC”，⼀个线程打印 A，⼀个线程打印 B，⼀个线程打印 C，⼀共打印 10 轮。</strong></p><p>这个问题其实和上⾯的交替打印奇偶数是⼀样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ABCPrinter</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerA</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreA, semaphoreB, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerB</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreB, semaphoreC, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerC</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreC, semaphoreA, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Semaphore cur, Semaphore next, String x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cur.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + x);</span><br><span class="line">                next.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ABCPrinter</span> <span class="variable">abcPrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ABCPrinter</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(abcPrinter::printerA, <span class="string">&quot;Thread 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(abcPrinter::printerB, <span class="string">&quot;Thread 2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(abcPrinter::printerC, <span class="string">&quot;Thread 3&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> : A</span><br><span class="line">Thread <span class="number">2</span> : B</span><br><span class="line">Thread <span class="number">3</span> : C</span><br><span class="line">Thread <span class="number">1</span> : A</span><br><span class="line">Thread <span class="number">2</span> : B</span><br><span class="line">Thread <span class="number">3</span> : C</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Thread <span class="number">1</span> : A</span><br><span class="line">Thread <span class="number">2</span> : B</span><br><span class="line">Thread <span class="number">3</span> : C</span><br></pre></td></tr></table></figure><hr><h2 id="三个线程交替打印-1-到-99"><a href="#三个线程交替打印-1-到-99" class="headerlink" title="三个线程交替打印 1 到 99"></a>三个线程交替打印 1 到 99</h2><p><strong>问题描述：写三个线程 A、B、C，A 线程打印 3n+1，B 线程打印 3n+2，C 线程打印 3n+3。</strong></p><p>这道题和三个线程交替打印 ABC 这道题有挺多相似之处，唯一不同之处就是对count计数的调整，这次我们选用线程安全的原子类<code>AtomicInteger</code> 来作替代。话不多说上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="comment">// 用线程安全的原子类来替代count变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphoreA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphoreB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphoreC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumPrinter</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerA</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreA, semaphoreB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerB</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreB, semaphoreC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerC</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreC, semaphoreA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Semaphore cur, Semaphore next)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cur.acquire();</span><br><span class="line">                <span class="comment">// 取值并逐渐递增</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> count.getAndIncrement();</span><br><span class="line">                <span class="keyword">if</span> (value &gt; max) &#123;  <span class="comment">// 超出范围，释放信号量防止死锁</span></span><br><span class="line">                    next.release();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">                next.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneTo99</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NumPrinter</span> <span class="variable">numPrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumPrinter</span>(<span class="number">99</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(numPrinter::printerA,<span class="string">&quot;Thread A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(numPrinter::printerB,<span class="string">&quot;Thread B&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(numPrinter::printerC,<span class="string">&quot;Thread C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread A : <span class="number">1</span></span><br><span class="line">Thread B : <span class="number">2</span></span><br><span class="line">Thread C : <span class="number">3</span></span><br><span class="line">Thread A : <span class="number">4</span></span><br><span class="line">Thread B : <span class="number">5</span></span><br><span class="line">Thread C : <span class="number">6</span></span><br><span class="line">Thread A : <span class="number">7</span></span><br><span class="line">Thread B : <span class="number">8</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Thread A : <span class="number">94</span></span><br><span class="line">Thread B : <span class="number">95</span></span><br><span class="line">Thread C : <span class="number">96</span></span><br><span class="line">Thread A : <span class="number">97</span></span><br><span class="line">Thread B : <span class="number">98</span></span><br><span class="line">Thread C : <span class="number">99</span></span><br></pre></td></tr></table></figure><hr><h2 id="实现⼀个线程安全的计数器"><a href="#实现⼀个线程安全的计数器" class="headerlink" title="实现⼀个线程安全的计数器"></a>实现⼀个线程安全的计数器</h2><p><strong>问题描述：实现⼀个线程安全的计数器，100 个线程，每个线程累加 100 次。</strong></p><p><code>AtomicLong</code> 通过使⽤ <strong>CAS（Compare-And-Swap）</strong> 操作，实现了⽆锁的线程安全机制，能够对⻓整型数据进⾏原⼦操作。⾼并发的场景下，乐观锁相⽐悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜⼀筹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建⼀个线程安全的计数器</span></span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">        <span class="comment">// 创建⼀个固定⼤⼩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 100 个线程，每个线程累加 100 次</span></span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    counter.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;Final Counter Value: &quot;</span> + counter.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p>虽然 <code>AtomicLong</code> 的性能已经相当优秀，但在⾼并发场景下仍存在⼀些效率问题。JDK 8 新增了⼀个原⼦性递增或者递减类 <code>LongAdder</code> ⽤来克服在⾼并发下使⽤ <code>AtomicLong</code> 的⼀些缺点。</p><p>使⽤ <code>LongAdder</code> 改造后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        <span class="comment">// 创建⼀个固定⼤⼩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 100 个线程，每个线程累加 100 次</span></span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;Final Counter Value: &quot;</span> + counter.sum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LongAdder 使⽤ <code>increment()</code> ⽅法累加，所有累加的总和通过 <code>sum()</code> ⽅法获取。</p><hr><h2 id="控制三个线程的执⾏顺序"><a href="#控制三个线程的执⾏顺序" class="headerlink" title="控制三个线程的执⾏顺序"></a>控制三个线程的执⾏顺序</h2><p><strong>问题描述：假设有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执⾏完后执⾏，T3 在 T2 执⾏完后执⾏？</strong></p><p>这道题不难，⼤部分⼈都是⽤ <code>join()</code> 或者 <code>CountDownLatch</code> 实现。话不多说上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// join();</span></span><br><span class="line">        countDownLatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countDownLatch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch1.countDown(); <span class="comment">// T1 完成后释放 latch1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 T1 完成</span></span><br><span class="line">                latch1.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;T2 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch2.countDown(); <span class="comment">// T2 完成后释放 latch2</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 T2 完成</span></span><br><span class="line">                latch2.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;T3 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T2 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T2 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T3 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T3 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动 T1 并等待其完成</span></span><br><span class="line">            t1.start();</span><br><span class="line">            t1.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// T1 完成后启动 T2 并等待其完成</span></span><br><span class="line">            t2.start();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// T2 完成后启动 T3 并等待其完成</span></span><br><span class="line">            t3.start();</span><br><span class="line">            t3.join();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五⼈赛跑裁判"><a href="#五⼈赛跑裁判" class="headerlink" title="五⼈赛跑裁判"></a>五⼈赛跑裁判</h2><p><strong>问题描述：有 5 个⼈赛跑，请你设计⼀个多线程的裁判程序给出他们赛跑的结果顺序，5 个⼈的速度随机处理。</strong></p><p>我们借助<code>线程池</code>和 <code>CountDownLatch</code> 来实现这⼀需求即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Racing</span> &#123;</span><br><span class="line">    <span class="comment">// 使⽤ AtomicInteger 确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建⼀个固定⼤⼩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(threadCount);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟随机耗时</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">sleepTime</span> <span class="operator">=</span> random.nextInt(<span class="number">401</span>) + <span class="number">100</span>; <span class="comment">// 100ms ~ 500ms</span></span><br><span class="line">                    Thread.sleep(sleepTime);</span><br><span class="line">                    <span class="comment">// 使⽤ AtomicInteger 确保线程安全</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> num.getAndIncrement();</span><br><span class="line">                    res[index] = <span class="string">&quot;运动员&quot;</span> + id + <span class="string">&quot;消耗的时间为&quot;</span> + sleepTime;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (String x : res) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运动员<span class="number">5</span>消耗的时间为<span class="number">162</span></span><br><span class="line">运动员<span class="number">2</span>消耗的时间为<span class="number">181</span></span><br><span class="line">运动员<span class="number">4</span>消耗的时间为<span class="number">266</span></span><br><span class="line">运动员<span class="number">3</span>消耗的时间为<span class="number">425</span></span><br><span class="line">运动员<span class="number">1</span>消耗的时间为<span class="number">452</span></span><br></pre></td></tr></table></figure><p>解题的核⼼是 <code>AtomicInteger</code> 和 <code>CountDownLatch</code> 类的运⽤：</p><ul><li><code>AtomicInteger</code> 是⼀个线程安全的整数类，⽀持原⼦性操作。</li><li><code>CountDownLatch</code> 是⼀个线程同步⼯具类，⽤于让主线程等待其他线程完成⼯作。在本题中，初始化计数器为线程数 5。每个线程完成任务后，调⽤<code>countDownLatch.countDown() </code>，主线程调⽤<code>countDownLatch.await()</code> 。</li></ul><p>完整的执⾏流程如下：</p><ol><li>创建⼀个固定⼤⼩的线程池和⼀个 <code>CountDownLatch</code> ，初始化为5。</li><li>提交5个线程任务到线程池，模拟每个运动员完成⽐赛的过程：<ul><li>每个线程随机等待⼀定时间 <strong>（100ms~500ms）</strong>，表示运动员⽐赛时⻓。</li><li>使⽤ <code>AtomicInteger</code> 确保线程安全，将⽐赛结果写⼊数组。</li><li>每个线程完成后，调⽤ <code>countDown()</code> 减少计数器值。</li></ul></li><li>主线程调⽤ <code>await()</code> ，等待所有线程完成。</li><li>所有线程完成后，主线程输出⽐赛结果。</li></ol><hr><h2 id="LRU缓存（升级版：带缓存过期时间）"><a href="#LRU缓存（升级版：带缓存过期时间）" class="headerlink" title="LRU缓存（升级版：带缓存过期时间）"></a>LRU缓存（升级版：带缓存过期时间）</h2><p><a href="https://blog.csdn.net/weixin_74199893/article/details/142991194">👉详情见该博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速通买卖股票的最佳时机（动态规划一网打尽）</title>
      <link href="/2025/03/24/%E9%80%9F%E9%80%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2025/03/24/%E9%80%9F%E9%80%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>阅读完本篇文章，你可以在力扣顺便解决以下题目：</p><table><thead><tr><th align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机(简单)</a></th><th align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II(中等)</a></th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III(困难)</a></td><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV(困难)</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期(中等)</a></td><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费(中等)</a></td></tr></tbody></table><p><img src="https://pic1.imgdb.cn/item/67e0e6f488c538a9b5c59d3a.png" alt="在这里插入图片描述"></p><p>👊虽然在处理某些股票相关的问题时，直接使用简单的方法可能看起来更直接也更容易实现，但我希望通过采用一种更为通用的方法——比如<strong>动态规划</strong>来解决问题，即便这在开始时可能会让人觉得有些复杂或繁琐。实际上，使用如<strong>贪心算法</strong>等方法可能在解决这类问题时更加直观且效率更高。然而，我们的目标是通过动态规划这种更具普遍性的策略，帮助大家建立起解决这类问题的能力，使得在未来面对更多类似挑战时可以更加从容不迫，并且能够用<strong>最少的记忆负担应对更多的题目类型</strong>。这样做是为了长远考虑，帮助积累解决问题的通用技巧，而不是仅仅针对单一问题寻找捷径。</p><p>💪接下来，让我们探讨一下如何运用动态规划来解决这一类与股票相关的题目。一旦你掌握了通过动态规划解决一个问题的方法，之后只需要对<strong>递推公式稍作调整，并正确设置初始条件</strong>，就能够解决其他类似的问题了。这种方法的核心在于理解并应用动态规划的基本原理，从而达到举一反三的效果。</p><h1 id="121-买卖股票的最佳时机-简单"><a href="#121-买卖股票的最佳时机-简单" class="headerlink" title="121.买卖股票的最佳时机(简单)"></a>121.买卖股票的最佳时机(简单)</h1><h2 id="🐚核心思路"><a href="#🐚核心思路" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><h3 id="1）确定dp数组以及下标的含义"><a href="#1）确定dp数组以及下标的含义" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>dp[i][0] 表示第i天持有股票所得最多现金<br>dp[i][1] 表示第i天不持有股票所得最多现金</p><blockquote><p>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</p></blockquote><h3 id="2）确定递推公式"><a href="#2）确定递推公式" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><p>如果在第 i 天持有股票 (<code>dp[i][0]</code>)，那么有两种可能性：</p><ol><li>我们在第 i-1 天就已经持有股票，并且在第 i 天没有进行任何操作，这意味着我们继续持有前一天的股票状态：<code>dp[i - 1][0]</code>。</li><li>我们在第 i 天买入股票，此时我们手中的现金减少了 <code>prices[i]</code>，因此现金变为 <code>-prices[i]</code>。</li></ol><p>为了最大化手中的现金，我们需要在这两种情况中选择较大的值。因此，我们有：<br><code>dp[i][0] = max(dp[i - 1][0], -prices[i]);</code></p><p>如果在第 i 天不持有股票 (<code>dp[i][1]</code>)，同样有两种可能性：</p><ol><li>我们在第 i-1 天就不持有股票，并且在第 i 天没有进行任何操作，这意味着我们继续保持不持有股票的状态：<code>dp[i - 1][1]</code>。</li><li>我们在第 i 天卖出股票，这时我们增加的现金为股票的价格 <code>prices[i]</code> 加上我们在第 i-1 天持有股票时的最大现金 <code>dp[i - 1][0]</code>。</li></ol><p>同样地，为了使手中的现金最大化，我们需要在这两种情况中选择较大的值。因此，我们有：<br><code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</code></p><p>这样，我们就定义了每一天的状态转移规则，以确保在每个决策点上都能做出最佳的选择。</p><h3 id="3）初始化"><a href="#3）初始化" class="headerlink" title="3）初始化"></a>3）初始化</h3><p>根据递推公式 <code>dp[i][0] = max(dp[i - 1][0], -prices[i])</code> 和 <code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])</code>，我们知道整个动态规划过程是从第一天的状态开始逐步推进的。</p><p>对于 <code>dp[0][0]</code>，它代表在第0天持有股票的情况。由于这是第一天，没有前一天的状态可以参考，所以唯一的情况就是在第0天买入股票。这意味着我们花费了 <code>prices[0]</code> 购买了股票，因此 <code>dp[0][0]</code> 的值应该是 <code>-prices[0]</code>（因为我们支付了这个金额来购买股票）。</p><p>而对于 <code>dp[0][1]</code>，它表示在第0天不持有股票的情况。在这种情况下，我们没有买入股票，所以我们的现金仍然是初始值，通常设定为 <code>0</code>。</p><p>因此，我们可以这样初始化：</p><ul><li><code>dp[0][0] = -prices[0]</code> （因为我们在第0天买入了股票）</li><li><code>dp[0][1] = 0</code> （因为我们没有持有股票，现金保持不变）</li></ul><p>这样我们就明确了初始状态，可以基于此进行后续的动态规划计算，从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，所以我们从前向后遍历即可。</p><h2 id="🌴代码实现"><a href="#🌴代码实现" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码"><a href="#JAVA代码" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// [0][0]持有   [0][1]不持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 这里只能有一次买入哦！！！</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机-II-中等"><a href="#122-买卖股票的最佳时机-II-中等" class="headerlink" title="122. 买卖股票的最佳时机 II(中等)"></a>122. 买卖股票的最佳时机 II(中等)</h1><h2 id="🐚核心思路-1"><a href="#🐚核心思路-1" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>在这道题中，股票可以买卖多次了！这也是和<strong>121. 买卖股票的最佳时机</strong>的唯一区别。重点在于递推公式的不同。</p><p>在回顾一下dp数组的含义：</p><p><strong>dp[i][0] 表示第i天持有股票所得现金。<br>dp[i][1] 表示第i天不持有股票所得最多现金。</strong></p><h3 id="递推公式："><a href="#递推公式：" class="headerlink" title="递推公式："></a>递推公式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br></pre></td></tr></table></figure><p>大家可以发现本题和<strong>121. 买卖股票的最佳时机</strong> 的代码几乎一样，唯一的区别在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br></pre></td></tr></table></figure><p>这正是因为本题的股票可以买卖多次！ 所以买入股票的时候，可能会有之前买卖的利润即：<code>dp[i - 1][1]</code>，所以<code>dp[i - 1][1] - prices[i]</code>。</p><h2 id="🌴代码实现-1"><a href="#🌴代码实现-1" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-1"><a href="#JAVA代码-1" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机-III-困难"><a href="#123-买卖股票的最佳时机-III-困难" class="headerlink" title="123. 买卖股票的最佳时机 III(困难)"></a>123. 买卖股票的最佳时机 III(困难)</h1><h2 id="🐚核心思路-2"><a href="#🐚核心思路-2" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>在这道题中，股票最多只能完成两笔交易。这意味着可以买卖一次，可以买卖两次，也可以不买卖。相比较于上两个题稍微复杂一点，不过就是多了几种讨论情况而已。</p><h3 id="1）确定dp数组以及下标的含义-1"><a href="#1）确定dp数组以及下标的含义-1" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>一天一共就有4个状态：</p><ul><li>第一次买入</li><li>第一次卖出</li><li>第二次买入</li><li>第二次卖出</li></ul><h3 id="2）确定递推公式-1"><a href="#2）确定递推公式-1" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">dp[i][<span class="number">3</span>] = max(dp[i-<span class="number">1</span>][<span class="number">3</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h3 id="3）初始化-1"><a href="#3）初始化-1" class="headerlink" title="3）初始化"></a>3）初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>; </span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-2"><a href="#🌴代码实现-2" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-2"><a href="#JAVA代码-2" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// [0][0] 第一次买入 [0][2] 第二次买入</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="188-买卖股票的最佳时机-IV-困难"><a href="#188-买卖股票的最佳时机-IV-困难" class="headerlink" title="188. 买卖股票的最佳时机 IV(困难)"></a>188. 买卖股票的最佳时机 IV(困难)</h1><h2 id="🐚核心思路-3"><a href="#🐚核心思路-3" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>在这道题中，股票最多可以完成 k 笔交易。相对于上一道动态规划：<strong>123.买卖股票的最佳时机III</strong> ，本题需要通过前两次的交易，来类比前k次的交易。其实也很简单，对着上一题找规律就行。<strong>但是有一点需要注意，我们要把[0][1]作为第一次买入了，为的就是处理第一次买入时的情况。</strong><br><img src="https://pic1.imgdb.cn/item/67e0e75f88c538a9b5c59d4d.png" alt="在这里插入图片描述"></p><p>如果按照规律我们是不是要这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k*<span class="number">2</span> - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">        dp[i][j] = Math.<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">        dp[i][j + <span class="number">1</span>] = Math.<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这肯定就矛盾了！我们最起码要从dp[0][0]开始初始化！</p><p><img src="https://pic1.imgdb.cn/item/67e0e78988c538a9b5c59d5b.png" alt="在这里插入图片描述"></p><h3 id="1）确定dp数组以及下标的含义-2"><a href="#1）确定dp数组以及下标的含义-2" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</p><p>j的状态表示为：</p><p>0 表示不操作<br>1 第一次买入<br>2 第一次卖出<br>3 第二次买入<br>4 第二次卖出<br>…..<br>除了0以外，<strong>偶数就是卖出，奇数就是买入</strong>。</p><h3 id="2）确定递推公式-2"><a href="#2）确定递推公式-2" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">    dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题和动态规划：<strong>123.买卖股票的最佳时机III</strong> 最大的区别就是这里<strong>要类比</strong> <code>j</code> 为奇数是买，偶数是卖的状态。</p><h3 id="3）初始化-2"><a href="#3）初始化-2" class="headerlink" title="3）初始化"></a>3）初始化</h3><p><code>dp[0][j]</code>当j为奇数的时候都初始化为 <code>-prices[0]</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-3"><a href="#🌴代码实现-3" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-3"><a href="#JAVA代码-3" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k*<span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个地方必须要从[0][1]开始买入算起，不能从[0][0]算第一次买入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k*<span class="number">2</span> - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是[0][0]算第一次买入，那下面这个式子的 j 不就成负数了</span></span><br><span class="line">                dp[i][j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][k*<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="309-买卖股票的最佳时机含冷冻期-中等"><a href="#309-买卖股票的最佳时机含冷冻期-中等" class="headerlink" title="309. 买卖股票的最佳时机含冷冻期(中等)"></a>309. 买卖股票的最佳时机含冷冻期(中等)</h1><p>在这道题中，尽可能地完成更多的交易（多次买卖一支股票），但有冷冻期，冷冻期为1天。相对于动态规划：<strong>122.买卖股票的最佳时机II</strong> ，本题加上了一个冷冻期。</p><h2 id="🐚核心思路-4"><a href="#🐚核心思路-4" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><h3 id="1）确定dp数组以及下标的含义-3"><a href="#1）确定dp数组以及下标的含义-3" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>本题则需要第三个状态：不持有股票（冷冻期）的最多现金。</p><p>dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。</p><p>j的状态为：</p><p>0：持有股票后的最多现金<br>1：不持有股票（能购买）的最多现金<br>2：不持有股票（冷冻期）的最多现金</p><ul><li>dp[i][0] 表示第 i 天结束时持有股票的最大利润。</li><li>dp[i][1] 表示第 i 天结束时不持有股票并且不在冷冻期的最大利润。</li><li>dp[i][2] 表示第 i 天结束时不持有股票并且处于冷冻期的最大利润（即前一日刚卖出股票）。</li></ul><h3 id="2）确定递推公式-3"><a href="#2）确定递推公式-3" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br></pre></td></tr></table></figure><h3 id="3）初始化-3"><a href="#3）初始化-3" class="headerlink" title="3）初始化"></a>3）初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-4"><a href="#🌴代码实现-4" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-4"><a href="#JAVA代码-4" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// [0][0]持有  [0][1]不持有  [0][2]冷冻</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);<span class="comment">// 保持持有或买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);<span class="comment">// 保持不持有或冷冻期结束</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i];<span class="comment">// 卖出后进入冷冻期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">2</span>],dp[prices.length-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>)); <span class="comment">// [持有股票, 不持有股票, 冷冻期]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 持有股票的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不持有股票的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 第一天不可能处于冷冻期</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 保持持有或买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 保持不持有或冷冻期结束</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]; <span class="comment">// 卖出后进入冷冻期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果是不持有股票并且不在冷冻期的最大利润</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="714-买卖股票的最佳时机含手续费-中等"><a href="#714-买卖股票的最佳时机含手续费-中等" class="headerlink" title="714. 买卖股票的最佳时机含手续费(中等)"></a>714. 买卖股票的最佳时机含手续费(中等)</h1><h2 id="🐚核心思路-5"><a href="#🐚核心思路-5" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>这个题没什么难的，相比于<strong>122. 买卖股票的最佳时机II</strong> 无非就是多了一步最后计算手续费的步骤而已。</p><p>递推公式这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-5"><a href="#🌴代码实现-5" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-5"><a href="#JAVA代码-5" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL相关面试题</title>
      <link href="/2025/03/24/MySQL%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/24/MySQL%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h3 id="面试官：-数据库的三大范式"><a href="#面试官：-数据库的三大范式" class="headerlink" title="面试官： 数据库的三大范式"></a><strong>面试官：</strong> 数据库的三大范式</h3><p><strong>候选人：</strong></p><ol><li>每个列都不可拆分</li><li>在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分</li><li>在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键列</li></ol><h3 id="面试官：-说一下外键约束"><a href="#面试官：-说一下外键约束" class="headerlink" title="面试官： 说一下外键约束"></a><strong>面试官：</strong> 说一下外键约束</h3><p><strong>候选人：</strong></p><p>外键约束的作用是维护表与表之间的关系，确保数据的完整性和一致性。让我们举一个简单的例子：</p><p>假设你有两个表，一个是学生表，另一个是课程表，这两个表之间有一个关系，即一个学生可以选修多门课程，而一门课程也可以被多个学生选修。在这种情况下，我们可以在学生表中定义一个指向课程表的外键，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> students (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  course_id <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (course_id) <span class="keyword">REFERENCES</span> courses(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里，<code>students</code>表中的<code>course_id</code>字段是一个外键，它指向<code>courses</code>表中的<code>id</code>字段。这个外键约束确保了每个学生所选的课程在<code>courses</code>表中都存在，从而维护了数据的完整性和一致性。</p><p>如果没有定义外键约束，那么就有可能出现学生选了不存在的课程或者删除了一个课程而忘记从学生表中删除选修该课程的学生的情况，这会破坏数据的<strong>完整性和一致性</strong>。因此，使用外键约束可以帮助我们避免这些问题。</p><h3 id="面试官：-说一下binlog"><a href="#面试官：-说一下binlog" class="headerlink" title="面试官： 说一下binlog"></a><strong>面试官：</strong> 说一下binlog</h3><p><strong>候选人：</strong></p><p>binlog日志是MySQL数据库的一种日志记录机制，用于记录数据库的修改操作（如插入、更新、删除等），以便在需要时进行数据恢复、数据复制和数据同步等操作。</p><p>binlog日志的实现以下功能：</p><ul><li><strong>数据恢复</strong>：binlog日志可以用于回滚到之前的某个时间点，从而恢复数据。</li><li><strong>数据复制</strong>：binlog日志可以用于在主从数据库之间复制数据，从而实现数据的高可用和负载均衡等功能。</li></ul><p>MySQL的binlog日志有三种格式，分别是Statement格式、Row格式和Mixed格式。它们之间的区别如下：</p><ul><li><strong>STATEMENT</strong>：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现；</li><li><strong>ROW</strong>：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大；</li><li><strong>MIXED</strong>：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul><h3 id="面试官：-MyISAM和InnoDB区别"><a href="#面试官：-MyISAM和InnoDB区别" class="headerlink" title="面试官： MyISAM和InnoDB区别"></a><strong>面试官：</strong> MyISAM和InnoDB区别</h3><p><strong>候选人：</strong></p><ol><li><strong>是否⽀持⾏级锁</strong> : MyISAM 只有表级锁(table-level locking)，⽽InnoDB ⽀持⾏级锁(rowlevel locking)和表级锁,默认为⾏级锁。</li></ol><blockquote><p>补充：<strong>行级锁和表级锁？</strong></p><p><strong>行级锁</strong>是一种细粒度的锁机制，它只锁定对特定行的访问。这意味着当一个事务正在更新或删除一个表中的某一行时，其他事务不能同时更新或删除这一行，但它们仍然可以读取这一行或者修改表中的其他行。</p><ul><li>这种锁的优点是它提供了更好的并发性能，因为多个事务可以在同一时间内操作表的不同部分。</li><li>缺点是它可能会导致更高的开销，因为系统需要跟踪哪些行已经被锁定。</li></ul><p><strong>表级锁</strong>是一种粗粒度的锁机制，它锁定整个表。当一个事务对某个表进行读写操作时，它可以阻止其他事务对该表的任何访问，直到锁被释放。</p><ul><li>这种锁的优点是实现简单，管理成本相对较低。</li><li>缺点是由于锁住了整个表，所以并发能力较差，尤其是在需要频繁并发读写的情况下。</li></ul></blockquote><ol start="2"><li><p><strong>是否⽀持事务和崩溃后的安全恢复：</strong> <strong>MyISAM</strong> 强调的是性能，每次查询具有原⼦性,其执⾏速度⽐InnoDB类型更快，但是不提供事务⽀持。但是<strong>InnoDB</strong> 提供事务⽀持事务，外部键等⾼级数据库功能。 具有提交事务(commit)、回滚(rollback)和崩溃修复能⼒。</p></li><li><p><strong>是否⽀持外键：</strong> MyISAM不⽀持，⽽InnoDB⽀持。</p></li><li><p><strong>是否⽀持MVCC</strong> ：仅 InnoDB ⽀持。应对⾼并发事务, MVCC⽐单纯的加锁更⾼效；MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下⼯作；MVCC可以使⽤ 乐观锁 和 悲观锁来实现。</p></li></ol><blockquote><p>《MySQL高性能》上⾯有⼀句话这样写到：</p><p>不要轻易相信“MyISAM⽐InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是⽤到了聚簇索引，或者需要访问的数据都可以放⼊内存的应⽤。</p></blockquote><blockquote><p>补充：<strong>乐观锁与悲观锁？</strong></p><p>悲观锁 ：基于假设：当事务要对某个数据进⾏操作时，认为很可能会发⽣冲突。因此，<strong>在事务开始时就对数据进⾏锁定</strong>，阻⽌其他事务同时对其进⾏修改，直到当前事务完成。这种⽅式虽然能够保证数据的⼀致性和准确性，但由于锁的存在，可能会导致其他事务等待，增加了系统开销。</p><p>乐观锁 ：基于另⼀种假设：认为事务之间发⽣冲突的概率较低，因此<strong>在读取数据时不⽴即加锁</strong>，⽽是允许多个事务同时读取数据。当事务尝试提交更改时，会检查在此期间是否有其他事务修改过相同的数据。如果有冲突，则当前事务失败，可能需要回滚并重新开始。<strong>乐观锁通常通过版本号或时间戳来检测数据是否已被修改。</strong></p></blockquote><h3 id="面试官：-MySQL中，如何定位慢查询-（高频）"><a href="#面试官：-MySQL中，如何定位慢查询-（高频）" class="headerlink" title="面试官： MySQL中，如何定位慢查询?（高频）"></a><strong>面试官：</strong> MySQL中，如何定位慢查询?<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>嗯~，我们当时做压测的时候有的接口非常的慢，接口的响应时间超过了2秒以上，因为我们当时的系统部署了运维的监控系统<strong>Skywalking</strong> ，在展示的报表中可以看到是哪一个接口比较慢，并且可以分析这个接口哪部分比较慢，这里可以看到SQL的具体的执行时间，所以可以定位是哪个sql出了问题。</p><p>如果，项目中没有这种运维的监控系统，其实在MySQL中也提供了<strong>慢日志查询</strong>的功能，可以在MySQL的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文件中，我记得上一个项目配置的是2秒，只要SQL执行的时间超过了2秒就会记录到日志文件中，我们就可以在日志文件找到执行比较慢的SQL了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  启用慢查询日志</span></span><br><span class="line">slow_query_log = 1 </span><br><span class="line"><span class="comment"># 定义慢查询的时间阈值，默认为10秒</span></span><br><span class="line">long_query_time = 2</span><br></pre></td></tr></table></figure><h3 id="面试官：-那这个SQL语句执行很慢-如何分析呢？（高频）"><a href="#面试官：-那这个SQL语句执行很慢-如何分析呢？（高频）" class="headerlink" title="面试官： 那这个SQL语句执行很慢, 如何分析呢？（高频）"></a><strong>面试官：</strong> 那这个SQL语句执行很慢, 如何分析呢？<code>（高频）</code></h3><p><strong>候选人：<strong>如果一条sql执行很慢的话，我们通常会使用mysql自动的</strong>执行计划explain</strong>来去查看这条sql的执行情况。</p><ul><li>比如在这里面可以通过 <strong>key(实际使用的索引)</strong> 和 <strong>key_len(使用的索引长度)</strong> 检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况。</li><li>第二个，可以通过<strong>type</strong>字段查看sql是否有进一步的优化空间，是否存在全索引扫描(INDEX)或全盘扫描(ALL)。</li><li>第三个可以通过<strong>extra</strong>建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。</li></ul><p><code>SQL案例：</code></p><p>假设我们有一个数据库表 <code>employees</code>，结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    emp_no <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    birth_date <span class="type">DATE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">14</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    gender ENUM(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    hire_date <span class="type">DATE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在我们想分析下面这个查询的执行计划，我们可以使用 <code>EXPLAIN</code> 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">AND</span> last_name <span class="operator">=</span> <span class="string">&#x27;Doe&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行这条命令后，会得到一个结果集：</p><p><img src="https://pic1.imgdb.cn/item/67e15ce50ba3d5a1d7e2a27d.png" alt="image-20250218230537025"></p><p>从这个例子中可以看出，因为 <code>first_name</code> 和 <code>last_name</code> 没有索引，所以MySQL需要对整个表进行全表扫描来查找符合条件的记录。这在数据量大时会非常低效。</p><h3 id="面试官：-一条SQL语句执行得很慢的原因有哪些？"><a href="#面试官：-一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="面试官： 一条SQL语句执行得很慢的原因有哪些？"></a><strong>面试官：</strong> 一条SQL语句执行得很慢的原因有哪些？</h3><p><strong>候选人：</strong> 分以下两种情况来讨论。</p><p>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</p><p>2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</p><h4 id="一、针对偶尔很慢的情况"><a href="#一、针对偶尔很慢的情况" class="headerlink" title="一、针对偶尔很慢的情况"></a>一、针对偶尔很慢的情况</h4><p>一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条SQL语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？</p><ol><li><p><strong>数据库在刷新脏页（flush）我也无奈啊</strong></p><p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p><blockquote><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p></blockquote><p><strong>刷脏页有下面2种场景：</strong></p><ul><li><strong>redo log写满了：</strong> redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，<strong>只能暂停其他操作</strong>，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</li><li><strong>内存不够用了：</strong> 如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷新脏页。</li></ul></li><li><p><strong>拿不到锁我能怎么办</strong>。</p><p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者表没有加锁，但要使用到的某一行被加锁了，这个时候，我也没办法啊。</p><p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态。</p></li></ol><h4 id="二、针对一直都这么慢的情况"><a href="#二、针对一直都这么慢的情况" class="headerlink" title="二、针对一直都这么慢的情况"></a>二、针对一直都这么慢的情况</h4><p>如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 SQL 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。</p><p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><ol><li><p><strong>没用到索引</strong></p><p><strong>（1）、字段没有索引</strong></p><p>刚好 c 字段上没有索引，只能走全表扫描了，体验不会索引带来的乐趣了，所以，这会导致这条查询语句很慢。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">100</span> <span class="operator">&lt;</span>c <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p><strong>（2）、字段有索引，但却没有用索引</strong></p><p>好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>但是这样子在查询的时候会用索引查询吗？</p><p>答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种<strong>字段上有索引，但由于自己的疏忽，导致系统没有使用索引</strong>的情况了。</p><p>正确的查询应该如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">1000</span> <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1&#x3D;1000 自动转换为 c &#x3D; 1000+1。</p><p>不好意思，确实不会帮你，所以，你要注意了。</p><p><strong>（3）、函数操作导致没有用上索引</strong></p><p>如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> pow(c,<span class="number">2</span>) <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>这里只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。</p></li><li><p><strong>数据库自己选错索引了</strong></p><p>我们在进行查询操作的时候，例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">100</span> <span class="operator">&lt;</span> c <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。</p><p>也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p><p>所以就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p><blockquote><p><strong>为什么会这样呢？</strong></p><p>其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I&#x2F;O操作的次数越少。</p><p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走<strong>两次索引</strong>。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，<strong>走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引</strong>。</p></blockquote><blockquote><p><strong>系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p><p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果<strong>预测</strong>到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p><p>那么问题来了，<strong>系统是怎么预测判断的呢？</strong></p><p>系统是通过<strong>索引的区分度</strong>来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为<strong>基数</strong>，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 &lt; c and c &lt; 10000 这个条件的行数越少。</p><p>所以呢，一个索引的基数越大，意味着走索引查询越有优势。</p></blockquote><blockquote><p><strong>那么问题来了，怎么知道这个索引的基数呢？</strong></p><p>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p><p><strong>重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后系统就不走 c 索引了，直接走全部扫描了</strong>。</p></blockquote></li></ol><p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p><p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> c <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>我们也可以通过:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze <span class="keyword">table</span> t;</span><br></pre></td></tr></table></figure><p>来重新统计分析。</p><p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引</strong>，这也可能是 SQL 执行的很慢的一个原因。</p><p>​</p><h3 id="面试官：-MySQL中-SQL-查询和更新语句的执行流程？"><a href="#面试官：-MySQL中-SQL-查询和更新语句的执行流程？" class="headerlink" title="面试官： MySQL中 SQL 查询和更新语句的执行流程？"></a><strong>面试官：</strong> MySQL中 SQL 查询和更新语句的执行流程？</h3><p><strong>候选人：</strong></p><h4 id="一、-MySQL-基础架构分析"><a href="#一、-MySQL-基础架构分析" class="headerlink" title="一、 MySQL 基础架构分析"></a>一、 MySQL 基础架构分析</h4><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p><ul><li><p><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p></li><li><p><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，<strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做⼀次缓存操作，失效后还要销毁。</strong>）</p></li><li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p></li><li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p></li><li><p><strong>执行器：</strong> 执行具体的SQL语句之前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用存储引擎的接口，返回接口执行的结果。</p></li></ul><p><img src="https://pic1.imgdb.cn/item/67e15d2c0ba3d5a1d7e2a28f.png" alt="image-20250219223554794"></p><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</li><li><strong>存储引擎</strong>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自带的redo log日志模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</strong></li></ul><h4 id="二、语句分析"><a href="#二、语句分析" class="headerlink" title="二、语句分析"></a>二、语句分析</h4><ol><li><p><strong>查询语句（SELECT）</strong></p><p>我们先分析下查询语句，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ul><li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，如果有直接返回，如果没有，执行下一步。</li><li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li><li>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</li><li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用存储引擎接口，返回引擎的执行结果。</li></ul></li><li><p><strong>更新语句（UPDATE、INSERT、DELETE）</strong></p><p>接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure><p>其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p><ul><li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li><li>然后拿到查询的语句，把 age 改为 19，然后调用存储引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 <strong>prepare（预提交）</strong> 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用存储引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ul><blockquote><p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于redo log没有记录，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了<strong>数据的一致性</strong>。</p><p>那么问题来了，有没有一个极端的情况呢？假设 <strong>redo log 处于预提交状态，binlog 也已经写完了</strong>，这个时候发生了异常重启会怎么样呢？这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题。</p></blockquote></li></ol><h3 id="面试官：-IP地址如何在数据库里存储？"><a href="#面试官：-IP地址如何在数据库里存储？" class="headerlink" title="面试官： IP地址如何在数据库里存储？"></a><strong>面试官：</strong> IP地址如何在数据库里存储？</h3><p><strong>候选人：</strong> IPv4 地址是一个 32 位的二进制数，通常以点分十进制表示法呈现，例如 <code>192.168.1.1</code>。</p><p>1.<strong>字符串类型的存储方式</strong>：直接将 IP 地址作为字符串存储在数据库中，比如可以用 <code>VARCHAR(15)</code>来存储。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个表，使用VARCHAR类型存储IPv4地址</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> ip_records (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    ip_address <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> ip_records (ip_address) <span class="keyword">VALUES</span> (<span class="string">&#x27;192.168.1.1&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>优点</strong>：直观易懂，方便直接进行数据的插入、查询和显示，不需要进行额外的转换操作。</p></li><li><p><strong>缺点</strong>：占用存储空间较大，字符串比较操作的性能相对较低，不利于进行范围查询。</p></li></ul><p>2.<strong>整数类型的存储方式：</strong> 将 IPv4 地址转换为 32 位无符号整数进行存储，常用的数据类型有 <code>INT UNSIGNED</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个表，使用INT UNSIGNED类型存储IPv4地址</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> ip_records (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    ip_address <span class="type">INT</span> UNSIGNED</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据，需要先将IP地址转换为整数</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> ip_records (ip_address) <span class="keyword">VALUES</span> (INET_ATON(<span class="string">&#x27;192.168.1.1&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询时将整数转换回IP地址</span></span><br><span class="line"><span class="keyword">SELECT</span> INET_NTOA(ip_address) <span class="keyword">FROM</span> ip_records;</span><br></pre></td></tr></table></figure><ul><li><p><strong>优点</strong>：占用存储空间小，整数比较操作的性能较高，便于进行范围查询。</p></li><li><p><strong>缺点</strong>：需要进行额外的转换操作，不够直观，增加了开发的复杂度。</p></li></ul><h3 id="面试官：-什么是索引-（高频）"><a href="#面试官：-什么是索引-（高频）" class="headerlink" title="面试官： 什么是索引 （高频）"></a><strong>面试官：</strong> 什么是索引 <code>（高频）</code></h3><p><strong>候选人：</strong> 嗯，索引是帮助MySQL<strong>高效获取数据</strong>的数据结构，主要是用来<strong>提高数据检索的效率</strong>，<strong>降低数据库的IO成本</strong>，同时通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，也能降低了CPU的消耗。</p><h3 id="面试官：-索引的底层数据结构了解过嘛-（高频）"><a href="#面试官：-索引的底层数据结构了解过嘛-（高频）" class="headerlink" title="面试官： 索引的底层数据结构了解过嘛 ? （高频）"></a><strong>面试官：</strong> 索引的底层数据结构了解过嘛 ? <code>（高频）</code></h3><p><strong>候选人：</strong> MySQL的默认的存储引擎InnoDB采用的<strong>B+树</strong>的数据结构来存储索引，选择B+树的主要的原因是：</p><ul><li><p>第一阶数更多，路径更短，这减少了树的高度，从而缩短了从根到叶子节点的路径长度，从而提高了检索效率。</p></li><li><p>第二个磁盘读写代价B+树更低，只有叶子节点存储实际的数据记录，而所有非叶子节点保存索引键值和指针信息。</p></li><li><p>第三是B+树便于扫库和区间查询，所有的叶子节点都通过双向链表连接在一起。</p></li></ul><h3 id="面试官：-B树和B-树的区别是什么呢？（高频）"><a href="#面试官：-B树和B-树的区别是什么呢？（高频）" class="headerlink" title="面试官： B树和B+树的区别是什么呢？（高频）"></a><strong>面试官：</strong> B树和B+树的区别是什么呢？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>第一：在B树中，非叶子节点和叶子节点都会存放数据，而B+树的所有的数据都会出现在叶子节点，在查询的时候，B+树查找效率更加稳定。</p><p>第二：在进行范围查询的时候，B+树效率更高，因为B+树都在叶子节点存储，并且叶子节点是一个双向链表。</p><h3 id="面试官：-什么是聚簇索引？什么是非聚簇索引（辅助索引）"><a href="#面试官：-什么是聚簇索引？什么是非聚簇索引（辅助索引）" class="headerlink" title="面试官： 什么是聚簇索引？什么是非聚簇索引（辅助索引） ?"></a><strong>面试官：</strong> 什么是聚簇索引？什么是非聚簇索引（辅助索引） ?</h3><p><strong>候选人：</strong></p><ul><li><p>聚簇索引主要是指<strong>数据与索引放到一块</strong>，B+树的叶子节点保存了整行数据，<strong>有且只有一个</strong>，这意味着表中的数据行按照索引键的顺序存放，通常这个索引是主键索引。</p></li><li><p>非聚簇索引（辅助索引）主要是<strong>数据与索引分开存储</strong>，B+树的叶子节点保存对应的主键值，<strong>可以有多个</strong>，当用户定义额外的索引时（如唯一索引、普通索引等），这些索引就是非聚簇索引。</p></li></ul><h3 id="面试官：-知道什么是回表查询嘛"><a href="#面试官：-知道什么是回表查询嘛" class="headerlink" title="面试官： 知道什么是回表查询嘛 ?"></a><strong>面试官：</strong> 知道什么是回表查询嘛 ?</h3><p><strong>候选人：<strong>嗯，其实跟刚才介绍的聚簇索引和非聚簇索引是有关系的，回表的意思就是通过</strong>辅助索引找到对应的主键值</strong>，然后再<strong>通过主键值找到聚集索引中所对应的整行数据</strong>，这个过程就是回表。</p><p>【<strong>备注</strong>：如果面试官直接问回表，则需要先介绍聚簇索引和非聚簇索引】</p><h3 id="面试官：-MySQL的主键索引为什么用自增ID，不使用UUID？"><a href="#面试官：-MySQL的主键索引为什么用自增ID，不使用UUID？" class="headerlink" title="面试官： MySQL的主键索引为什么用自增ID，不使用UUID？"></a><strong>面试官：</strong> MySQL的主键索引为什么用自增ID，不使用UUID？</h3><p><strong>候选人：</strong></p><p>一般情况下，MySQL推荐使用自增ID，因为在MySQL的InnoDB存储引擎中，主键索引就是聚簇索引，主键索引的B+树的叶子结点<strong>按顺序存储</strong>主键值和数据，如果主键索引是自增ID，只需按顺序往后排列即可；如果是UUID，ID是随机生成的，在数据插入时会造成大量的数据移动，产生大量碎片。</p><h3 id="面试官：-知道什么叫覆盖索引嘛"><a href="#面试官：-知道什么叫覆盖索引嘛" class="headerlink" title="面试官： 知道什么叫覆盖索引嘛 ?"></a><strong>面试官：</strong> 知道什么叫覆盖索引嘛 ?</h3><p><strong>候选人：</strong></p><p>如果一个索引包含了查询语句中所需要的所有列（索引全部命中了），那么这个索引就是一个覆盖索引。如果我们使用id查询，它会直接走覆盖索引查询，一次索引扫描，直接返回数据，性能高。</p><p>如果按照<strong>辅助索引</strong>查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用<code>select *</code>，尽量在返回的列中都包含添加索引的字段。</p><h3 id="面试官：-MySQL超大分页怎么处理"><a href="#面试官：-MySQL超大分页怎么处理" class="headerlink" title="面试官： MySQL超大分页怎么处理 ?"></a><strong>面试官：</strong> MySQL超大分页怎么处理 ?</h3><p><strong>候选人：</strong> 超大分页一般都是在数据量比较大时，我们使用了limit分页查询，并且需要对数据进行排序，这个时候效率就很低。例如我们执行<code>limit 900000，10</code>，此时MySQL需排序前900010条记录，仅仅返回900000-900010的记录，其他记录要丢弃，这时查询排序的代价就非常大了。</p><p>不过我们可以采用<strong>覆盖索引和子查询</strong>来解决。先分页查询数据的<strong>id字段</strong>，确定了id之后，再用<strong>子查询</strong>来过滤，只查询这个id列表中的数据就可以了。因为查询id的时候，走的覆盖索引，所以效率可以提升很多。</p><h3 id="面试官：-什么情况下索引会失效-（高频）"><a href="#面试官：-什么情况下索引会失效-（高频）" class="headerlink" title="面试官： 什么情况下索引会失效 ?（高频）"></a><strong>面试官：</strong> 什么情况下索引会失效 ?<code>（高频）</code></h3><p><strong>候选人：</strong> 嗯，这个情况比较多，我说一些自己的经验，以前遇到过的，比如：</p><ul><li><p>索引在使用的时候没有遵循<strong>最左匹配法则</strong>。</p><blockquote><p>假设有一个复合索引 <code>idx(a, b, c)</code>，其中 <code>a</code> 是最左边的列。</p><p>查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> c <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这种情况下，虽然有复合索引 <code>idx(a, b, c)</code>，但是因为查询条件没有从索引的最左侧开始，所以无法利用这个索引。</p></blockquote></li><li><p>模糊查询，如果%号在前面也会导致索引失效。</p><blockquote><p>假设有一个索引 <code>idx(column_a)</code>。</p><p>查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column_a <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里 <code>%</code> 放在了模式字符串的开头，意味着匹配任意数量的字符后跟着 <code>abc</code>。由于 <code>%</code> 放在了开头，数据库无法利用索引来加速查询，因为任何字符都可能匹配，所以只能进行全面扫描。</p></blockquote></li><li><p>如果在添加索引的字段上进行了<strong>运算操作</strong>或者<strong>类型转换</strong>也都会导致索引失效。</p><blockquote><p>假设有一个索引 <code>idx(column_b)</code>。</p><p>查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column_b <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>这里对 <code>column_b</code> 进行了加法运算，导致索引 <code>idx(column_b)</code> 无法被使用。同样，如果对 <code>column_b</code> 进行类型转换，例如 <code>WHERE CAST(column_b AS CHAR) = &#39;5&#39;</code>，也会导致索引失效。</p></blockquote></li><li><p>如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效</p><blockquote><p>假设有一个复合索引 <code>idx(a, b, c)</code>。</p><p>查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">20</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个查询中，虽然 <code>a</code> 和 <code>c</code> 的条件可以使用索引，但是由于 <code>b</code> 使用了范围查询 <code>BETWEEN</code>，导致 <code>c</code> 的条件无法使用索引加速查询。因此，尽管 <code>a</code> 和 <code>b</code> 的条件仍然可以使用部分索引，但是 <code>c</code> 的索引效果将被忽略。</p></blockquote></li><li><p>当查询中使用了 <code>IS NOT NULL</code> 时，索引可能会失效。虽然 MySQL 支持对 <code>IS NULL</code> 使用索引，但在很多情况下，特别是 <code>IS NOT NULL</code> 的查询，数据库可能会选择全表扫描，从而导致索引失效。</p></li></ul><p>通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用<strong>explain</strong>执行计划来分析。</p><h3 id="面试官：-sql的优化的经验（慢查询优化）（高频）"><a href="#面试官：-sql的优化的经验（慢查询优化）（高频）" class="headerlink" title="面试官： sql的优化的经验（慢查询优化）（高频）"></a><strong>面试官：</strong> sql的优化的经验（慢查询优化）<code>（高频）</code></h3><p><strong>候选人：</strong> 嗯，这个在项目还是挺常见的，当然如果直说sql优化的话，我们会从这几方面考虑，比如</p><p>建表的时候、使用索引、sql语句的编写、主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表。</p><h3 id="面试官：-创建表的时候，你们是如何优化的呢？"><a href="#面试官：-创建表的时候，你们是如何优化的呢？" class="headerlink" title="面试官： 创建表的时候，你们是如何优化的呢？"></a><strong>面试官：</strong> 创建表的时候，你们是如何优化的呢？</h3><p><strong>候选人：</strong></p><ul><li>对于数值型字段，我们会根据预期的值域大小选择适当的类型，如 <code>TINYINT</code>、<code>SMALLINT</code>、<code>INT</code> 或 <code>BIGINT</code>。这样既可以节省存储空间，也能提高查询效率。</li><li>对于字符型字段，我们会在 <code>CHAR</code> 和 <code>VARCHAR</code> 之间作出区分。<code>CHAR</code> 适合固定长度的字符串，而 <code>VARCHAR</code> 更适用于长度可变的文本。对于非常大的文本字段，我们会考虑使用 <code>TEXT</code> 类型及其变体。</li></ul><h3 id="面试官：-那在使用索引的时候，是如何优化呢？（高频）"><a href="#面试官：-那在使用索引的时候，是如何优化呢？（高频）" class="headerlink" title="面试官： 那在使用索引的时候，是如何优化呢？（高频）"></a><strong>面试官：</strong> 那在使用索引的时候，是如何优化呢？<code>（高频）</code></h3><p><strong>候选人：</strong> 这个情况有很多，不过都有一个大前提，就是表中的数据要超过10万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。</p><p>还有就是，我们通常创建索引的时候都是使用复合索引来创建，一条sql的返回值，<strong>尽量使用覆盖索引</strong>，如果字段的区分度不高的话，我们也会把它放在<strong>组合索引</strong>后面的字段。</p><p>如果某一个字段的内容较长，我们会考虑使用<strong>前缀索引</strong>来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢，维护成本大。</p><h3 id="面试官：-你平时对sql语句做了哪些优化呢？（高频）"><a href="#面试官：-你平时对sql语句做了哪些优化呢？（高频）" class="headerlink" title="面试官： 你平时对sql语句做了哪些优化呢？（高频）"></a><strong>面试官：</strong> 你平时对sql语句做了哪些优化呢？<code>（高频）</code></h3><p><strong>候选人：</strong> 嗯，这个也有很多，比如SELECT语句务必指明字段名称，不要直接使用select * ，还有就是要注意SQL语句避免造成索引失效的写法；如果是聚合查询，尽量用union all代替union ，union会多一次过滤，效率比较低；如果是表关联的话，尽量使用<strong>inner join</strong> ，不要使用<strong>left join &#x2F; right join</strong>，如必须使用，一定要以小表为驱动。</p><blockquote><p>补充：<strong>union all 和 union</strong></p><p><strong><code>UNION ALL</code></strong>：它会返回查询结果的所有行，包括重复的行。因此，它的执行速度通常更快，因为它不需要进行去重处理。</p><p><strong><code>UNION</code></strong>：它会去除查询结果中的重复行，然后返回最终结果。这意味着 <code>UNION</code> 在返回结果之前会进行去重处理，这一步骤可能会消耗更多的计算资源，因此执行速度较慢。</p></blockquote><blockquote><p>补充：<strong>以小表为驱动怎么理解？</strong></p><p>数据库在执行<strong>join</strong>操作时，通常会对驱动表进行扫描，并为驱动表中的每一行查找另一表中的匹配行。如果驱动表很大，那么这种操作可能会非常耗时。</p></blockquote><h3 id="面试官：-事务的特性是什么？可以详细说一下吗？"><a href="#面试官：-事务的特性是什么？可以详细说一下吗？" class="headerlink" title="面试官： 事务的特性是什么？可以详细说一下吗？"></a><strong>面试官：</strong> 事务的特性是什么？可以详细说一下吗？</h3><p><strong>候选人：</strong> ACID，分别指的是：<strong>原子性、一致性、隔离性、持久性</strong>；我举个例子：</p><p>A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在要么都成功，要么都失败。</p><p>在转账的过程中，数据要一致，A扣除了500，B必须增加500。</p><p>在转账的过程中，隔离性体现在A向B转账，不能受其他事务干扰。</p><p>在转账的过程中，持久性体现在事务提交后，要把数据持久化（可以说是落盘操作）。</p><blockquote><p>MySQL InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li><p>原子性是通过 undo log（回滚日志） 来保证的；</p></li><li><p>持久性是通过 redo log （重做日志）来保证的；</p></li><li><p>隔离性是通过 MVCC（多版本并发控制） 和锁机制来保证的；</p></li><li><p>一致性则是通过持久性+原子性+隔离性来保证；</p></li></ul></blockquote><h3 id="面试官：-如何开启事务？"><a href="#面试官：-如何开启事务？" class="headerlink" title="面试官： 如何开启事务？"></a><strong>面试官：</strong> 如何开启事务？</h3><p><strong>候选人：</strong></p><p><img src="https://pic1.imgdb.cn/item/67e15daf0ba3d5a1d7e2a2ab.png" alt="image-20250308112116164"></p><p><img src="https://pic1.imgdb.cn/item/67e15db70ba3d5a1d7e2a2ad.png" alt="image-20250308112238874"></p><h3 id="面试官：并发事务带来哪些问题？"><a href="#面试官：并发事务带来哪些问题？" class="headerlink" title="面试官：并发事务带来哪些问题？"></a><strong>面试官</strong>：并发事务带来哪些问题？</h3><p><strong>候选人</strong>：</p><p>我们在项目开发中，多个事务并发进行是经常发生的，并发也是必然的，有可能导致一些问题：</p><ol><li><p>第一是脏读：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<strong>（一个事务读到另一个事务还未提交的数据）</strong></p></li><li><p>第二是不可重复读：比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<strong>（一个事务先后读取同一条记录，但两次读取的数据不同）</strong></p></li><li><p>第三是幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<strong>（一个事务按照条件查询时，没有对应的数据行，再次查询时发现多了一行数据）</strong></p></li></ol><blockquote><p>补充：<strong>不可重复读和幻读的区别</strong></p><p>不可重复读的重点是修改；幻读的重点是新增或者删除。</p></blockquote><h3 id="面试官：怎么解决这些问题呢？MySQL的默认隔离级别是？（高频）"><a href="#面试官：怎么解决这些问题呢？MySQL的默认隔离级别是？（高频）" class="headerlink" title="面试官：怎么解决这些问题呢？MySQL的默认隔离级别是？（高频）"></a><strong>面试官</strong>：怎么解决这些问题呢？MySQL的默认隔离级别是？<code>（高频）</code></h3><p><strong>候选人</strong>：解决方案是<strong>对事务进行隔离</strong>。</p><p>MySQL支持四种隔离级别，分别有：</p><p>第一个是 <strong>未提交读（READ UNCOMMITTED）</strong> 它解决不了刚才提出的所有问题，一般项目中也不用这个。</p><p>第二个是 <strong>读已提交（READ COMMITTED）</strong> 它能解决脏读的问题的，但是解决不了不可重复读和幻读。</p><p>第三个是 <strong>可重复读（REPEATABLE READ）</strong> 在这个隔离级别下，事务在执行期间会锁定查询的数据行，确保该数据在事务完成前不会被其他事务修改。它能解决脏读和不可重复读，但是解决不了幻读，这个也是MySQL默认的隔离级别。</p><p>第四个是 <strong>串行化（SERIALIZABLE）</strong> 它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。</p><p>所以，我们一般使用的都是MySQL默认的隔离级别为<strong>可重复读</strong>。</p><h3 id="面试官：MySQL-中单表最多不能超过2000w？为什么？"><a href="#面试官：MySQL-中单表最多不能超过2000w？为什么？" class="headerlink" title="面试官：MySQL 中单表最多不能超过2000w？为什么？"></a><strong>面试官</strong>：MySQL 中单表最多不能超过2000w？为什么？</h3><p><strong>候选人</strong>：</p><p>• MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。</p><p>• 页的空间是 16K, 并不是所有的空间都是用来存放数据的,会有一些固定的信息,如,页头,页尾,页码,校验码等等。</p><p>• 在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于：叶子节点存放的是实际的行数据,而非叶子节点存放的是主键和页号。</p><p>• 索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致B+ 树层级更高，影响查询性能。</p><h3 id="面试官：MySQL-binlog，redolog和undolog的区别"><a href="#面试官：MySQL-binlog，redolog和undolog的区别" class="headerlink" title="面试官：MySQL binlog，redolog和undolog的区别"></a><strong>面试官</strong>：MySQL binlog，redolog和undolog的区别</h3><p><strong>候选人</strong>：</p><ul><li><p><strong>binlog</strong>（二进制日志）：记录所有对MySQL数据库的修改操作，包括插入、更新和删除等。binlog主要用于数据恢复到指定时间点或者指定事务。可以使用<code>mysql binlog</code>命令将binlog文件解析成SQL语句，从而恢复MySQL数据库的状态。</p></li><li><p><strong>redolog</strong>（重做日志）：记录所有对MySQL数据库的修改操作，但是只记录了<strong>物理操作</strong>，比如页的修改。redolog主要用于MySQL的崩溃恢复，即在MySQL崩溃后，通过重做日志，将数据库恢复到最近一次提交的状态。</p></li><li><p><strong>undolog</strong>（回滚日志）：用于记录事务的<strong>回滚操作</strong>，即在事务执行过程中，如果发生了回滚，会将回滚操作记录到undolog中。undolog主要用于 MySQL 的回滚操作，比如使用ROLLBACK语句回滚事务。undolog是InnoDB存储引擎的特有日志，不同于其他存储引擎。</p></li></ul><h3 id="面试官：事务中的隔离性是如何保证的呢？-你解释一下MVCC"><a href="#面试官：事务中的隔离性是如何保证的呢？-你解释一下MVCC" class="headerlink" title="面试官：事务中的隔离性是如何保证的呢？(你解释一下MVCC)"></a><strong>面试官</strong>：事务中的隔离性是如何保证的呢？(你解释一下MVCC)</h3><p><strong>候选人</strong>：事务的隔离性是由<strong>锁和MVCC</strong>实现的。</p><p>其中MVCC的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undo log日志，第三个是readView读视图。</p><p>隐藏字段是指：在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的；另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址。</p><p>undo log主要的作用是<strong>记录回滚日志，存储老版本数据</strong>，在内部会形成一个版本链，在多个事务并行操作某一行记录，<strong>记录不同事务修改数据的版本</strong>，通过roll_pointer指针形成一个链表。</p><p>readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。<strong>如果是rc隔离级别，每一次执行快照读时生成readView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</strong>。</p><h3 id="面试官：MySQL主从同步原理"><a href="#面试官：MySQL主从同步原理" class="headerlink" title="面试官：MySQL主从同步原理"></a><strong>面试官</strong>：MySQL主从同步原理</h3><p><strong>候选人</strong>：MySQL主从复制的核心就是二进制日志(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：</p><p>第一：主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p><p>第二：从库读取主库的二进制日志文件 Binlog ，写入到从库的<strong>中继日志 Relay Log</strong> 。</p><p>第三：从库重做中继日志中的事件，将改变反映它自己的数据。</p><blockquote><p>思考：<strong>为什么不让从库直接读取主库的binlog文件呢？中继日志的作用是什么？</strong></p><p>如果多个从库直接连接到主库并读取其binlog，这会增加主库的网络负载和磁盘IO压力。</p><p>如果从库失败，可通过中继日志快速恢复到失败前的状态，有助于加速从库的恢复过程。</p><p>由于中继日志是本地存储的，因此读取速度通常更快。</p></blockquote><h3 id="面试官：-谈谈你对读写分离和分库分表的理解（高频）"><a href="#面试官：-谈谈你对读写分离和分库分表的理解（高频）" class="headerlink" title="面试官： 谈谈你对读写分离和分库分表的理解（高频）"></a><strong>面试官：</strong> 谈谈你对读写分离和分库分表的理解<code>（高频）</code></h3><p><strong>候选人:</strong></p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="何为读写分离？"><a href="#何为读写分离？" class="headerlink" title="何为读写分离？"></a>何为读写分离？</h4><p>见名思意，根据读写分离的名字，我们就可以知道：<strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong> 这样的话，就能够小幅提升写性能，大幅提升读性能。</p><p><img src="https://pic1.imgdb.cn/item/67e15e040ba3d5a1d7e2a2c1.png" alt="image-20250219223812794"></p><p>一般情况下，我们都会选择一主多从，也就是<strong>一台主数据库负责写，其他的从数据库负责读</strong>。主库和从库之间会进行数据同步，以保证从库中数据的准确性。</p><h4 id="读写分离会带来什么问题？如何解决？"><a href="#读写分离会带来什么问题？如何解决？" class="headerlink" title="读写分离会带来什么问题？如何解决？"></a>读写分离会带来什么问题？如何解决？</h4><p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p><p>解决方案：</p><p><strong>1.强制将读请求路由到主库处理。</strong></p><p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。</p><p><strong>2.延迟读取。</strong></p><p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。</p><p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p><h4 id="如何实现读写分离？"><a href="#如何实现读写分离？" class="headerlink" title="如何实现读写分离？"></a>如何实现读写分离？</h4><p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p><ol><li>部署多台数据库，选择一种的一台作为主数据库，其他的一台或者多台作为从数据库。</li><li>保证主数据库和从数据库之间的数据是实时同步的。</li><li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li></ol><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：<strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p><p>换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p><p>答案之一就是 <strong>分库分表</strong>。</p><p><img src="https://pic1.imgdb.cn/item/67e15e300ba3d5a1d7e2a2cc.png" alt="image-20250219223901151"></p><p><img src="https://pic1.imgdb.cn/item/67e15e380ba3d5a1d7e2a2cd.png" alt="image-20250219223910561"></p><p><img src="https://pic1.imgdb.cn/item/67e15e400ba3d5a1d7e2a2ce.png" alt="image-20250219223920177"></p><h4 id="什么情况下需要分库分表？"><a href="#什么情况下需要分库分表？" class="headerlink" title="什么情况下需要分库分表？"></a>什么情况下需要分库分表？</h4><p>遇到下面几种场景可以考虑分库分表：</p><ul><li><strong>单表的数据达到千万级别以上</strong>，数据库读写速度比较缓慢（分表）。</li><li>数据库中的数据<strong>占用的空间越来越大</strong>，备份时间越来越长（分库）。</li><li>应用的<strong>并发量太大</strong>（分库）。</li></ul><h4 id="分库分表会带来什么问题呢？"><a href="#分库分表会带来什么问题呢？" class="headerlink" title="分库分表会带来什么问题呢？"></a>分库分表会带来什么问题呢？</h4><p>引入分库分表之后，会给系统带来什么挑战呢？</p><ul><li><strong>join 操作</strong> ：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的<code>封装</code>，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li><li><strong>事务问题</strong> ：同一个数据库中的表分布在不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li><li><strong>分布式 id</strong> ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入<code>分布式id</code>了。</li></ul><h3 id="相关阅读：揭秘！MySQL索引背后的秘密武器：B-树为何力压跳表，独领风骚？"><a href="#相关阅读：揭秘！MySQL索引背后的秘密武器：B-树为何力压跳表，独领风骚？" class="headerlink" title="相关阅读：揭秘！MySQL索引背后的秘密武器：B+树为何力压跳表，独领风骚？"></a>相关阅读：<a href="https://blog.csdn.net/weixin_74199893/article/details/140401043">揭秘！MySQL索引背后的秘密武器：B+树为何力压跳表，独领风骚？</a></h3>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合相关面试题</title>
      <link href="/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h2 id="1-Java常见的集合类"><a href="#1-Java常见的集合类" class="headerlink" title="1 Java常见的集合类"></a>1 Java常见的集合类</h2><h3 id="面试官：说一说Java提供的常见集合？（高频）"><a href="#面试官：说一说Java提供的常见集合？（高频）" class="headerlink" title="面试官：说一说Java提供的常见集合？（高频）"></a><strong>面试官</strong>：说一说Java提供的常见集合？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>在java中提供了量大类的集合框架，主要分为两类：</p><p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p><ul><li>在Collection中有三个子接口List、Set和Queue。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。在Queue接口中有实现类PriorityQueue等。</li><li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的ConcurrentHashMap</li></ul><p><img src="https://pic1.imgdb.cn/item/67e122000ba3d5a1d7e294bb.png" alt="image-20250303094632756"></p><h3 id="面试官：说说List-Set-Map三者的区别？"><a href="#面试官：说说List-Set-Map三者的区别？" class="headerlink" title="面试官：说说List,Set,Map三者的区别？"></a><strong>面试官</strong>：说说List,Set,Map三者的区别？</h3><p><strong>候选人</strong>：</p><ul><li><p>List (对付顺序的好帮⼿)： 存储的元素是<strong>有序的</strong> 、<strong>可重复</strong>的。</p></li><li><p>Set (注重独⼀⽆⼆的性质): 存储的元素是**⽆序的**、<strong>不可重复</strong>的。</p></li><li><p>Map (⽤ Key 来搜索的专家): 使⽤键值对（kye-value）存储，类似于数学上的函数y&#x3D;f(x)，“x”代表 key，”y”代表 value，<strong>Key 是⽆序的、不可重复的</strong>，<strong>value 是⽆序的、可重复的</strong>，每个键最多映射到⼀个值。</p></li></ul><h3 id="面试官：-常见集合的时间复杂度分析"><a href="#面试官：-常见集合的时间复杂度分析" class="headerlink" title="面试官： 常见集合的时间复杂度分析"></a><strong>面试官：</strong> 常见集合的时间复杂度分析</h3><p><strong>候选人</strong>：以下是各种常见数据结构的基本操作时间复杂度的简要概述：</p><h4 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h4><ul><li><strong>访问</strong>：O(1)，因为可以直接通过索引访问。</li><li><strong>插入&#x2F;删除</strong>：平均 O(n)，因为在中间位置插入或删除元素需要移动后续元素。</li><li><strong>搜索</strong>：O(n)，除非数组有序且使用二分查找，否则需要遍历整个数组。</li></ul><h4 id="2-单向链表（Singly-Linked-List）"><a href="#2-单向链表（Singly-Linked-List）" class="headerlink" title="2. 单向链表（Singly Linked List）"></a>2. 单向链表（Singly Linked List）</h4><ul><li><strong>访问</strong>：O(n)，因为需要从头节点开始遍历。</li><li><strong>插入&#x2F;删除</strong>：O(1)，如果已知前驱节点的话；否则需要 O(n) 来找到前驱节点。</li><li><strong>搜索</strong>：O(n)，因为需要遍历链表直到找到目标元素。</li></ul><h4 id="3-双向链表（Doubly-Linked-List）"><a href="#3-双向链表（Doubly-Linked-List）" class="headerlink" title="3. 双向链表（Doubly Linked List）"></a>3. 双向链表（Doubly Linked List）</h4><ul><li><strong>访问</strong>：O(n)，因为也需要从头节点或尾节点开始遍历。</li><li><strong>插入&#x2F;删除</strong>：O(1)，如果已知前驱或后继节点的话；否则需要 O(n) 来找到前驱或后继节点。</li><li><strong>搜索</strong>：O(n)，因为需要遍历链表直到找到目标元素。</li></ul><h4 id="4-二叉搜索树（Binary-Search-Tree）"><a href="#4-二叉搜索树（Binary-Search-Tree）" class="headerlink" title="4. 二叉搜索树（Binary Search Tree）"></a>4. 二叉搜索树（Binary Search Tree）</h4><ul><li><strong>最佳情况（平衡）</strong>：<ul><li><strong>访问&#x2F;搜索</strong>：O(log n)，如果树是平衡的。</li><li><strong>插入&#x2F;删除</strong>：O(log n)，如果树是平衡的。</li></ul></li><li><strong>最坏情况（不平衡）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(n)，如果树退化成链式结构。</li></ul></li></ul><h4 id="5-红黑树（Red-Black-Tree）"><a href="#5-红黑树（Red-Black-Tree）" class="headerlink" title="5. 红黑树（Red-Black Tree）"></a>5. 红黑树（Red-Black Tree）</h4><ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(log n)，因为红黑树是一种自平衡的二叉搜索树，能够保持树的高度较低。</li></ul><h4 id="6-散列表（Hash-Table）"><a href="#6-散列表（Hash-Table）" class="headerlink" title="6. 散列表（Hash Table）"></a>6. 散列表（Hash Table）</h4><ul><li><strong>理想情况（均匀分布）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：平均 O(1)，理想情况下，哈希函数将键均匀分布在哈希表中，减少了冲突。</li></ul></li><li><strong>最坏情况（严重冲突）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(n)，如果哈希函数导致大量冲突，性能退化。</li></ul></li></ul><h2 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h2><h3 id="面试官：ArrayList底层是如何实现的？-jdk1-8源码解析"><a href="#面试官：ArrayList底层是如何实现的？-jdk1-8源码解析" class="headerlink" title="面试官：ArrayList底层是如何实现的？(jdk1.8源码解析)"></a><strong>面试官</strong>：ArrayList底层是如何实现的？(jdk1.8源码解析)</h3><p><strong>候选人</strong>：</p><ol><li>类定义与成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部使用的数组，用于存储元素</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列表的实际大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初识容量为10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认的空数组，用于初始化空的 ArrayList</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空闲数组，用于优化 ArrayList 的行为</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>构造函数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，初始化为空数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始容量的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从 Collection 初始化 ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="comment">// 第一步：确保数组已使用长度（size）加1之后足够存下下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 第三步：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 第四步：返回添加成功布尔值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>获取元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查索引是否合法。</span></span><br><span class="line">    RangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">RangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#面试官：ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="面试官：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a><strong>面试官</strong>：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h3><p><strong>候选人</strong>：</p><p>在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p><h3 id="面试官：说⼀说-ArrayList-的扩容机制吧？"><a href="#面试官：说⼀说-ArrayList-的扩容机制吧？" class="headerlink" title="面试官：说⼀说 ArrayList 的扩容机制吧？"></a><strong>面试官</strong>：说⼀说 ArrayList 的扩容机制吧？</h3><p><strong>候选人：</strong> 在添加元素时会检查当前数组的容量是否足够存放新的元素。如果不足够，则会触发扩容操作。扩容机制主要包括以下几个步骤：</p><ol><li><p><strong>检测容量不足</strong>：当尝试添加新元素时，<code>ArrayList</code> 会先检查当前的容量是否足以容纳新的元素。</p></li><li><p><strong>触发扩容</strong>：如果当前容量不足，则会调用 <code>ensureCapacityInternal</code> 方法来确保有足够的空间。</p></li><li><p><strong>计算新容量</strong>：通常情况下，新容量为当前容量的 1.5 倍。</p></li><li><p><strong>执行扩容</strong>：使用 <code>Arrays.copyOf</code> 方法来创建一个新的数组，并将旧数组的内容拷贝到新数组中。</p></li></ol><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保有足够的容量来存放新的元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将新元素放置在当前 size 的位置，并将 size 增加 1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回添加成功的标志</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果所需的最小容量大于当前数组的长度，则调用 grow 方法</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算新的容量，默认情况下是旧容量的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量仍然小于所需的最小容量，则使用所需的最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量超过最大数组大小，则使用大的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用新的容量创建一个新的数组，并拷贝旧数组的内容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：-为什么数组索引从0开始？"><a href="#面试官：-为什么数组索引从0开始？" class="headerlink" title="面试官： 为什么数组索引从0开始？"></a><strong>面试官：</strong> 为什么数组索引从0开始？</h3><p><strong>候选人：</strong></p><p>在根据数据索引获取元素的时候，会用索引和寻址公式来计算内存中所对应的元素数据。</p><blockquote><p>数组索引从0开始，寻址公式可以简化为：</p><p><strong>arr[i] &#x3D; baseAddress + i * dataTypeSize</strong><br>地址&#x3D;基地址+(索引×元素大小)</p></blockquote><p>如果数组的索引从1开始，寻址公式中就会增加一次减法操作，对CPU来说就多了一条指令，性能不高。</p><blockquote><p>如果索引从1开始，则寻址公式变为：</p><p><em><em>arr[i] &#x3D; baseAddress + (i - 1)</em> dataTypeSize</em>*<br>地址&#x3D;基地址+((索引−1)×元素大小)</p></blockquote><h3 id="面试官：如何实现数组和List之间的转换"><a href="#面试官：如何实现数组和List之间的转换" class="headerlink" title="面试官：如何实现数组和List之间的转换"></a><strong>面试官</strong>：如何实现数组和List之间的转换</h3><p><strong>候选人</strong>：</p><ol><li><p><strong>数组转List</strong>：可以使用 <code>Arrays.asList(T... a)</code> 方法将数组转换为 <code>List</code>。该方法返回一个基于原数组的 <code>List</code>，所以它是一个固定大小的列表，不能进行添加或删除操作，但可以修改元素。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br></pre></td></tr></table></figure></li><li><p><strong>List 转数组</strong>：可以使用 <code>List</code> 的 <code>toArray()</code> 方法将 <code>List</code> 转换为数组。</p><ul><li><strong><code>toArray()</code></strong>：返回一个包含所有 <code>List</code> 元素的数组，但该数组类型是 <code>Object[]</code>，需要类型转换。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>toArray(new String[0])</code> 中的 <code>new String[0]</code> 是为了确保返回的数组类型正确，而不是使用 <code>new String[list.size()]</code>，这样可以避免在一些情况下的性能问题。</p></blockquote></li></ol><h3 id="面试官：用Arrays-asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗"><a href="#面试官：用Arrays-asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗" class="headerlink" title="面试官：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗"></a><strong>面试官</strong>：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗</h3><p><strong>候选人</strong>：</p><ul><li><strong>Arrays.asList</strong> 转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是<strong>同一个内存地址</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] array = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改数组的元素</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;List: &quot;</span> + list); <span class="comment">// 输出 List: [X, B, C]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Array: &quot;</span> + Arrays.toString(array)); <span class="comment">// 输出 Array: [X, B, C]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list用了 <strong>toArray</strong> 转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了<strong>数组的拷贝</strong>，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 toArray 方法转换为数组</span></span><br><span class="line">        String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 List</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;List: &quot;</span> + list); <span class="comment">// 输出 List: [X, B, C]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Array: &quot;</span> + Arrays.toString(array)); <span class="comment">// 输出 Array: [A, B, C]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：ArrayList-和-LinkedList-的区别是什么？（高频）"><a href="#面试官：ArrayList-和-LinkedList-的区别是什么？（高频）" class="headerlink" title="面试官：ArrayList 和 LinkedList 的区别是什么？（高频）"></a><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ol><li><p><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>底层数据结构：</strong> Arraylist 底层使⽤的是 <strong>Object</strong> <strong>数组</strong>； LinkedList 底层使⽤的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</p></li><li><p><strong>插⼊和删除是否受元素位置的影响：</strong> ① <strong>ArrayList</strong> <strong>采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。</strong> ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置插⼊和删除元素的话时间复杂度就为 O(n)。②<strong>LinkedList</strong> <strong>采⽤链表存储，所以对于</strong> <strong>add(E e)</strong> <strong>⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似O(1)</strong>，如果是要在指定位置插⼊和删除元素的话（ (add(int index, Eelement) ） 时间复杂度近似为o(n)。</p></li><li><p><strong>是否⽀持快速随机访问：</strong> LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。（数组天然⽀持随机访问，时间复杂度为 <strong>O(1)</strong>，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 <strong>O(n)</strong>，所以不⽀持快速随机访问。）</p></li><li><p><strong>内存空间占⽤：</strong> ArrayList 底层是数组，内存连续，节省内存；LinkedList 是双向链表需要存储数据和两个指针，更占用内存。</p></li><li><p><strong>应用场景：</strong> 访问频繁选数组，插删频繁选链表。</p></li></ol><blockquote><p>补充：<strong>双向链表和双向循环链表</strong></p><p><strong>双向链表：</strong> 包含两个指针，⼀个 prev 指向前⼀个节点，⼀个 next 指向后⼀个节点。</p><p><img src="https://pic1.imgdb.cn/item/67e1221a0ba3d5a1d7e294cf.png" alt="image-20250218112654847"></p><p><strong>双向循环链表：</strong> 最后⼀个节点的 next 指向 head，⽽ head 的 prev 指向最后⼀个节点，构成⼀个环。</p><p><img src="https://pic1.imgdb.cn/item/67e122220ba3d5a1d7e294e0.png" alt="image-20250218112704475"></p></blockquote><blockquote><p>补充：<strong>RandomAccess接⼝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接⼝中什么都没有定义。所以，在我看来<code>RandomAccess</code> 接⼝不过是⼀个标识罢了。标识什么？ 标识实现这个接⼝的类具有随机访问功能。ArrayList 实现了 <code>RandomAccess</code> 接⼝，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接⼝只是标识，<strong>并不是说 ArrayList实现 RandomAccess 接⼝才具有快速随机访问功能的！</strong></p></blockquote><h3 id="面试官：-ArrayList-与-Vector-区别？"><a href="#面试官：-ArrayList-与-Vector-区别？" class="headerlink" title="面试官：  ArrayList 与 Vector 区别？"></a><strong>面试官：</strong>  ArrayList 与 Vector 区别？</h3><p><strong>候选人：</strong></p><p>• <strong>线程安全性:</strong> Vector是线程安全的，ArrayList不是线程安全的。</p><p>• <strong>扩容策略:</strong> ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</p><blockquote><p>ArrayList和Vector都支持动态扩容，都属于动态数组。</p></blockquote><h3 id="面试官：刚才你说了ArrayList-和-LinkedList-不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？"><a href="#面试官：刚才你说了ArrayList-和-LinkedList-不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？" class="headerlink" title="面试官：刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？"></a><strong>面试官</strong>：刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</h3><p><strong>候选人</strong>：</p><p>主要有两种解决方案：</p><p>第一：我们使用这个集合，优先在方法内使用，定义为<strong>局部变量</strong>，且不能逃离方法的作用范围。这样的话，就不会出现线程安全问题。</p><p>第二：如果非要在成员变量中使用的话，可以使用<strong>线程安全的集合</strong>来替代</p><ul><li><p>ArrayList可以通过Collections 的 <strong>synchronizedList</strong> 方法将 ArrayList 转换成线程安全的容器后再使用。</p></li><li><p>LinkedList 换成<strong>ConcurrentLinkedQueue</strong>来使用</p></li></ul><h2 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3 HashMap"></a>3 HashMap</h2><h3 id="前提知识：红黑树和二叉搜索树（Binary-Search-Tree-BST）"><a href="#前提知识：红黑树和二叉搜索树（Binary-Search-Tree-BST）" class="headerlink" title="前提知识：红黑树和二叉搜索树（Binary Search Tree,BST）"></a>前提知识：红黑树和二叉搜索树（Binary Search Tree,BST）</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型。</p><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p><p><img src="https://pic1.imgdb.cn/item/67e1222d0ba3d5a1d7e294e7.png" alt="image-20250218112825681"></p><h4 id="红黑树（高频）"><a href="#红黑树（高频）" class="headerlink" title="红黑树（高频）"></a>红黑树<code>（高频）</code></h4><p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）。</p><p><img src="https://pic1.imgdb.cn/item/67e122760ba3d5a1d7e29509.png" alt="image-20250218112839568"></p><p>（2）红黑树的特质</p><p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p><p>性质2：根节点是<strong>黑色</strong></p><p>性质3：叶子节点都是黑色的空节点</p><p>性质4：红黑树中红色节点的子节点都是黑色</p><p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p><p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong>。</p><h3 id="面试官：说一下HashMap的实现原理？"><a href="#面试官：说一下HashMap的实现原理？" class="headerlink" title="面试官：说一下HashMap的实现原理？"></a><strong>面试官</strong>：说一下HashMap的实现原理？</h3><p><strong>候选人</strong>：</p><p>1，底层使用hash表数据结构，即<strong>数组 + 链表 &#x2F; 红黑树</strong>。</p><p>2，添加数据时，计算key的值确定元素在数组中的下标。</p><ul><li><p>key相同则替换</p></li><li><p>不同则存入链表或红黑树中</p></li></ul><p>3，获取数据通过key的hash计算数组下标获取元素。</p><blockquote><p><strong>红黑树比链表的优点?</strong><br>红黑树是一种自平衡的二叉搜索树，而链表是线性数据结构。红黑树的查找复杂度是 <strong>O(log n)</strong>，查找效率更高；红黑树在插入和删除操作的时间复杂度为 <strong>O(log n)</strong>；红黑树节点只需要存储少量额外的颜色信息，不会像链表那样需要存储大量的指针。<br><strong>为什么不一开始就用红黑树？</strong><br>虽然红黑树的查询效率更高，但它并不适合所有场景。如果数据量非常小，比如只有几个节点，链表的线性查找效率并不会比红黑树差多少。红黑树需要额外的内存来存储指向左右子节点的指针和颜色信息。链表仅需要存储一个指针（单链表）或两个指针（双向链表）；如果数据变化频繁，红黑树的频繁平衡操作可能带来额外的计算成本。</p></blockquote><h3 id="面试官：HashMap的jdk1-7和jdk1-8有什么区别（高频）"><a href="#面试官：HashMap的jdk1-7和jdk1-8有什么区别（高频）" class="headerlink" title="面试官：HashMap的jdk1.7和jdk1.8有什么区别（高频）"></a><strong>面试官</strong>：HashMap的jdk1.7和jdk1.8有什么区别<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ul><li><p>JDK1.7采用的是拉链法，<strong>数组+链表</strong>。在扩容时使用 <strong>“头插法”</strong> 插入新元素。这种方式会导致链表顺序反转，在多线程环境下，可能引发环形链表问题，导致程序死循环。扩容是 <strong>“先扩容后插入”</strong>，无论是否发生哈希冲突，都会执行扩容操作，可能导致无效扩容。</p></li><li><p>JDK1.8之后采用<strong>数组+链表+红黑树</strong>，链表长度大于8且数组长度大于64则会从链表转化为红黑树。改为 <strong>“尾插法”</strong> 插入，保证链表顺序一致，避免了扩容中的死循环问题。扩容变为 <strong>“先插入再扩容”</strong>，只有当插入后超过阈值或发生哈希冲突时，才会触发扩容，减少了不必要的操作。</p></li></ul><blockquote><p>补充：什么是拉链法？</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建⼀个链表数组，数组中每⼀格就是⼀个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></blockquote><blockquote><p>jdk1.8 中将链表改造红黑树还有一个非常重要的原因，可以防止DDos攻击。</p><p><strong>DDos 攻击</strong>：分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS）</p><p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个。</p></blockquote><h3 id="面试官：-如何解决hash冲突？"><a href="#面试官：-如何解决hash冲突？" class="headerlink" title="面试官： 如何解决hash冲突？"></a><strong>面试官：</strong> 如何解决hash冲突？</h3><p><strong>候选人：</strong> 在 Java 中，解决哈希冲突的常用方法有<strong>链地址法、红黑树、开放地址法和再哈希法</strong>。</p><p><strong>链地址法</strong>通过在每个桶中存储一个链表，将冲突的元素串联起来。它实现简单，但在链表过长时性能会下降。</p><p>为了解决链表性能问题，Java 8 引入了<strong>红黑树</strong>。当链表长度超过 8 且数组长度达到 64 时，链表会转换为红黑树，将查找效率提升至 O(log n)。</p><p><strong>开放地址法</strong>则通过在哈希表中寻找下一个空闲位置存储数据，常用的方式包括<strong>线性探测（依次向后查找）和二次探测（采用平方检测）</strong>。它节省空间，但在负载因子较高时性能会下降。</p><p><strong>再哈希法</strong>通过使用另一个哈希函数重新计算哈希值来解决冲突，避免链表或树结构，但计算成本较高。</p><p>在 Java 中，<strong>链地址法和红黑树</strong>的组合是最常用的解决方案，兼顾了性能和内存使用。</p><h3 id="面试官：知道hashmap在1-7情况下的多线程死循环问题吗？"><a href="#面试官：知道hashmap在1-7情况下的多线程死循环问题吗？" class="headerlink" title="面试官：知道hashmap在1.7情况下的多线程死循环问题吗？"></a><strong>面试官</strong>：知道hashmap在1.7情况下的多线程死循环问题吗？</h3><p><strong>候选人</strong>：</p><h4 id="Java-1-7-中的死循环问题"><a href="#Java-1-7-中的死循环问题" class="headerlink" title="Java 1.7 中的死循环问题"></a>Java 1.7 中的死循环问题</h4><p>在Java 1.7中，<code>HashMap</code>采用的是“头插法”进行扩容。这意味着在扩容时，旧数组中的元素会根据新的索引位置被插入到新数组对应的链表头部。当两个或更多的线程几乎同时进行扩容操作时，可能会导致如下情形：</p><ol><li><strong>线程一读取并开始扩容</strong>：假设线程一开始读取<code>HashMap</code>并准备进行扩容。此时，它读取到了某个链表，该链表包含节点A和节点B（顺序为A -&gt; B）。</li><li><strong>线程二介入并完成扩容</strong>：在线程一还没有完成扩容之前，线程二也开始了扩容操作。线程二按照头插法将节点A和节点B重新插入新数组中的对应位置，但是顺序变成了B -&gt; A（因为A先插入，然后B插入到A的前面）。</li><li><strong>线程一继续执行</strong>：当线程一恢复执行时，它尝试将节点A插入新数组中的对应位置。按照头插法，它会将A插入到链表的头部。然而，此时节点B已经在链表的头部，并且B的<code>next</code>已经指向了A。因此，当线程一将A插入时，A的<code>next</code>又指向了B，这就形成了一个循环链表（A -&gt; B -&gt; A）。</li></ol><h4 id="解决方法：Java-1-8-的尾插法"><a href="#解决方法：Java-1-8-的尾插法" class="headerlink" title="解决方法：Java 1.8 的尾插法"></a>解决方法：Java 1.8 的尾插法</h4><p>Java 1.8中的<code>HashMap</code>采用了“尾插法”，而不是头插法来进行扩容。这意味着在扩容时，元素会插入到链表的末尾，而不是头部。这样做的好处在于，即使多个线程几乎同时进行扩容，也不会改变链表原有的顺序，从而避免了循环链表的产生。</p><h3 id="面试官：说下HashMap中put方法的具体流程（高频）"><a href="#面试官：说下HashMap中put方法的具体流程（高频）" class="headerlink" title="面试官：说下HashMap中put方法的具体流程（高频）"></a><strong>面试官</strong>：说下HashMap中put方法的具体流程<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p><img src="https://pic1.imgdb.cn/item/67e1235e0ba3d5a1d7e29537.png" alt="image-20250218112948771"></p><ul><li>首先判断键值对数组table是否为空，如果为空则执行resize()进行扩容（初始化长度为16的数组）</li><li>如果不为空则根据key计算hash值，得到数组的索引</li><li>判断该索引位置是否为空，如果为空直接<strong>插入</strong>即可，否则进行后续操作</li><li>判断当前索引位置上的key是否与要插入元素的key相同（是否存在），存在相同的话直接<strong>覆盖value</strong>就可以了</li><li>不相同的话判断该位置是否为红黑树，如果是红黑树，则直接在树中<strong>插入</strong>键值对即可</li><li>如果不是的话就要遍历链表，判断该位置的key是否存在，如果存在相同的直接<strong>覆盖value</strong>即可</li><li>如果不相同的话就使用尾插法，并判断链表长度是否大于8，大于8的话把链表转换为红黑树，走红黑树<strong>插入</strong>的逻辑</li><li>最后一步，就是在以上所有涉及到插入的操作中，判断<strong>实际存在的键值对数量size</strong>（也就是++size）是否超出了最大容量threshold，如果超过，就进行扩容。</li></ul><p>添加元素的时候至少考虑三种情况：</p><blockquote><ol><li>数组位置为null</li><li>数组位置不为null，键重复，元素覆盖</li><li>数组位置不为null，键不重复，挂在下面形成链表或者红黑树</li></ol></blockquote><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//参数一：键</span></span><br><span class="line">    <span class="comment">//参数二：值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值：被覆盖元素的值，如果没有覆盖，返回null</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用键计算出对应的哈希值，再把哈希值进行一些额外的处理</span></span><br><span class="line"><span class="comment">//简单理解：返回值就是返回键的哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个局部变量，用来记录哈希表中数组的地址值。</span></span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="comment">//临时的第三方变量，用来记录键值对对象的地址值</span></span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="comment">//表示当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//表示索引</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//把哈希表中数组的地址值，赋值给局部变量tab</span></span><br><span class="line">    tab = table;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//1.如果当前是第一次添加数据，底层会创建一个默认长度为16，加载因子为0.75的数组</span></span><br><span class="line">        <span class="comment">//2.如果不是第一次添加数据，会看数组中的元素是否达到了扩容的条件</span></span><br><span class="line">        <span class="comment">//如果没有达到扩容条件，底层不会做任何操作</span></span><br><span class="line">        <span class="comment">//如果达到了扩容条件，底层会把数组扩容为原先的两倍，并把数据全部转移到新的哈希表中</span></span><br><span class="line">        tab = resize();</span><br><span class="line">        <span class="comment">//表示把当前数组的长度赋值给n</span></span><br><span class="line">        n = tab.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿着数组的长度跟键的哈希值进行计算，计算出当前键值对对象，在数组中应存入的位置</span></span><br><span class="line">    i = (n - <span class="number">1</span>) &amp; hash;   <span class="comment">//index</span></span><br><span class="line">    <span class="comment">//获取数组中对应元素的数据</span></span><br><span class="line">    p = tab[i];</span><br><span class="line">    <span class="comment">//判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//等号的左边：数组中键值对的哈希值</span></span><br><span class="line">        <span class="comment">//等号的右边：当前要添加键值对的哈希值</span></span><br><span class="line">        <span class="comment">//如果键不一样，此时返回false</span></span><br><span class="line">        <span class="comment">//如果键一样，返回true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> p.hash == hash;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (b1 &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            <span class="comment">//判断数组中获取出来的键值对是不是红黑树中的节点</span></span><br><span class="line">            <span class="comment">//如果是，则调用方法putTreeVal，把当前的节点按照红黑树的规则添加到树当中。</span></span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果从数组中获取出来的键值对不是红黑树中的节点</span></span><br><span class="line">            <span class="comment">//表示此时下面挂的是链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//判断当前链表长度是否超过8，如果超过8，就会调用方法treeifyBin</span></span><br><span class="line">                    <span class="comment">//treeifyBin方法的底层还会继续判断:判断数组的长度是否大于等于64</span></span><br><span class="line">                    <span class="comment">//如果同时满足这两个条件，就会把这个链表转成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为覆盖操作</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                    p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出旧值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//threshold：记录的就是数组的长度 * 0.75，哈希表的扩容时机  16 * 0.75 = 12</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//表示当前没有覆盖任何元素，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：讲一讲HashMap的扩容机制（高频）"><a href="#面试官：讲一讲HashMap的扩容机制（高频）" class="headerlink" title="面试官：讲一讲HashMap的扩容机制（高频）"></a><strong>面试官</strong>：讲一讲HashMap的扩容机制<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p><img src="https://pic1.imgdb.cn/item/67e1239d0ba3d5a1d7e2954e.png" alt="请添加图片描述"></p><ul><li>在添加元素或初始化的时候需要调用resize()方法进行扩容，第一次添加数据初始化数组长度为16，以后每次扩容都是达到了扩容阈值（数组长度 * 0.75）</li></ul><blockquote><p>扩容阈值 &#x3D; 数组容量 * 加载因子（默认为0.75）</p><p>负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。</p></blockquote><ul><li><p>每次扩容的时候，都是扩容之前容量的2倍； </p></li><li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p></li><li><p>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p></li><li><p>有冲突节点的话，如果是红黑树，就走红黑树的添加</p></li><li><p>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ul><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？"><a href="#面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？"></a><strong>面试官</strong>：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？</h3><p><strong>候选人</strong>：JDK 1.8 的 hash ⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二次哈希：首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p><p>在putValue的方法中，计算数组下标的时候使用<strong>hash值与数组长度取模</strong>得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了<strong>数组长度-1</strong> 得到一个值，用这个值按位<strong>与运算</strong>hash值，最终得到数组的位置。（也就是说 <strong>hash%length&#x3D;&#x3D;hash&amp;(length-1)</strong> 的前提是 length 是2的 <strong>n次⽅）</strong> 并且采⽤⼆进制位操作 &amp;，相对于 % 能够提⾼运算效率，这就解释了<strong>HashMap的⻓度为什么是2的幂次⽅。</strong></p><h3 id="面试官：好的，hashmap是线程安全的吗？"><a href="#面试官：好的，hashmap是线程安全的吗？" class="headerlink" title="面试官：好的，hashmap是线程安全的吗？"></a><strong>面试官</strong>：好的，hashmap是线程安全的吗？</h3><p><strong>候选人</strong>：不是线程安全的</p><h3 id="面试官：那我们想要使用线程安全的map该怎么做呢？"><a href="#面试官：那我们想要使用线程安全的map该怎么做呢？" class="headerlink" title="面试官：那我们想要使用线程安全的map该怎么做呢？"></a><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</h3><p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p><h3 id="面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）"><a href="#面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）" class="headerlink" title="面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）"></a><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？<code>（高频）</code></h3><blockquote><p>《Java并发编程的艺术》 6.1.1 为什么要使用 ConcurrentHashMap?</p><p>在并发编程中使用 HashMap 可能导致程序死循环。而使用线程安全的 HashTable 效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap 的登场机会。</p><p>（1）线程不安全的HashMap</p><p>在多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近100%，所以在并发情况下不能使用 HashMap。HashMap 在并发执行 put 操作时会引起死循环，是因为多线程会导致 HashMap 的 Entry 链表形成<strong>环形数据结构</strong>，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取 Entry。</p><p>（2）效率低下的HashTable（一锁就锁全表）</p><p>HashTable 容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable 的效率非常低下。因为当一个线程访问HashTable 的同步方法，其他线程也访问HashTable 的同步方法时，会进入阻塞或轮询状态。如线程1使用 put 进行元素添加，线程2 不但不能使用 put 方法添加元素，也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p><p>（3）ConcurrentHashMap 的锁分段技术可有效提升并发访问率</p><p>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap 所使用的锁分段技术。</p></blockquote><p><strong>候选人</strong>：ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong>。</li></ul><p>在jdk1.7中ConcurrentHashMap 是由Segment 数组结构和HashEntry数组结构组成。Segment 是一种可重入锁(类似ReentrantLock)，扮演锁的⻆⾊。HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个Segment数组。一个Segment 里包含一个 HashEntry 数组，<strong>每个 HashEntry 是一个链表结构的元素</strong>，每个 Segment 守护着一个 HashEntry 数组，当对 HashEntry 数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p><p><img src="https://pic1.imgdb.cn/item/67e123e70ba3d5a1d7e29569.png" alt="image-20250218113808758"></p><p>在jdk1.8中ConcurrentHashMap 取消了 Segment 分段锁，采⽤ <strong>CAS 和 synchronized</strong> 来保证并发安全。虽然 <code>CAS</code> 能保证<strong>单个变量</strong>的原子更新，但在 <strong>多个变量关联修改</strong> 时，就会产生<strong>ABA 问题</strong>或 <strong>自旋失败问题</strong>，因此 JDK 1.8 <code>ConcurrentHashMap</code> 仍然<strong>结合 <code>synchronized</code></strong> 来保证更复杂场景的安全。</p><blockquote><p>ABA 问题是 <strong>CAS（Compare-And-Swap）</strong> 机制中的一种特殊并发问题，指的是：<br><strong>某个变量的值从 A 变为 B，然后又变回 A，CAS 机制无法察觉这个变化，从而导致错误的结果。</strong></p><p>在 <strong>高并发环境</strong> 下，如果线程在 CAS 操作时仅仅判断值是否相等，而不检查是否发生过中间修改，就可能出现 ABA 问题。</p></blockquote><h3 id="面试官：说说ConcurrentHashMap的get、put、size操作"><a href="#面试官：说说ConcurrentHashMap的get、put、size操作" class="headerlink" title="面试官：说说ConcurrentHashMap的get、put、size操作"></a><strong>面试官</strong>：说说ConcurrentHashMap的get、put、size操作</h3><p><strong>候选人</strong>：（源自《Java并发编程的艺术》 6.1.5节）</p><p><strong>get操作：</strong></p><p>先经过一次散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key.hashcode());</span><br><span class="line">  <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。我们知道 HashTable 容器的 get 方法是需要加锁的，那么 <strong>ConcurrentHashMap 的 get 操作是如何做到不加锁</strong>的呢？原因是它的 get方法里将要使用的共享变量都定义成 <strong>volatile</strong> 类型。定义成 volatile 的变量，能够在线程之间保持可见性，<strong>能够被多线程同时读，并且保证不会读到过期的值</strong>，但是只能被单线程写(有一种情况可以被多线程写，就是写入的值不依赖于原值)，在get操作里只需要读不需要写共享变量 count 和 value，所以可以不用加锁。之所以不会读到过期的值，是因为根据 <strong>Java 内存模型的 happens-before 原则</strong>，对 volatile 字段的写入操作先于读操作，即使两个线程同时修改和获取 volatile 变量，get操作也能拿到最新的值，这是用 volatile替换锁的经典应用场景。</p><p><strong>put操作：</strong></p><p>由于 put 方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放在 HashEnty 数组里。</p><p>1）是否需要扩容</p><p>在插入元素前会先判断Segment 里的 HashEnty数组是否超过容量(threshold)，如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比 HashMap 更恰当，因为 HashMap 是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，可能扩容之后没有新元素插入，这时 HashMap 就进行了一次无效的扩容。</p><p>2）如何扩容</p><p>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个 Segment 进行扩容。</p><p><strong>size 操作：</strong></p><p>如果要统计整个 ConcurrentHashMap 里元素的大小，就必须统计所有 Segment 里元素的大小后求和。Segment里的全局变量 count 是一个 volatile 变量，那么在多线程场景下，是不是直接把所有 Segment 的 count 相加就可以得到整个 ConcurrentHashMap 大小了呢? 不是的，虽然相加时可以获取每个 Segment 的 count 的最新值，但是可能累加前使用的 count 发生了变化，那么统计结果就不准了。所以，最安全的做法是在统计size的时候把所有Segment 的put、remove 和 clean 方法全部锁住，但是这种做法显然非常低效。</p><p>因为在累加 count 操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap 的做法是<strong>尝试2次</strong>：通过不锁住Segment的方式来统计各个Segment大小；如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment 的大小。</p><p>那么 ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢?使用modCount 变量，在 put、remove 和 clean 方法里操作元素前都会将变量 modCount 进行加1.那么在统计 size 前后比较 modCount 是否发生变化，从而得知容器的大小是否发生变化。</p><h3 id="面试官：ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#面试官：ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="面试官：ConcurrentHashMap用了悲观锁还是乐观锁?"></a><strong>面试官</strong>：ConcurrentHashMap用了悲观锁还是乐观锁?</h3><p><strong>候选人</strong>：悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空:</p><p>• 如果为空则使用 <code>volatile + CAS (乐观锁)</code> 来初始化。</p><p>• 如果容器不为空，则根据存储的元素计算该位置是否为空。</p><p>•如果根据存储的元素计算结果为空，则利用<code>CAS(乐观锁)</code> 设置该节点;</p><p>• 如果根据存储的元素计算结果不为空，则使用 synchronized(悲观锁)，然后遍历桶中的数据并替换或新增节点到桶中，最后再判断是否需要转为红黑树,这样就能保证并发访问时的线程安全了。</p><h3 id="面试官：HashSet与HashMap的区别？"><a href="#面试官：HashSet与HashMap的区别？" class="headerlink" title="面试官：HashSet与HashMap的区别？"></a><strong>面试官</strong>：HashSet与HashMap的区别？</h3><p><strong>候选人</strong>：HashSet 底层就是基于 HashMap 实现的。</p><p><img src="https://pic1.imgdb.cn/item/67e1240f0ba3d5a1d7e29575.png" alt="image-20250218113836389"></p><h3 id="面试官：HashTable与HashMap的区别"><a href="#面试官：HashTable与HashMap的区别" class="headerlink" title="面试官：HashTable与HashMap的区别"></a><strong>面试官</strong>：HashTable与HashMap的区别</h3><p><strong>候选人</strong>：</p><table><thead><tr><th align="center"><strong>区别</strong></th><th align="center"><strong>HashTable</strong></th><th align="center"><strong>HashMap</strong></th></tr></thead><tbody><tr><td align="center">数据结构</td><td align="center">数组+链表</td><td align="center">数组+链表+红黑树</td></tr><tr><td align="center">是否可以为null</td><td align="center">Key和value都不能为null</td><td align="center">可以为null</td></tr><tr><td align="center">hash算法</td><td align="center">key的hashCode()</td><td align="center">二次hash</td></tr><tr><td align="center">扩容方式</td><td align="center">当前容量翻倍 +1（2n + 1）</td><td align="center">当前容量翻倍(2n)</td></tr><tr><td align="center">线程安全</td><td align="center">同步(synchronized)的，线程安全</td><td align="center">非线程安全</td></tr></tbody></table><p>在实际开发中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架相关面试题</title>
      <link href="/2025/03/23/SSM%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/23/SSM%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h3 id="面试官：-Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#面试官：-Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="面试官： Spring,Spring MVC,Spring Boot 之间什么关系?"></a><strong>面试官：</strong> Spring,Spring MVC,Spring Boot 之间什么关系?</h3><p><strong>Spring MVC</strong> 是 <strong>Spring</strong> 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p><img src="https://pic1.imgdb.cn/item/67e124e40ba3d5a1d7e2959f.png" alt="image-20250220112745225"></p><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！<strong>Spring Boot</strong> 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 <strong>Spring MVC</strong> 作为 MVC 框架，只是说 <strong>Spring Boot</strong> 帮你简化了 <strong>Spring MVC</strong> 的很多配置，真正做到开箱即用！</p><h3 id="面试官：-RestController-vs-Controller"><a href="#面试官：-RestController-vs-Controller" class="headerlink" title="面试官：@RestController vs @Controller"></a><strong>面试官</strong>：@RestController vs @Controller</h3><p><strong>候选人</strong>：</p><blockquote><p>@Controller + @ResponseBody &#x3D; @RestController</p></blockquote><p><strong>Controller</strong> <strong>返回⼀个⻚⾯</strong></p><p>单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要<strong>返回⼀个视图</strong>的情况，这种情况属于⽐传统的Spring MVC 的应⽤，对应于前后端不分离的情况。</p><p><img src="https://pic1.imgdb.cn/item/67e1251a0ba3d5a1d7e295a4.png" alt="image-20250220112800901"></p><p><strong>@RestController 返回JSON 或 XML 形式数据</strong></p><p>@RestController <strong>只返回对象</strong>，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离）。</p><p><img src="https://pic1.imgdb.cn/item/67e1252a0ba3d5a1d7e295a8.png" alt="image-20250220112812238"></p><blockquote><p>@ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的<strong>转换器转换为指定的格式</strong>之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐多。</p></blockquote><p><img src="https://pic1.imgdb.cn/item/67e125320ba3d5a1d7e295ac.png" alt="image-20250220112822929"></p><h3 id="面试官：BeanFactory和FactoryBean有什么区别？"><a href="#面试官：BeanFactory和FactoryBean有什么区别？" class="headerlink" title="面试官：BeanFactory和FactoryBean有什么区别？"></a><strong>面试官</strong>：BeanFactory和FactoryBean有什么区别？</h3><p><strong>候选人</strong>：</p><p>1）BeanFactory是IoC容器，在程序启动时根据传入参数产生各种类型的bean，并添加到IoC容器的<strong>singletonObject</strong>属性中。</p><p>2）FactoryBean是个bean，存放在BeanFactory当中，在程序运行中产生指定类型的bean，并添加到IoC容器的factoryBeanObjectCache（缓存）当中。</p><blockquote><p>当你定义了一个 FactoryBean，Spring 通过它来创建真正的 bean，而不是将 FactoryBean 本身作为 bean 提供。</p></blockquote><h3 id="面试官：-Autowired-和-Resource-的区别是什么？"><a href="#面试官：-Autowired-和-Resource-的区别是什么？" class="headerlink" title="面试官：@Autowired 和 @Resource 的区别是什么？"></a><strong>面试官</strong>：@Autowired 和 @Resource 的区别是什么？</h3><p><strong>候选人</strong>：</p><ul><li><p><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</p></li><li><p><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</p></li><li><p>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过<strong>名称</strong>才能正确匹配到对应的 Bean。<code>@Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显示指定名称。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure><h3 id="面试官：-Spring-Bean-默认是单例的，如何保证并发安全"><a href="#面试官：-Spring-Bean-默认是单例的，如何保证并发安全" class="headerlink" title="面试官： Spring Bean 默认是单例的，如何保证并发安全?"></a><strong>面试官：</strong> Spring Bean 默认是单例的，如何保证并发安全?</h3><p><strong>候选人：</strong></p><p>Spring 的 Bean 默认都是单例的，某些情况下，单例是并发不安全的，以 <code>Controller</code> 举例，问题根源在于，我们可能会在 <code>Controller</code> 中定义成员变量，如此一来，多个请求来临，进入的都是同一个单例的 <code>Controller</code> 对象，并对此成员变量的值进行修改操作，因此会互相影响，无法达到并发安全（不同于线程隔离的概念，后面会解释到）的效果。</p><p>首先来举个例子，证明单例的并发不安全性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;testsingleton1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次访问此 url，可以看到每次的结果都是自增的，所以这样的代码显然是并发不安全的。</p><p>我们为了让无状态的海量 HTTP 请求之间不受影响，我们可以采取以下几种措施：</p><h4 id="1、单例变原型"><a href="#1、单例变原型" class="headerlink" title="1、单例变原型"></a><strong>1、单例变原型</strong></h4><p>对 web 项目，可以 <code>Controller</code> 类上加注解 <code>@Scope(&quot;prototype&quot;)</code> 或 <code>@Scope(&quot;request&quot;)</code>，</p><p>对非 web 项目，在 <code>Component</code> 类上添加注解 <code>@Scope(&quot;prototype&quot;)</code> 。</p><p>这种方式实现起来非常简单，但是很大程度上<strong>增大了 Bean 创建实例化销毁的服务器资源开销</strong>。</p><h4 id="2、尽量避免使用成员变量"><a href="#2、尽量避免使用成员变量" class="headerlink" title="2、尽量避免使用成员变量"></a><strong>2、尽量避免使用成员变量</strong></h4><p>有人说，单例 Bean 的成员变量这么麻烦，能不用成员变量就尽量避免这么用，在业务允许的条件下，将成员变量替换为方法中的局部变量，多省事。这种方式自然是最恰当的。代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;testsingleton1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// TODO biz code</span></span><br><span class="line">         <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但当很少的某种情况下，必须使用成员变量呢，我们该怎么处理？</p><h4 id="3、使用并发安全的容器"><a href="#3、使用并发安全的容器" class="headerlink" title="3、使用并发安全的容器"></a><strong>3、使用并发安全的容器</strong></h4><p>Java 作为功能性超强的编程语言，API 丰富，如果非要在单例 Bean 中使用成员变量，可以考虑使用并发安全的容器，如 <code>ConcurrentHashMap</code>、<code>ConcurrentHashSet</code> 等等。</p><h4 id="4、分布式或微服务的并发安全"><a href="#4、分布式或微服务的并发安全" class="headerlink" title="4、分布式或微服务的并发安全"></a><strong>4、分布式或微服务的并发安全</strong></h4><p>如果还要进一步考虑到微服务或分布式服务的影响，方式 4 便不足以处理了，所以可以借助于可以共享某些信息的分布式缓存中间件如 Redis 等，这样即可保证同一种服务的不同服务实例都拥有同一份共享信息（如当前运行中的任务列表等这类变量）。</p><h3 id="面试官：谈谈⾃⼰对于-Spring-IoC-和-AOP-的理解（高频）"><a href="#面试官：谈谈⾃⼰对于-Spring-IoC-和-AOP-的理解（高频）" class="headerlink" title="面试官：谈谈⾃⼰对于 Spring IoC 和 AOP 的理解（高频）"></a><strong>面试官</strong>：谈谈⾃⼰对于 Spring IoC 和 AOP 的理解<code>（高频）</code></h3><p><strong>候选人</strong>：</p><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>IoC（Inverse of Control：控制反转）是⼀种<strong>设计思想</strong>，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 容器实际上就是个Map（key，value），Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。</p><p> <strong>IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</strong> 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP是<strong>面向切面编程</strong>，在spring中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为<code>公共日志保存</code>，<code>事务处理</code>等。</p><p>Spring AOP 主要依赖<strong>动态代理</strong>来实现，接下来我会讲述 Spring AOP 的执行流程，主要分为六步。</p><p>当 Spring AOP 拦截一个方法调用时：</p><p>第一步是要<strong>定义切面（Aspect）</strong>，可以使用 <code>@Aspect</code> 标注类，并在其中定义切点（Pointcut）和通知（Advice），如 @Before、@After、@Around 等。</p><p>第二步是要<strong>解析切点</strong>，Spring 会解析 <code>@Pointcut</code> 表达式，确定需要增强的方法。</p><p>第三步是要<strong>创建代理对象</strong>，如果目标类实现了接口，Spring 使用 <strong>JDK 动态代理</strong>，通过 <code>Proxy.newProxyInstance</code> 生成代理对象；如果目标类没有实现接口，Spring 使用 <strong>CGLIB 动态代理</strong>，通过创建目标类的子类来生成代理对象。</p><p>第四步是要<strong>方法调用拦截</strong>，如果是JDK 动态代理，代理对象会拦截方法调用，并调用invoke，执行增强逻辑后，再调用目标方法；如果是CGLIB 动态代理，代理对象则通过 intercept 代理方法调用，执行增强逻辑后，再调用目标方法。</p><p>第五步是要<strong>执行增强逻辑</strong>，根据通知类型，在方法执行前后或异常时，执行对应的 AOP 逻辑，如日志记录、事务提交等。</p><p>第六步是要<strong>执行目标方法</strong>，最终调用目标对象的方法，完成实际业务逻辑。</p><p><img src="https://pic1.imgdb.cn/item/67e1253b0ba3d5a1d7e295ad.png" alt="Comparison and application of Spring AOP and AspectJ - Spring Cloud"></p><h3 id="面试官：-什么是动态代理？（高频）"><a href="#面试官：-什么是动态代理？（高频）" class="headerlink" title="面试官： 什么是动态代理？（高频）"></a><strong>面试官：</strong> 什么是动态代理？<code>（高频）</code></h3><p>动态代理是一种在运行时动态生成代理对象，并在代理对象中增强目标对象方法的技术。它被广泛用于 AOP（面向切面编程）、权限控制、日志记录等场景，使得程序更加灵活、可维护。动态代理可以通过 JDK 原生的 Proxy 机制或 CGLIB 方式实现。接下来我会讲述动态代理的实现方式和执行流程。</p><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>首先，<strong>JDK 动态代理</strong>基于接口，适用于代理实现了接口的对象，当使用 JDK 动态代理时，主要分为四步，</p><p>第一步是<strong>定义接口</strong>，由于动态代理是基于接口进行代理的，因此目标对象必须实现接口。</p><p>第二步是<strong>创建并实现 InvocationHandler 接口</strong>，并在 invoke 方法中定义增强逻辑。</p><p>第三步是<strong>生成代理对象</strong>，使用 Proxy.newProxyInstance 创建代理对象，代理对象内部会调用 invoke 方法。</p><p>第四步是<strong>调用代理方法</strong>，当调用代理对象的方法时，invoke 方法会被触发，执行增强逻辑，并最终调用目标方法。</p><h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h4><p>其次，<strong>CGLIB</strong> 通过子类继承目标类，适用于没有实现接口的类，当使用 CGLIB 动态代理时，主要分为四步，</p><p>第一步是通过 Enhancer <strong>创建代理对象</strong>。</p><p>第二步是<strong>设置父类</strong>，CGLIB 代理基于子类继承，因此代理对象是目标类的子类。</p><p>第三步是<strong>定义并实现 MethodInterceptor 接口</strong>，在 intercept 方法中增强目标方法。</p><p>第四步是<strong>调用代理方法</strong>，当调用代理对象的方法时，intercept 方法会被触发，执行增强逻辑，并最终调用目标方法。</p><h3 id="面试官：-动态代理和静态代理的区别（高频）"><a href="#面试官：-动态代理和静态代理的区别（高频）" class="headerlink" title="面试官： 动态代理和静态代理的区别（高频）"></a><strong>面试官：</strong> 动态代理和静态代理的区别<code>（高频）</code></h3><p>动态代理和静态代理都属于代理模式，它们都用于在不修改目标对象代码的情况下增强其功能。接下来我会详细讲述动态代理和静态代理的五点区别。</p><p>第一点是<strong>实现方式</strong>的不同，静态代理需要手动编写代理类，而动态代理在运行时动态生成代理类。</p><p>第二点是<strong>灵活性</strong>的不同，静态代理不够灵活，代理类与目标类一一对应；而动态代理更加灵活，适用于多种目标类。</p><p>第三点是<strong>维护成本</strong>的不同，静态代理的维护成本较高，因为每个目标类都需要一个代理类；而动态代理的维护成本较低，因为代理逻辑是通用的。</p><p>第四点是<strong>技术依赖</strong>的不同，静态代理基于普通 Java 类；动态代理依赖反射或字节码技术。</p><p>第五点是<strong>适用场景</strong>的不同，静态代理则适用于简单的、目标类较少的场景；而动态代理适合需要为多个目标类添加相同逻辑的场景。</p><h3 id="面试官：将⼀个类声明为Spring的-bean-的注解有哪些"><a href="#面试官：将⼀个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="面试官：将⼀个类声明为Spring的 bean 的注解有哪些?"></a><strong>面试官</strong>：将⼀个类声明为Spring的 bean 的注解有哪些?</h3><p><strong>候选人</strong>：</p><p>我们⼀般使⽤ <code>@Autowired</code> 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现：</p><ol><li><p><code>@Component</code> ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。</p></li><li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要⽤于数据库相关操作。</p></li><li><p><code>@Service</code> : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。</p></li><li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯。</p></li></ol><h3 id="面试官：Spring中事务失效的场景有哪些（高频）"><a href="#面试官：Spring中事务失效的场景有哪些（高频）" class="headerlink" title="面试官：Spring中事务失效的场景有哪些（高频）"></a><strong>面试官</strong>：Spring中事务失效的场景有哪些<code>（高频）</code></h3><p><strong>候选人</strong>：<a href="https://blog.csdn.net/weixin_74199893/article/details/137992711?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522F5257AA1-4F50-4779-BD73-4A87810B06F3%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=F5257AA1-4F50-4779-BD73-4A87810B06F3&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-137992711-null-null.nonecase&utm_term=%E5%A4%B1%E6%95%88&spm=1018.2226.3001.4450">见文章：详解Spring事务失效的八种常见场景</a></p><p>第一个，如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了抛出去就行。</p><p>第二个，如果事务方法内部抛出了 <strong>运行时异常（RuntimeException）</strong>，Spring 会默认回滚事务。如果抛出了 <strong>受检查异常（Checked Exception）</strong>，Spring 默认不会回滚事务，除非使用 <code>@Transactional(rollbackFor = Exception.class)</code> 明确指定应当回滚受检查异常。</p><p>第三个，如果方法上不是public修饰的，也会导致事务失效。为了解决这个问题，我们需要将事务方法的访问修饰符改为public即可。</p><p>第四个，当方法内部通过 <strong>this</strong> 调用事务也会失败，需要通过上下文获取代理对象才能重启事务。</p><p>第五个，同一个Service类中非事务方法调用了事务性的方法，也会导致事务失效。解决方法：确保所有涉及数据库操作的方法都被<code>@Transactional</code>注解修饰。</p><p>第六个，当使用不支持事务的数据库引擎时，例如 MySQL 的 <strong>MyISAM</strong> 引擎不支持事务，即使代码中配置了事务管理，也无法生效。因此，确保使用的数据库引擎（如 <strong>InnoDB</strong>）支持事务是非常重要的。</p><h3 id="面试官：Spring的bean的生命周期（高频）"><a href="#面试官：Spring的bean的生命周期（高频）" class="headerlink" title="面试官：Spring的bean的生命周期（高频）"></a><strong>面试官</strong>：Spring的bean的生命周期<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>首先会通过一个非常重要的类，叫做<strong>BeanDefinition</strong>获取bean的定义信息，这里面就封装了bean的所有信息。在创建bean的时候：</p><p>第一步是调用构造函数实例化bean</p><p>第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成</p><p>第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行</p><p>第四步是执行了bean的前置处理器BeanPostProcessor对象的<strong>postProcessBeforeInitialization()</strong> ⽅法</p><p>第五步是初始化方法，比如实现了接口InitializingBean或者自定义init方法</p><p>第六步是执行了bean的后置处理器BeanPostProcessor对象的<strong>postProcessAfterInitialization()</strong> ⽅法，主要是对bean进行增强，有可能在这里产生<strong>代理对象</strong></p><p>最后一步是销毁bean</p><p><img src="https://pic1.imgdb.cn/item/67e125440ba3d5a1d7e295b3.png" alt="如何记忆Spring Bean的生命周期- 草捏子"></p><h3 id="面试官：Spring中的循环引用"><a href="#面试官：Spring中的循环引用" class="headerlink" title="面试官：Spring中的循环引用"></a><strong>面试官</strong>：Spring中的循环引用</h3><p><strong>候选人</strong>：</p><p>循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于A。</p><p>循环依赖在spring中是允许存在，spring框架依据<strong>三级缓存</strong>已经解决了<code>大部分</code>的循环依赖问题：</p><p>①一级缓存：单例池，缓存（已经经历了完整的生命周期，已经初始化完成的）bean对象</p><p>②二级缓存：缓存早期的bean对象（生命周期还没走完）</p><p>③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p><h3 id="面试官：那具体解决流程清楚吗？"><a href="#面试官：那具体解决流程清楚吗？" class="headerlink" title="面试官：那具体解决流程清楚吗？"></a><strong>面试官</strong>：那具体解决流程清楚吗？</h3><p><strong>候选人</strong>：</p><p>第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第二，A在初始化的时候需要B对象，这个走B的创建的逻辑</p><p>第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键</p><p>第五，B通过从通过二级缓存earlySingletonObjects  获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects  </p><p>第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一级缓存singletonObjects </p><p>第七，二级缓存中的临时对象A清除 </p><p><img src="https://pic1.imgdb.cn/item/67e1254c0ba3d5a1d7e295b6.png" alt="image-20250220131739478"></p><h3 id="面试官：构造方法出现了循环依赖怎么解决？"><a href="#面试官：构造方法出现了循环依赖怎么解决？" class="headerlink" title="面试官：构造方法出现了循环依赖怎么解决？"></a><strong>面试官</strong>：构造方法出现了循环依赖怎么解决？</h3><p><strong>候选人</strong>：</p><p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入，可以使用<code>@Lazy</code>懒加载，什么时候需要对象再进行bean对象的创建。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@lazy</span> B b)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：SpringMVC的执行流程知道嘛（高频）"><a href="#面试官：SpringMVC的执行流程知道嘛（高频）" class="headerlink" title="面试官：SpringMVC的执行流程知道嘛（高频）"></a><strong>面试官</strong>：SpringMVC的执行流程知道嘛<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p><img src="https://pic1.imgdb.cn/item/67e125550ba3d5a1d7e295b8.png" alt="image-20250220131759779"></p><p>1、用户发送出请求到前端控制器DispatcherServlet，这是一个调度中心</p><p>2、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。</p><p>3、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p><p>4、DispatcherServlet调用HandlerAdapter（处理器适配器）。</p><p>5、HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）。</p><p>6、Controller执行完成返回ModelAndView对象。</p><p>7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</p><p>8、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。</p><p>9、ViewReslover解析后返回具体View（视图）。</p><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p><p>11、DispatcherServlet响应用户。</p><p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接返回结果。</p><h3 id="面试官：-和-的区别是什么？（高频）"><a href="#面试官：-和-的区别是什么？（高频）" class="headerlink" title="面试官：#{ }和${ }的区别是什么？（高频）"></a><strong>面试官</strong>：#{ }和${ }的区别是什么？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ol><li><p>符号类型</p><p><strong>#{ }</strong>：参数占位符，即预编译，对传入参数自动加单引号</p><p><strong>${ }</strong>：字符串替换符，即SQL拼接，对传入参数不加任何引号</p><blockquote><p><code>预编译（Prepared Statement）</code>是指将SQL语句模板提前编译为可执行计划，参数（如用户输入）在运行时绑定。这样可以避免SQL注入，并提高重复执行的效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PREPARE</span> stmt <span class="keyword">FROM</span> <span class="string">&#x27;SELECT * FROM users WHERE id = ?&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> stmt <span class="keyword">USING</span> <span class="variable">@id</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>防止注入问题</p><p><strong>#{ }</strong>：能防止SQl注入</p><p><strong>${ }</strong>：不能防止SQL注入</p></li><li><p>sql执行过程</p><p><strong>#{ }</strong>：先编译再取值</p><p><strong>${ }</strong>：先取值后编译</p></li><li><p>MyBatis排序时使用order by用${ }而不是#{ }</p></li><li><p>使用场景</p><p><strong>大部分情况下</strong>，特别是传入的值为用户输入、动态条件时，推荐使用 <code>#&#123; &#125;</code> 进行参数绑定。它能有效防止 SQL 注入，并且让代码更安全和简洁。</p><p><strong>表名、列名的动态拼接</strong>：这些不能作为参数绑定的元素，只能使用 <code>$&#123; &#125;</code> 进行拼接。<strong>拼接 SQL 片段</strong>：在一些复杂 SQL 语句（比如动态构造的 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句）中，可以使用 <code>$&#123; &#125;</code> 直接拼接。</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 插入用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO users (username, password, email) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 更新用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">    UPDATE users SET password = #&#123;password&#125; WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据动态表名查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRecordsByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Record&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM $&#123;tableName&#125; WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态列名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserOrderByColumn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users ORDER BY $&#123;columnName&#125; ASC</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态 SQL 片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsersWithConditions&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users</span><br><span class="line">    WHERE 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">        AND age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">        AND gender = #&#123;gender&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    ORDER BY $&#123;sortColumn&#125; $&#123;sortOrder&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="面试官：SpringBoot-是如何实现自动装配的？（高频）"><a href="#面试官：SpringBoot-是如何实现自动装配的？（高频）" class="headerlink" title="面试官：SpringBoot 是如何实现自动装配的？（高频）"></a><strong>面试官</strong>：SpringBoot 是如何实现自动装配的？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>在SpringBoot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是：</p><ul><li><code>@SpringBootConfiguration</code>：这也是一个配置类</li><li><code>@EnableAutoConfiguration</code>：springboot实现自动装配的<strong>核心注解</strong></li><li><code>@ComponentScan</code>: 组件扫描</li></ul><p>其中**@EnableAutoConfiguration**是实现自动装配的核心注解。</p><p>它通过 <code>@Import</code> 注解来导入一个特殊的配置类，这个配置类会读取项目及其依赖库中的 <code>META-INF/spring.factories</code> 文件里定义的自动配置类，并将它们注册到 Spring 容器中。</p><p>在这些配置类中所定义的Bean会根据<strong>条件注解</strong>所指定的条件决定是否需要将其导入到Spring容器中。</p><h3 id="面试官：Spring-的常见注解有哪些？"><a href="#面试官：Spring-的常见注解有哪些？" class="headerlink" title="面试官：Spring 的常见注解有哪些？"></a><strong>面试官</strong>：Spring 的常见注解有哪些？</h3><p><strong>候选人</strong>：</p><p>第一类是：声明bean，有 <strong>@Component、@Service、@Repository、@Controller</strong></p><p>第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse</p><p>第三类是：设置作用域 @Scope（singleton、prototype, request, session, global-session等）</p><p>第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和 @Bean </p><p>第五类是：跟aop相关做增强的注解  @Aspect，@Before，@After，@Around，@Pointcut</p><h3 id="面试官：SpringMVC常见的注解有哪些？"><a href="#面试官：SpringMVC常见的注解有哪些？" class="headerlink" title="面试官：SpringMVC常见的注解有哪些？"></a><strong>面试官</strong>：SpringMVC常见的注解有哪些？</h3><p><strong>候选人</strong>：</p><p>@RequestMapping：用于映射请求路径；</p><p><code>@RequestBody：</code>注解实现接收http请求的json数据，<strong>将json转换为java对象</strong>；</p><p>@RequestParam：指定请求参数的名称；</p><p><code>@PathViriable：</code>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数；</p><p><code>@ResponseBody：</code>注解实现将controller方法返回对象转化为指定类型对象响应给客户端。</p><p>@RequestHeader：获取指定的请求头数据，还有像@PostMapping、@GetMapping这些。</p><h3 id="面试官：MyBatis执行流程"><a href="#面试官：MyBatis执行流程" class="headerlink" title="面试官：MyBatis执行流程"></a><strong>面试官</strong>：MyBatis执行流程</h3><p><strong>候选人</strong>：</p><p>①读取MyBatis配置文件（mybatis-config.xml） ，加载运行环境和映射文件</p><p>②构造会话工厂SqlSessionFactory，一个项目只需要一个，单例的，一般由spring进行管理</p><p>③会话工厂创建SqlSession对象，这里面就含了执行SQL语句的所有方法</p><p>④操作数据库的接口，Executor执行器，同时负责查询缓存的维护</p><p>⑤Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</p><p>⑥输入参数映射</p><p>⑦输出结果映射</p><h3 id="面试官：MyBatis分⻚插件的原理是什么？"><a href="#面试官：MyBatis分⻚插件的原理是什么？" class="headerlink" title="面试官：MyBatis分⻚插件的原理是什么？"></a><strong>面试官</strong>：MyBatis分⻚插件的原理是什么？</h3><p><strong>候选人</strong>：</p><p>分⻚插件的基本原理是使⽤ Mybatis 提供的插件接⼝，实现⾃定义插件，在插件的拦截⽅法内拦截待执⾏的 sql，然后重写 sql，根据 dialect ⽅⾔，添加对应的物理分⻚语句和物理分⻚参数。</p><p>举例： <code>select _ from student</code> ，拦截 sql 后重写为： <code>select t._ from student t limit 0 10</code></p><h3 id="面试官：Mybatis是否支持延迟加载？"><a href="#面试官：Mybatis是否支持延迟加载？" class="headerlink" title="面试官：Mybatis是否支持延迟加载？"></a><strong>面试官</strong>：Mybatis是否支持延迟加载？</h3><p><strong>候选人</strong>：</p><p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p><p>Mybatis 仅⽀持 <strong>association 关联对象</strong>和 <strong>collection 关联集合对象</strong>的延迟加载，association 指的就是⼀对⼀，collection 指的就是⼀对多查询。</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载，默认是关闭的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazyLoadingEnabled=true|false</span><br></pre></td></tr></table></figure><h3 id="面试官：延迟加载的底层原理知道吗？"><a href="#面试官：延迟加载的底层原理知道吗？" class="headerlink" title="面试官：延迟加载的底层原理知道吗？"></a><strong>面试官</strong>：延迟加载的底层原理知道吗？</h3><p><strong>候选人</strong>：</p><p>延迟加载在底层主要使用的<strong>CGLIB动态代理</strong>完成的。</p><p>第一是，使用CGLIB创建目标对象的代理对象。</p><p>第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值（第一次延迟加载肯定为空），再执行sql查询。</p><p>第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了。</p><h3 id="面试官：Mybatis的一级、二级缓存用过吗？"><a href="#面试官：Mybatis的一级、二级缓存用过吗？" class="headerlink" title="面试官：Mybatis的一级、二级缓存用过吗？"></a><strong>面试官</strong>：Mybatis的一级、二级缓存用过吗？</h3><p><strong>候选人</strong>：</p><p>MyBatis的一级缓存基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。</p><blockquote><p><strong>PerpetualCache</strong>：持久化的缓存接口PerpetualCache，其内部实现是一个HashMap，用于存储查询结果。</p></blockquote><p>关于二级缓存需要单独开启：</p><p>二级缓存是基于Namespace和Mapper的作用域起作用的，不是依赖于Session，默认也是采用 PerpetualCache的HashMap 存储。</p><p>如果想要开启二级缓存需要在<strong>全局配置文件</strong>和<strong>映射文件</strong>中开启配置才行。</p><h3 id="面试官：Mybatis的二级缓存什么时候会清理缓存中的数据"><a href="#面试官：Mybatis的二级缓存什么时候会清理缓存中的数据" class="headerlink" title="面试官：Mybatis的二级缓存什么时候会清理缓存中的数据"></a><strong>面试官</strong>：Mybatis的二级缓存什么时候会清理缓存中的数据</h3><p><strong>候选人</strong>：</p><p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h3 id="相关阅读：手写SSM、手写SpringBoot"><a href="#相关阅读：手写SSM、手写SpringBoot" class="headerlink" title="相关阅读：手写SSM、手写SpringBoot"></a>相关阅读：<a href="https://blog.csdn.net/weixin_74199893/category_12663760.html?spm=1001.2014.3001.5482">手写SSM、手写SpringBoot</a></h3>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE相关面试题</title>
      <link href="/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h3 id="面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）"><a href="#面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）" class="headerlink" title="面试官： 面向对象(OOP)和面向过程(POP)的区别（高频）"></a><strong>面试官</strong>： 面向对象(OOP)和面向过程(POP)的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>⾯向过程</strong> ：<strong>⾯向过程性能⽐⾯向对象⾼。</strong> ⽐如单⽚机、嵌⼊式开发、Linux&#x2F;Unix 等⼀般采⽤⾯向过程开发。以函数为中心，强调逻辑流程。</p></li><li><p><strong>⾯向对象</strong> ：<strong>⾯向对象易维护、易复⽤、易扩展。</strong> 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>⾯向对象性能⽐⾯向过程低</strong>。以对象为中心，强调数据和行为的封装。</p></li></ul><blockquote><p>拓展：为什么⾯向过程性能⽐⾯向对象⾼？</p><p>⾯向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是⾯向对象语⾔，⽽是 Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的⼆进制机械码。⽽⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏。</p></blockquote><hr><h3 id="面试官：Java的基本数据类型"><a href="#面试官：Java的基本数据类型" class="headerlink" title="面试官：Java的基本数据类型"></a><strong>面试官</strong>：Java的基本数据类型</h3><p><strong>候选人：</strong> Java 语言一共提供了八种原始的数据类型(byte、short、int、long、float、double、char、boolean)。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png" alt="img"></p><p>以上这些基本类型可以分为如下三种类型：</p><p>1）数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</p><p>2）字符型：char</p><p>3）布尔型：boolean</p><p>8种基本数据类型的默认值、位数、取值范围，如下表所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="img"></p><hr><h3 id="面试官：说说JVM-、-JDK-和-JRE的区别？"><a href="#面试官：说说JVM-、-JDK-和-JRE的区别？" class="headerlink" title="面试官：说说JVM 、 JDK 和 JRE的区别？"></a><strong>面试官</strong>：说说JVM 、 JDK 和 JRE的区别？</h3><p><strong>候选人：</strong></p><ul><li><strong>Java Virtual Machine（JVM）</strong> 是运⾏ Java 字节码的虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li></ul><blockquote><p>拓展：什么是字节码?采⽤字节码的好处是什么?</p><p>在 Java 中，JVM 可以理解的代码就叫做  （即扩展名为 .class 的⽂件），它<strong>不⾯向任何特定的处理器，只⾯向虚拟机</strong>。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔<strong>执⾏效率低</strong>的问题，同时⼜保留了解释型语⾔<strong>可移植</strong>的特点。</p></blockquote><ul><li><strong>Java Runtime Environment（JRE）</strong> 包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包。</li><li><strong>Java Development Kit（JDK）</strong> 是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等。</li></ul><p><img src="https://pic1.imgdb.cn/item/67e102c388c538a9b5c5a6e8.png" alt="img"></p><hr><h3 id="面试官：Java-程序从源代码到运⾏分为哪几步？"><a href="#面试官：Java-程序从源代码到运⾏分为哪几步？" class="headerlink" title="面试官：Java 程序从源代码到运⾏分为哪几步？"></a><strong>面试官</strong>：Java 程序从源代码到运⾏分为哪几步？</h3><p><strong>候选人：</strong> Java程序从源代码到运⾏⼀般有下⾯3步：</p><p><img src="https://pic1.imgdb.cn/item/67e102d788c538a9b5c5a6ec.png" alt="image-20250218110538905"></p><p>我们需要格外注意的是 <strong>.class-&gt;机器码</strong> 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过解释器逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的<strong>热点代码</strong>)，所以后⾯引进了 <strong>JIT 编译器</strong>，⽽ JIT 属于<strong>运⾏时编译</strong>。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。这也解释了我们为什么经常会说 Java 是编译与解释共存的语⾔。</p><hr><h3 id="面试官：Java和C-的区别"><a href="#面试官：Java和C-的区别" class="headerlink" title="面试官：Java和C++的区别"></a><strong>面试官</strong>：Java和C++的区别</h3><p><strong>候选人：</strong></p><ul><li>都是面向对象的语言，都支持封装、继承和多态。</li><li>Java不提供指针来直接访问内存，程序内存更加安全。</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以有多个实现类。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存。</li><li>在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符‘\0’来表示结束。但是，Java 语⾔中没有结束符这⼀概念。</li></ul><blockquote><p>深度思考：</p><p>在C语言中，字符串是以空字符（’\0’）结尾的字符数组。这种设计的好处是简单直接，但缺点是在访问字符串时每次都需要检查空字符来确定字符串的长度，这可能会导致额外的计算开销。在Java中，字符串是一个类（<code>String</code>），它包含了字符串的值以及其长度信息。这种设计使得字符串的长度可以在创建时确定，并且可以通过内置的方法（如<code>length()</code>）轻松获取。这种方法提高了效率，减少了因字符串处理不当而导致的安全隐患。</p></blockquote><hr><h3 id="面试官：-什么是序列化-什么是反序列化"><a href="#面试官：-什么是序列化-什么是反序列化" class="headerlink" title="面试官： 什么是序列化?什么是反序列化?"></a><strong>面试官</strong>： 什么是序列化?什么是反序列化?</h3><p><strong>候选人：</strong></p><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>：将<strong>数据结构或对象</strong>转换成可以存储或传输的形式，通常是<strong>二进制字节流</strong>，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为<strong>原始数据结构或者对象</strong>的过程</li></ul><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到 <strong>数据库（如 Redis）</strong> 之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p><img src="https://pic1.imgdb.cn/item/67e1030a88c538a9b5c5a6fa.png" alt="image-20250218110611282"></p><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><hr><h3 id="面试官：-重载和重写的区别（高频）"><a href="#面试官：-重载和重写的区别（高频）" class="headerlink" title="面试官： 重载和重写的区别（高频）"></a><strong>面试官</strong>： 重载和重写的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>重载（编译时多态）是同一个类中方法之间的关系，是水平关系。</p><p>重写（运行时多态）是子类和父类之间的关系，是垂直关系。</p><p><img src="https://pic1.imgdb.cn/item/67e1030f88c538a9b5c5a700.png" alt="image-20250218110611282"></p><hr><h3 id="面试官：面向对象的特征有哪些方面？（高频）"><a href="#面试官：面向对象的特征有哪些方面？（高频）" class="headerlink" title="面试官：面向对象的特征有哪些方面？（高频）"></a><strong>面试官</strong>：面向对象的特征有哪些方面？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。<strong>继承是多态的前提。</strong></p><blockquote><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol></blockquote><p><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。例如，如果父类 Animal 有一个 <code>makeSound()</code> 方法，子类 Dog 和 Cat 可以分别重写这个方法，当调用 <code>animal.makeSound()</code> 时，具体执行的是 Dog 或 Cat 的实现。</p><hr><h3 id="面试官：面向对象的设计原则你知道有哪些吗"><a href="#面试官：面向对象的设计原则你知道有哪些吗" class="headerlink" title="面试官：面向对象的设计原则你知道有哪些吗"></a><strong>面试官</strong>：面向对象的设计原则你知道有哪些吗</h3><p><strong>候选人：</strong> 面向对象编程中的五大原则:</p><ul><li><strong>单一职责原则(SRP)</strong>:一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子:考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li><li><strong>开放封闭原则(OCP)</strong>:软件实体应该对扩展开放，对修改封闭。例子:通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li><li><strong>里氏替换原则(LSP)</strong>:子类对象应该能够替换掉所有父类对象。例子:一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li><li><strong>接口隔离原则(ISP)</strong> :客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子:通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li><li><strong>依赖倒置原则(DIP)</strong>:高层模块不应该依赖低层模块，二者都应该依赖于抽象;抽象不应该依赖于细节，细节应该依赖于抽象。例子:如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类。</li></ul><hr><h3 id="面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）"><a href="#面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）" class="headerlink" title="面试官： String 、StringBuffer 和 StringBuilder 的区别是什么?（高频）"></a><strong>面试官</strong>： String 、StringBuffer 和 StringBuilder 的区别是什么?<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>可变性：</strong></p><ul><li><p>String对象是不可变类，也就是说String对象一旦被创建，其值将不能被改变。String 类中使⽤ <code>final</code> 关键字修饰字符数组来保存字符串， <code>private final char[] value</code> ，所以 String 对象是不可变的。</p><blockquote><p>拓展：在 Java 9 之后，String 类的实现改⽤ byte 数组存储字符串</p><p><strong>private final byte[] value</strong></p></blockquote></li><li><p>StringBuilder 与 StringBuffer 都继承⾃ <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使⽤字符数组保存字符串 <code>char[] value</code> 但是没有⽤ <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>线程安全性</strong>：</p><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>StringBuffer 对<code>AbstractStringBuilder</code>⽅法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对⽅法加同步锁，线程不安全。</li></ul><p><strong>性能</strong>：</p><ul><li><p>每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象。性能最好。</p></li><li><p>StringBuffer 每次都会对<strong>对象本身</strong>进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。性能最差。</p></li><li><p>相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 <strong>10%~15%</strong> 左右的性能提升，但却要冒多线程不安全的⻛险。(如下)</p></li></ul><p><strong>实例化&#x2F;初始化：</strong></p><blockquote><p>《Java程序员面试笔试宝典》第二版 1.18节</p><p>当实例化String的时候，可以利用构造方法（String s1 &#x3D; new String(“world”)）的方式来对其初始化，也可以使用赋值（String s1 &#x3D; “Hello”）的方式来初始化，而StringBuffer和StringBuilder只能使用构造方法（StringBuffer s &#x3D; new StringBuffer(“world”)）的方式来初始化。</p></blockquote><p><strong>在频繁字符串拼接或修改情况下：</strong></p><p>String 字符串修改实现的原理为：当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuilder，然后调用 StingBuilder 的append 方法，最后调用 StingBuilder 的 toString方法把结果返回。举例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码等价于下述代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">s.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">s = sb.toString();</span><br></pre></td></tr></table></figure><p>由此可以看出，上述过程比使用 StingBuilder 多了一些附加的操作，同时也生成了一些临时的对象，导致程序的执行效率降低。</p><p><strong>对于三者使⽤的总结：</strong></p><ol><li>操作少量的数据: 适⽤ String</li><li><strong>单线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li><strong>多线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ol><hr><h3 id="面试官：接⼝和抽象类的区别是什么？（高频）"><a href="#面试官：接⼝和抽象类的区别是什么？（高频）" class="headerlink" title="面试官：接⼝和抽象类的区别是什么？（高频）"></a><strong>面试官</strong>：接⼝和抽象类的区别是什么？<code>（高频）</code></h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">参数</th><th align="center">抽象类（从属关系is-a）</th><th align="center">接口（特定功能的实现has-a）</th></tr></thead><tbody><tr><td align="center">声明</td><td align="center">抽象类使用abstract关键字声明</td><td align="center">接口使用interface关键字声明</td></tr><tr><td align="center">实现</td><td align="center">子类使用extends关键字来继承抽象类</td><td align="center">子类使用implements关键字来实现接口</td></tr><tr><td align="center">构造器</td><td align="center">抽象类可以有构造器</td><td align="center">接口不能有构造器</td></tr><tr><td align="center">访问修饰符</td><td align="center">抽象类中的方法可以是任意访问修饰符</td><td align="center">接口方法默认修饰符是public。并且不允许定义为private 或者 protected</td></tr><tr><td align="center">多继承</td><td align="center">一个类最多只能继承一个抽象类</td><td align="center">一个类可以实现多个接口</td></tr><tr><td align="center">字段声明</td><td align="center">抽象类的字段声明可以是任意的</td><td align="center">接口的字段默认都是 static 和 final 的</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sparrow</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating seeds.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="面试官：成员变量与局部变量的区别有哪些？"><a href="#面试官：成员变量与局部变量的区别有哪些？" class="headerlink" title="面试官：成员变量与局部变量的区别有哪些？"></a><strong>面试官</strong>：成员变量与局部变量的区别有哪些？</h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">属性</th><th align="center">成员变量</th><th align="center">局部变量</th></tr></thead><tbody><tr><td align="center"><strong>作用域</strong></td><td align="center">针对整个类有效</td><td align="center">只在某个范围内有效，通常在方法或语句体内</td></tr><tr><td align="center"><strong>存储位置</strong></td><td align="center">随着对象的创建而存在，存储在堆内存中</td><td align="center">在方法被调用或语句被执行的时候存在，存储在栈内存中</td></tr><tr><td align="center"><strong>生命周期</strong></td><td align="center">随着对象的创建而存在，随着对象的消失而消失</td><td align="center">当方法调用完，或者语句结束后，就自动释放</td></tr><tr><td align="center"><strong>初始值</strong></td><td align="center">有默认初始值，如数字类型为0，布尔类型为false，引用类型为null</td><td align="center">没有默认初始值，使用前必须显式赋值</td></tr><tr><td align="center"><strong>使用原则</strong></td><td align="center">就近原则（首先在局部范围找，有就使用；接着在成员位置找）</td><td align="center">就近原则</td></tr></tbody></table><hr><h3 id="面试官：-什么是自动拆箱-装箱？（高频）"><a href="#面试官：-什么是自动拆箱-装箱？（高频）" class="headerlink" title="面试官： 什么是自动拆箱&#x2F;装箱？（高频）"></a><strong>面试官：</strong> 什么是自动拆箱&#x2F;装箱？<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p>自动装箱是指将基本数据类型（如 int、double、boolean 等）自动转换为对应的包装类对象（如 Integer、Double、Boolean 等）。这个过程由<strong>编译器</strong>自动完成，当存储一个基本数据类型到需要用到对象的场景中(例如集合)，Java 编译器会检测到基本数据类型需要被转换为包装类对象，编译器会自动调用包装类的 <code>valueOf()</code> 方法来创建对应的包装类对象，生成的对象会被存储到目标位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> Integer.valueOf(num);</span><br></pre></td></tr></table></figure></li><li><p>自动拆箱是指将包装类对象（如 Integer、Double、Boolean 等）自动转换为对应的基本数据类型（如 int、double、boolean 等）。同样，这个过程也是由<strong>编译器</strong>自动完成的。当你从一个需要对象的场景中取出值并赋给基本数据类型时，Java 编译器会检测到目标变量是一个基本数据类型。编译器会自动调用包装类的 <code>xxxValue()</code> 方法，比如 <code>intValue()</code>、<code>doubleValue()</code> 等，来获取基本数据类型的值。返回的基本数据类型值会被赋给目标变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> integerObj.intValue();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>一共有3点需要注意</p><p>第一个是<strong>性能问题</strong>，频繁的自动装箱和拆箱可能会导致额外的性能开销，因为每次都需要创建或转换对象。</p><p>第二个是<strong>空指针异常</strong>，如果对一个 null 的包装类对象进行自动拆箱操作，会抛出 NullPointerException。</p><p>第三个是<strong>缓存机制</strong>，某些包装类（如 Integer、Boolean 等）会对常用值进行缓存。</p></blockquote><hr><h3 id="面试官：-int和Integer的区别（高频）"><a href="#面试官：-int和Integer的区别（高频）" class="headerlink" title="面试官： int和Integer的区别（高频）"></a><strong>面试官：</strong> int和Integer的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ol><li><p><strong>定义上的区别:</strong></p><ul><li><p>int 是 Java 的基本数据类型，<strong>直接存储数值</strong>，占用固定的 4 字节内存空间，范围是从 -2,147,483,648 到 2,147,483,647。</p></li><li><p>而 Integer 是 int 的包装类，<strong>它是一个对象</strong>，通过引用指向存储的数值，因此除了存储数值本身外，还需要额外的内存开销。</p></li></ul></li><li><p><strong>使用方式上的区别:</strong></p><ul><li><p>int 是一种原始类型，可以直接声明和赋值。</p></li><li><p>而 Integer 必须实例化后才能使用，它提供了更多的功能，比如支持泛型、序列化、缓存以及一些实用方法。</p></li></ul></li><li><p><strong>使用场景上的区别:</strong></p><ul><li><p>当需要高效处理整数时，优先使用 int。</p></li><li><p>当需要将整数作为对象使用时，选择 Integer。</p></li></ul></li></ol><blockquote><p>Java 是一门面向对象的语言，很多场景需要将数据封装成对象。例如：泛型（Generics）要求参数必须是对象类型，而不能是基本数据类型。序列化（Serialization）需要对象支持，以便将数据持久化或通过网络传输。缓存机制需要对整数进行复用，以提高性能和节省内存。</p><p>因此，Java 设计了 Integer 作为 int 的包装类，解决了这些面向对象的需求。</p></blockquote><h4 id="Integer-a-1，Integer-b-1，a-b"><a href="#Integer-a-1，Integer-b-1，a-b" class="headerlink" title="Integer a&#x3D;1，Integer b&#x3D;1，a&#x3D;&#x3D;b?"></a><strong>Integer a&#x3D;1，Integer b&#x3D;1，a&#x3D;&#x3D;b?</strong></h4><p> Java 使用了 <strong>Integer 缓存池</strong>，默认缓存范围是 <code>-128</code> 到 <code>127</code>。</p><ul><li>使用 <code>==</code> 比较时，如果值在 <code>-128 ~ 127</code> 之间，结果为 <code>true</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>如果值超出缓存范围，结果为 <code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>equals()</code> 方法进行值比较，则无论范围如何，结果都为 <code>true</code></li></ul><hr><h3 id="面试官：-与-equals（高频）"><a href="#面试官：-与-equals（高频）" class="headerlink" title="面试官：  &#x3D;&#x3D; 与 equals（高频）"></a><strong>面试官：</strong>  &#x3D;&#x3D; 与 equals<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>&#x3D;&#x3D;</strong> : 它的作⽤是判断两个对象的地址是不是相等。(基本数据类型&#x3D;&#x3D;⽐的是值，引⽤数据类型&#x3D;&#x3D;⽐的是内存地址)。</p><p><strong>equals()</strong> : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：</p><ul><li><p>情况 1：类<strong>没有覆盖 equals()</strong> ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“&#x3D;&#x3D;”⽐这两个对象地址。</p></li><li><p>情况 2：类<strong>覆盖了 equals()</strong> ⽅法。⼀般我们都覆盖 equals() ⽅法来⽐两个对象的内容是否相等；若它们的内容相等，则返回 true 。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true，因为String内部重写了equals.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？"><a href="#面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？" class="headerlink" title="面试官：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？"></a><strong>面试官</strong>：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？</h3><p><strong>候选人：</strong></p><p><strong>1）hashCode()介绍:</strong></p><p>hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><strong>2）以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3）为啥hashcode相同了，这两个对象还有可能不相同呢？</strong></p><p>这是由于哈希码值的空间有限（通常是32位整数），而对象的状态空间可能非常大，因此可能会发生“哈希碰撞”，即不同的对象拥有相同的哈希码值。举个例子，考虑一个简单的类 <code>Person</code>，它有两个属性 <code>name</code> 和 <code>age</code>。你可以为这个类重写 <code>hashCode()</code> 和 <code>equals()</code> 方法来确保当两个 <code>Person</code> 对象具有相同的 <code>name</code> 和 <code>age</code> 时，它们的哈希码相同并且 <code>equals()</code> 方法也返回 <code>true</code>。但是，如果你仅仅让 <code>hashCode()</code> 方法基于 <code>name</code> 属性计算哈希码，那么即使 <code>age</code> 不同，两个具有相同名字的 <code>Person</code> 对象也会有相同的哈希码值，尽管它们实际上是不同的对象。</p><p><strong>4）为什么重写equals 时必须重写 hashCode ⽅法？</strong></p><p>如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等,对两个对象分别调⽤ equals⽅法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。<strong>因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖。</strong></p><hr><h3 id="面试官：值传递和引用传递有什么区别？（高频）"><a href="#面试官：值传递和引用传递有什么区别？（高频）" class="headerlink" title="面试官：值传递和引用传递有什么区别？（高频）"></a><strong>面试官</strong>：值传递和引用传递有什么区别？<code>（高频）</code></h3><p><strong>候选人：</strong> Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。（《Java 核⼼技术 卷Ⅰ基础知识》第⼗版 4.5 节）</p><ul><li><strong>值传递</strong>：指的是在方法调用时，传递的参数是<strong>按值的拷贝传递</strong>，也就是说传递后就互不相关了。Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/67e103ea88c538a9b5c5a769.png" alt="image-20250218110642119"></p><p><strong>解析：</strong> 在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><ul><li><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，<strong>其实传递的引用的地址</strong>，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/67e103e488c538a9b5c5a767.png" alt="image-20250218110654146"></p><p><strong>解析：</strong> array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/67e103dc88c538a9b5c5a764.png" alt="image-20250218110707866"></p><p><img src="https://pic1.imgdb.cn/item/67e103d488c538a9b5c5a753.png" alt="image-20250218110721206"></p><p>解析：通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</strong></p><hr><h3 id="面试官：final-、finally-、finalize区别"><a href="#面试官：final-、finally-、finalize区别" class="headerlink" title="面试官：final 、finally 、finalize区别"></a><strong>面试官</strong>：final 、finally 、finalize区别</h3><p><strong>候选人：</strong></p><ul><li>final可以修饰类、变量、方法。修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。（如果是<strong>基本数据类型</strong>的变量，则其数值⼀旦在初始化之后便不能更改；如果是<strong>引⽤类型</strong>的变量，则在对其初始化之后便不能再让其指向另⼀个对象。）</li><li>finally一般作用在<strong>try-catch</strong>代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾。</li></ul><hr><h3 id="面试官：finally块中的代码什么时候被执行？"><a href="#面试官：finally块中的代码什么时候被执行？" class="headerlink" title="面试官：finally块中的代码什么时候被执行？"></a><strong>面试官</strong>：finally块中的代码什么时候被执行？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.19节）<br>在 Java 语言的异常处理中，finally 语句块的作用就是保证无论出现什么情况，finally 块里的代码一定会被执行。由于当程序执行 return 的时候就意味着结束对当前方法的调用并跳出这个方法体，任何语句要执行都只能在 return 前执行(除非碰到 exit 函数)，因此 fnally 块里的代码也是在return 前执行的。<strong>此外，如果 try-finally 或者 catch-finally 中都有 return，则 finally 块中的 return 语句将会覆盖别处的 return 语句，最终返回到调用者的是 finally 中 return 的值</strong>。下面通过两个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>从上面这个例子中可以看出，在执行 return 前确实执行了 finally 中的代码。紧接着，在 finally块里面放置 return 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>在以下</strong> <strong>3</strong> <strong>种特殊情况下，</strong> <strong>finally</strong> <strong>块不会被执⾏：</strong></p><ol><li><p>在 try 或 finally 块中⽤了 System.exit(0) 退出程序。</p></li><li><p>当程序在进入try语句块之前就出现异常的时候（int i &#x3D; 5&#x2F;0;）。</p></li><li><p>程序所在的线程死亡。</p></li><li><p>关闭 CPU。</p></li></ol><hr><h3 id="面试官：this与super的区别"><a href="#面试官：this与super的区别" class="headerlink" title="面试官：this与super的区别"></a><strong>面试官</strong>：this与super的区别</h3><p><strong>候选人：</strong></p><ul><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><hr><h3 id="面试官：Java程序初始化的顺序可以说下吗？"><a href="#面试官：Java程序初始化的顺序可以说下吗？" class="headerlink" title="面试官：Java程序初始化的顺序可以说下吗？"></a><strong>面试官</strong>：Java程序初始化的顺序可以说下吗？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.1节）</p><p>Java程序的初始化工作可以在许多不同的代码块中来完成(例如:静态代码块、构造函数等)，它们执行的顺序为:<strong>父类静态变量</strong>→父类静态代码块→<strong>子类静态变量</strong>→子类静态代码→<strong>父类非静态变量</strong>→父类非静态代码块→父类构造方法→<strong>子类非静态变量</strong>→子类非静态代码块→子类构造方法。下面给出一个不同模块初始化时执行顺序的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Base <span class="keyword">static</span> block</span><br><span class="line">Derived <span class="keyword">static</span> block</span><br><span class="line">Base block</span><br><span class="line">Base constructor</span><br><span class="line">Derived block</span><br><span class="line">Derived constructor</span><br></pre></td></tr></table></figure><p>这里需要注意的是，(静态)非静态成员域在定义时初始化和(静态)非静态块中初始化的优先级是平级的，也就是说按照从上到下初始化，最后一次初始化为最终的值(不包括非静态的成员域在构造器中初始化)。所以在(静态)非静态块中初始化的域甚至能在该域声明的上方，因为分配存储空间在初始化之前就完成了。如下例所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><hr><h3 id="面试官：说下构造方法（构造器）吧！"><a href="#面试官：说下构造方法（构造器）吧！" class="headerlink" title="面试官：说下构造方法（构造器）吧！"></a><strong>面试官</strong>：说下构造方法（构造器）吧！</h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.2节）</p><p>Java 语言中，构造方法具有以下特点:</p><p>1）构造方法必须与类的名字相同，并且不能有返回值(返回值也不能为 void)。</p><p>2）每个类可以有多个构造方法。</p><p>3）构造方法可以有0个、1 个或1个以上的参数。</p><p>4）构造方法总是伴随着 new 操作一起调用。</p><p>5）构造方法的主要作用是完成对象的初始化工作。</p><p>6）构造方法不能被继承，因此就不能被重写(Override)，但是构造方法能够被重载(Overload)。</p><p>7）当父类和子类都没有定义构造方法的时候，编译器会为父类生成一个默认的无参数的构造方法，给子类也生成一个默认的无参数的构造方法。</p><hr><h3 id="面试官：break、continue以及return的区别"><a href="#面试官：break、continue以及return的区别" class="headerlink" title="面试官：break、continue以及return的区别"></a><strong>面试官</strong>：break、continue以及return的区别</h3><p><strong>候选人：</strong></p><ul><li>break：跳出上一层循环，不再执行循环(结束当前的循环体)。所以，当多层循环嵌套，break 语句出现在嵌套循环中的内层循环，它将仅仅只是终止了内层循环的执行，而不影响外层循环的执行。</li></ul><blockquote><p>拓展：由于 break 只能跳出当前的循环，那么如何才能实现跳出多重循环呢?可以在多重循环的外面定义一个标识，然后在循环体里使用带有标识的 break 语句即可跳出多重循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     out:</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) <span class="keyword">break</span> out;</span><br><span class="line">             System.out.println(j);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在 C&#x2F;C++中，goto 常被用作跳出多重循环，在 Java 语言中，可以使用 break 和 continue 来达到同样的效果。那么既然 goto 没有在 Java 语言中使用，为什么还要作为保留字呢?其中一个可能的原因就是这个关键字有可能会在将来被使用。这里需要注意的是，在 Java 语言中，虽然没有 goto 语句，但是却能使用标识符加冒号 (:)的形式定义标签，其目的主要是在多重循环中方便使用 break 和 continue。</p></blockquote><ul><li>continue：跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)。简单地说，continue 只是中断一次循环的执行而己。</li><li>return：程序返回，不再执行下面的代码(结束当前的方法直接返回)。</li></ul><hr><h3 id="面试官：-说说你对Java-中的异常处理的理解？"><a href="#面试官：-说说你对Java-中的异常处理的理解？" class="headerlink" title="面试官： 说说你对Java 中的异常处理的理解？"></a><strong>面试官</strong>： 说说你对Java 中的异常处理的理解？</h3><p>**候选人：**在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类有两个重要的⼦类 Exception （异常）和 Error （错误）。 Exception 能被程序本身处理( trycatch )， Error 是⽆法处理的(只能尽量避免)。Exception 和 Error ⼆者都是 Java 异常处理的重要⼦类，各⾃都包含⼤量⼦类。</p><ul><li><strong>Exception</strong>：程序本身可以处理的异常，可以通过 catch 来进⾏捕获。 Exception ⼜可以分为 <strong>受检异常</strong>(必须处理) 和 <strong>非受检异常</strong>(可以不处理)。</li></ul><blockquote><p><strong>受检查异常</strong>：Java 代码在编译过程中，如果受检查异常没有被 catch &#x2F; throw 处理的话，就没办法通过编译。除了 RuntimeException 及其⼦类以外，其他的 Exception 类及其⼦类都属于检查异常 。常⻅的受检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException …。</p><p><strong>不受检查异常</strong>：Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException 及其⼦类都统称为⾮受检查异常，例如： NullPointExecrption（空指针异常） 、 NumberFormatException （字符串转换为数字）、 ArrayIndexOutOfBoundsException （数组越界）、 ClassCastException （类型转换错误）等。</p></blockquote><ul><li><strong>Error</strong>：Error 属于程序⽆法处理的错误 ，我们没办法通过 catch 来进⾏捕获 。例如，Java 虚拟机运⾏错误（ Virtual MachineError ）、虚拟机内存不够错误( OutOfMemoryError )、类定义错误（NoClassDefFoundError ）等 。这些异常发⽣时，Java虚拟机（JVM）⼀般会选择线程终⽌。</li></ul><p><img src="https://pic1.imgdb.cn/item/67e121280ba3d5a1d7e2946e.png" alt="image-20250218110747074"></p><hr><h3 id="面试官：-BIO-NIO-AIO-有什么区别-（高频）"><a href="#面试官：-BIO-NIO-AIO-有什么区别-（高频）" class="headerlink" title="面试官： BIO,NIO,AIO 有什么区别?（高频）"></a><strong>面试官</strong>： BIO,NIO,AIO 有什么区别?<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>BIO (Blocking I&#x2F;O):</strong>  <strong>同步阻塞</strong> I&#x2F;O 模式，数据的读取写⼊必须<strong>阻塞</strong>在⼀个线程内等待其完成（每个线程只能处理一个连接）。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型不错的，可以让每⼀个连接专注于⾃⼰的 I&#x2F;O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。但是，当⾯对⼗万甚⾄百万级连接的时候，这种方式需要创建大量的线程，而系统的资源都是有限的，大量的线程会降低系统的性能。</p></li><li><p><strong>NIO (Non-blocking I&#x2F;O):</strong> <strong>同步⾮阻塞</strong> 的 I&#x2F;O 模型。NIO通过 <code>Channels , Selector，Buffers</code> 来实现非阻塞的IO操作。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I&#x2F;O 操作⽅法。它最主要的特点是，提供了基于Selector的异步网络I&#x2F;O，使得一个线程可以管理多个连接。</p><p>（图片源自《Java程序员面试笔试宝典》第二版 2.4节）</p><p><img src="https://pic1.imgdb.cn/item/67e121420ba3d5a1d7e29474.png" alt="image-20250218110800609"></p></li></ul><blockquote><p>扩展：Channel（通道） , Selector（选择器），Buffer（缓冲区）</p><p>(1) Channel(通道)<br>为了更容易地理解什么是 <code>Channel</code>，这里以 <code>InputStream</code> 为例来介绍什么是 <code>Channel</code>。传统的 IO 中经常使用下面的代码来读取文件(此处忽略异常处理):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;imput.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">byte</span>[] tempbyte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((tempbyte=is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><p><code>InputStream</code> 其实就是一个用来读取文件的通道。只不过 <code>InputStream</code> 是一个单向的通道，只能用来读取数据。而 NIO 中的 <code>Channel</code> 是一个双向的通道，不仅能读取数据，而且还能写入数据。</p><p>(2) Buffer(缓冲区)<br>在上面的示例代码中，<code>InputSteam</code> 把读取到的数据放在了 byte 数组中，如果用 <code>OutputSteam</code> 写数据，那么也可以把 byte 数组中的数据<strong>写到文件</strong>中。而在 NIO 中，数据只能被<strong>写到 Buffer</strong> 中，同理读取的数据也只能放在 Buffer 中，由此可见 Bufer 是 Channel 用来读写数据的非常重要的一个工具。</p><p><img src="https://pic1.imgdb.cn/item/67e1215d0ba3d5a1d7e29479.png" alt="image-20250218110814433"></p><p>(3) Selector(选择器)<br><code>Selector</code> 是 NIO 中最重要的部分，是实现一个线程管理多个连接的关键，它的作用就是<strong>轮询</strong>所有被注册的<code>Channel</code>，一旦发现 <code>Channel</code> 上被注册的事件发生，就可以对这个事件进行处理。</p></blockquote><ul><li><strong>AIO (Asynchronous I&#x2F;O):</strong> AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是<strong>异步⾮阻塞</strong>的 IO 模型。虽然 NIO 在⽹络操作中，也提供了⾮阻塞的⽅法，但它本身仍然是同步的，选择器仍然需要通过<strong>轮询</strong>主动检查数据请求。而异步 IO （AIO）是<strong>基于事件和回调机制</strong>实现的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</li></ul><hr><h3 id="面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"><a href="#面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？" class="headerlink" title="面试官： NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"></a><strong>面试官：</strong> NIO是如何实现同步非阻塞的？主线程是只有一个嘛？</h3><p><strong>候选人：</strong></p><p>在NIO中，使用了多路复用器Selector来实现同步非阻塞的IO操作。Selector是一个可以监控多个通道（Channel）是否有数据可读或可写的对象，当一个或多个Channel准备好读或写时，Selector会通知程序进行读写操作，而不是像BIO一样阻塞等待IO操作完成。</p><p>在NIO中，主线程<strong>通常只有一个</strong>，但是可以使用Selector来管理多个Channel，实现多个连接的非阻塞读写操作。当有多个Channel需要进行IO操作时，Selector会<strong>轮询</strong>这些Channel，检查它们的状态是否可读或可写，如果有可读或可写的Channel，就将其加入到一个已选择键集合中，等待程序处理。这样，一个线程就可以同时处理多个Channel，提高了系统的并发处理能力。</p><hr><h3 id="面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"><a href="#面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）" class="headerlink" title="面试官： 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"></a><strong>面试官：</strong> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？<code>（高频）</code></h3><ul><li><p>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接<strong>复制内部对象的引用地址</strong>，也就是说<strong>拷贝对象和原对象共用同一个内部对象</strong>。浅拷贝实现简单，使用 <code>clone()</code> 即可。</p></li><li><p>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。**增加了一个指针并且申请了一个新的内存，使这个新增的指针指向新的内存。**深拷贝需要递归复制或序列化，实现较复杂。</p><blockquote><p>联想：在租房的场景中，租客和房东共享房子的使用权，任何改动都会影响对方；而在买房的场景中，买方拥有独立的房子，可以自由改造而不影响他人。通过租房和买房的类比，轻松理解浅拷贝和深拷贝的不同。</p><p>浅拷贝 → 租房（租客和房东共享房子，改动家具会影响房东）。</p><p>深拷贝 → 买房（买房后拥有完全独立的房子，改动家具不会影响房东）。</p></blockquote></li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="https://pic1.imgdb.cn/item/67e121730ba3d5a1d7e29482.png" alt="image-20250303092129835"></p><hr><h3 id="面试官：-什么是泛型？有什么作用？（高频）"><a href="#面试官：-什么是泛型？有什么作用？（高频）" class="headerlink" title="面试官： 什么是泛型？有什么作用？（高频）"></a><strong>面试官：</strong> 什么是泛型？有什么作用？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>泛型是一种在编译时提供类型安全检查的机制，它允许我们将类型作为参数传递给类、接口或方法，从而避免硬编码具体的类型。通过泛型，我们可以编写适用于多种数据类型的代码，同时确保类型安全。</p><p>泛型的作用主要有4点：</p><p>第一点是<strong>提高代码的复用性</strong>，它允许我们编写与类型无关的通用代码。</p><p>第二点是<strong>增强类型安全性</strong>，在没有泛型的情况下，集合类（如 ArrayList）默认存储的是 Object 类型，取出元素时需要手动进行类型转换，容易引发 ClassCastException。而泛型在编译时就会进行类型检查，避免了运行时的类型错误。</p><p>第三点是<strong>简化代码</strong>，使用泛型后，我们无需显式地进行类型转换，减少了冗余代码，提高了代码的可读性和维护性。</p><p>第四点是<strong>支持复杂的类型约束</strong>，泛型可以通过通配符（如 ? extends T 和 ? super T）实现更复杂的类型限制，满足特定场景下的需求。</p><hr><h3 id="面试官：-Java反射机制以及获取反射对象的几种方式（高频）"><a href="#面试官：-Java反射机制以及获取反射对象的几种方式（高频）" class="headerlink" title="面试官： Java反射机制以及获取反射对象的几种方式（高频）"></a><strong>面试官：</strong> Java反射机制以及获取反射对象的几种方式<code>（高频）</code></h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.4节）</p><p>在Java语言中，反射机制是指对于运行时类，都能够动态地获取到这个类的所有属性和方法。对于任意的一个对象，都能够调用它的任意一个方法以及访问它的属性；这种动态地获取类或对象的属性以及方法从而完成调用功能被称为Java语言的反射机制。</p><p>反射机制中Class是一个非常重要的类，在Java语言中获取Class对象主要有如下几种方法。</p><ol><li>通过<code>.class</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = A.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>Class.forName()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="3"><li>通过<code>.getClass()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">new</span> <span class="title class_">A</span>().getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">dynamic block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><p>从上面的例子可知，虽然这三种方式都可以获得类的Class对象，但是它们还是有区别的，主要区别如下所示：</p><p>方法1）<strong>不执行静态块和普通代码块</strong></p><p>方法2）<strong>只执行静态块，而不执行普通代码块</strong></p><p>方法3）<strong>因为需要创建对象，所以会执行静态块和普通代码块</strong></p><hr><h3 id="面试官：-Java创建对象除了new还有别的什么方式"><a href="#面试官：-Java创建对象除了new还有别的什么方式" class="headerlink" title="面试官： Java创建对象除了new还有别的什么方式?"></a><strong>面试官：</strong> Java创建对象除了new还有别的什么方式?</h3><p><strong>候选人：</strong></p><ul><li><p><strong>通过反射创建对象</strong>:通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newinstance() 方法或者通过 Constructor 类来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; clazz=MyClass.class;</span><br><span class="line">    MyClass obj=(MyClass)clazz.newInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过反序列化创建对象</strong>:通过将对象序列化(保存到文件或网络传输)然后再反序列化(从文件或网络传输中读取对象)的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Serialize object</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialize object</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过clone创建对象</strong>:所有 Java 对象都继承自 Object 类，Object 类中有一个 clone()方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/22/hello-world/"/>
      <url>/2025/03/22/hello-world/</url>
      
        <content type="html"><![CDATA[<div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p></div><div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p></div><hr><h1 id="🎉-Hello-World"><a href="#🎉-Hello-World" class="headerlink" title="🎉 Hello, World!"></a>🎉 Hello, World!</h1><p>欢迎来到我的个人网站！这是一个承载思考与创意的空间，也是我与世界对话的窗口。从构思到上线，这个小小的角落凝聚了我的热情与心血。</p><h2 id="🌿-为什么是“Hello-World”"><a href="#🌿-为什么是“Hello-World”" class="headerlink" title="🌿 为什么是“Hello, World”?"></a>🌿 为什么是“Hello, World”?</h2><p>“Hello, World!” 是程序员的第一课。它不仅是一句简单的问候，更象征着探索与创造的开始。每一个程序员在学习一门新语言时，都会用它来向世界宣告自己的到来。</p><p>而我的个人网站，也像是一次数字世界的问候。它不仅代表着技术上的实现，更是我向世界展示自我的方式。在这里，我记录思考、分享作品、交流想法。这个名字承载了我对新起点的期待，也寄托着我不断学习和成长的决心。</p><h2 id="🌿-关于这里"><a href="#🌿-关于这里" class="headerlink" title="🌿 关于这里"></a>🌿 关于这里</h2><p>在这里，你会找到：</p><ul><li><strong>📝 日常分享</strong>：记录生活中的点滴瞬间，感悟万物之美。</li><li><strong>🎨 绘画作品</strong>：用色彩描绘内心世界，捕捉灵感的瞬间。</li><li><strong>💡 技术探索</strong>：分享我的学习笔记和项目经验，共同成长。</li></ul><h2 id="💬-与我互动"><a href="#💬-与我互动" class="headerlink" title="💬 与我互动"></a>💬 与我互动</h2><p>每一篇文章、每一幅作品，都是我世界的一部分。我希望你在这里找到共鸣，也欢迎留下你的想法和故事。</p><ul><li>想法碰撞？留下评论吧！</li><li>想了解更多？敬请期待更新！</li><li>有问题？<a href="#">联系我</a> 我很乐意听到你的声音。</li></ul><h2 id="🚀-未来可期"><a href="#🚀-未来可期" class="headerlink" title="🚀 未来可期"></a>🚀 未来可期</h2><p>未来还有更多精彩内容等待解锁。感谢你的到来，让我们一起探索这场数字旅程吧！</p><p>再次欢迎你，愿你在这里度过美好的时光！🌟</p>]]></content>
      
      
      <categories>
          
          <category> 个人碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
