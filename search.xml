<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>后端高频笔试题（非常规LC题）</title>
      <link href="/2025/03/24/%E5%90%8E%E7%AB%AF%E9%AB%98%E9%A2%91%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/24/%E5%90%8E%E7%AB%AF%E9%AB%98%E9%A2%91%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><strong>1. 常见的五种单例模式的实现⽅式<br>2. 约瑟夫环 （递归）<br>3. 交替打印奇偶数 （Semaphore、synchronized搭配wait、notify）<br>4. 交替打印 ABC （Semaphore）<br>5. 三个线程交替打印 1 到 99 （Semaphore、AtomicInteger）<br>6. 实现⼀个线程安全的计数器 （ThreadPool、AtomicInteger &#x2F; LongAdder）<br>7. 控制三个线程的执⾏顺序 （CountDownLatch、join）<br>8. 五⼈赛跑裁判 （ThreadPool、AtomicInteger、CountDownLatch）<br>9. LRU缓存（升级版：带缓存过期时间）</strong></p><h2 id="常见的五种单例模式的实现⽅式"><a href="#常见的五种单例模式的实现⽅式" class="headerlink" title="常见的五种单例模式的实现⽅式"></a>常见的五种单例模式的实现⽅式</h2><h3 id="1、枚举（推荐）"><a href="#1、枚举（推荐）" class="headerlink" title="1、枚举（推荐）:"></a>1、枚举（推荐）:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>《Effective Java》</strong> 作者推荐的⼀种单例实现⽅式，简单⾼效，⽆需加锁，线程安全，可以避免通过反射破坏枚举单例。</p><h3 id="2、静态内部类（推荐）"><a href="#2、静态内部类（推荐）" class="headerlink" title="2、静态内部类（推荐）:"></a>2、静态内部类（推荐）:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供获取实例的公共⽅法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部类 <code>Singleton</code> 被加载的时候，并不会创建静态内部类 <code>SingletonInner</code> 的实例对象。只有当调⽤ <code>getInstance()</code> ⽅法时， <code>SingletonInner</code> 才会被加载，这个时候才会创建单例对象<code>INSTANCE</code> 。<code>INSTANCE</code> 的唯⼀性、创建过程的线程安全性，都由 JVM 来保证。</p><p>这种⽅式同样简单⾼效，⽆需加锁，线程安全，并且⽀持延时加载。</p><h3 id="3、双重校验锁"><a href="#3、双重校验锁" class="headerlink" title="3、双重校验锁:"></a>3、双重校验锁:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">singlton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采⽤ <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code></p><p>这段代码其实是分为三步执⾏：</p><ol><li>为 <strong>uniqueInstance</strong> 分配内存空间</li><li>初始化 <strong>uniqueInstance</strong></li><li>将 <strong>uniqueInstance</strong> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 <code>1-&gt;3-&gt;2</code>。指令排在单线程环境下不会出现问题，但是在<strong>多线程</strong>环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ <code>getUniqueInstance ()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code> ，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>这种⽅式实现起来较麻烦，但同样线程安全，⽀持延时加载。</p><h3 id="4、饿汉式："><a href="#4、饿汉式：" class="headerlink" title="4、饿汉式："></a>4、饿汉式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="comment">// 类加载时就创建实例，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利⽤ Java 的静态特性，在类加载时就创建实例，天然线程安全，但可能会导致资源浪费。</p><h3 id="5、懒汉式："><a href="#5、懒汉式：" class="headerlink" title="5、懒汉式："></a>5、懒汉式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全的懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第⼀次使⽤时才创建实例。在多线程环境下，可能会出现多个线程同时进入 <code>if (instance == null)</code>语句块，导致创建多个实例，不符合单例模式的设计。</p><h3 id="五种单例模式对比"><a href="#五种单例模式对比" class="headerlink" title="五种单例模式对比"></a><strong>五种单例模式对比</strong></h3><table><thead><tr><th><strong>方式</strong></th><th><strong>线程安全性</strong></th><th><strong>是否懒加载</strong></th><th><strong>实现难度</strong></th><th><strong>性能</strong></th></tr></thead><tbody><tr><td><strong>饿汉式</strong></td><td>✅ 线程安全</td><td>❌ 不是懒加载</td><td>⭐⭐ 易实现</td><td>⭐⭐⭐ 访问快</td></tr><tr><td><strong>懒汉式（非线程安全）</strong></td><td>❌ 线程不安全</td><td>✅ 懒加载</td><td>⭐⭐ 易实现</td><td>⭐⭐⭐ 访问快</td></tr><tr><td><strong>懒汉式（DCL双重检查锁）</strong></td><td>✅ 线程安全</td><td>✅ 懒加载</td><td>⭐⭐⭐ 代码复杂</td><td>⭐ 访问需加锁</td></tr><tr><td><strong>静态内部类</strong></td><td>✅ 线程安全</td><td>✅ 懒加载</td><td>⭐⭐ 易实现</td><td>⭐⭐⭐ 访问快</td></tr></tbody></table><hr><h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><p>约瑟夫环问题的核心思想是：<strong>一群人围成一圈，从某个起点开始依次报数，报到特定数字的人出局，直到只剩下最后一个人为止</strong>。  </p><h3 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a><strong>求解思路</strong></h3><p>这个问题可以用 <strong>递推公式</strong> 来表示：</p><p><em>f(n,k)&#x3D;(f(n−1,k)+k-1)%n+1</em></p><p>其中：</p><ul><li><code>f(n, k)</code> 代表 <strong>n 个人围成一圈</strong>，每次报数到 <code>k</code> 的人出局，最终<strong>留下的人的编号</strong>。</li><li>递归的<strong>终止条件</strong>是当 <code>n = 1</code> 时，唯一的那个人自然是编号 1（即 <code>f(1, k) = 1</code>)。</li><li>递推公式的含义是：在 <strong>n - 1 个人的情况下找到安全位置</strong>，然后<strong>映射到当前 n 个人的编号</strong>。</li></ul><hr><h3 id="换个更直观的理解"><a href="#换个更直观的理解" class="headerlink" title="换个更直观的理解"></a><strong>换个更直观的理解</strong></h3><p>想象有 <strong>n 个人站成一个圈</strong>，他们按顺序报数，每报到 <strong>k</strong> 的人出局。我们希望知道最终谁能存活下来。</p><ul><li><strong>从 1 个人开始</strong>（显然他是幸存者）。</li><li><strong>增加到 2 个人</strong>，谁存活取决于前一个人的位置加上 <code>k</code>，再取模计算位置。</li><li><strong>每次增加 1 个人</strong>，都要重新计算安全位置。</li></ul><p>这就像我们 <strong>不断从后往前推导，找到一个人站在“安全位置”</strong>。最终，我们得到了 <strong>最后留下的那个人的编号</strong>。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JosephusProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">josephus</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果只有⼀个⼈，则返回 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (josephus(n - <span class="number">1</span>, k) + k - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后留下的人的编号是：&quot;</span> + josephus(n, k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后留下的人的编号是：<span class="number">4</span></span><br></pre></td></tr></table></figure><hr><h2 id="交替打印奇偶数"><a href="#交替打印奇偶数" class="headerlink" title="交替打印奇偶数"></a>交替打印奇偶数</h2><p><strong>问题描述：写两个线程打印 1-100，⼀个线程打印奇数，⼀个线程打印偶数。</strong></p><p>这道题的实现⽅式还是挺多的，线程的等待&#x2F;通知机制 <strong>（ wait() 和 notify() ）</strong> 、信号<code>Semaphore</code> 等都可以实现。</p><h3 id="synchronized-wait-notify-实现"><a href="#synchronized-wait-notify-实现" class="headerlink" title="synchronized+wait&#x2F;notify 实现"></a>synchronized+wait&#x2F;notify 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * synchronized+wait/notify 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParityPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="comment">// 从1开始计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParityPrinter</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> isOdd)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (isOdd == (count % <span class="number">2</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + count++);</span><br><span class="line">                    lock.notify();  <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有正确的线程才能打印，错误的线程会 lock.wait() 进入等待状态</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddAndEven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印 1-100</span></span><br><span class="line">        <span class="type">ParityPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParityPrinter</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 创建打印奇数和偶数的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printOdd, <span class="string">&quot;Odd&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printEven, <span class="string">&quot;Even&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Odd : <span class="number">1</span></span><br><span class="line">Even : <span class="number">2</span></span><br><span class="line">Odd : <span class="number">3</span></span><br><span class="line">Even : <span class="number">4</span></span><br><span class="line">Odd : <span class="number">5</span></span><br><span class="line">...</span><br><span class="line">Odd : <span class="number">95</span></span><br><span class="line">Even : <span class="number">96</span></span><br><span class="line">Odd : <span class="number">97</span></span><br><span class="line">Even : <span class="number">98</span></span><br><span class="line">Odd : <span class="number">99</span></span><br><span class="line">Even : <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="Semaphore-实现"><a href="#Semaphore-实现" class="headerlink" title="Semaphore 实现"></a>Semaphore 实现</h3><p>如果想要把上⾯的代码修改为基于 <code>Semaphore</code> 实现也挺简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Semaphore 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParityPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreOdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreEven</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParityPrinter</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreOdd, semaphoreEven);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreEven, semaphoreOdd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Semaphore cur, Semaphore next)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 信号量 -1 </span></span><br><span class="line">                cur.acquire();</span><br><span class="line">                <span class="comment">// 防止 max 取值导致多打印或者死锁</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">                    next.release();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + count++);</span><br><span class="line">                <span class="comment">// 信号量 +1 </span></span><br><span class="line">                next.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddAndEven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印 1-100</span></span><br><span class="line">        <span class="type">ParityPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParityPrinter</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 创建打印奇数和偶数的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printOdd, <span class="string">&quot;Odd&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printEven, <span class="string">&quot;Even&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们这⾥使⽤两个信号 <code>semaphoreOdd</code> 和 <code>semaphoreEven</code> 来确保两个线程交替执⾏。<code>semaphoreOdd</code> 信号先获取，也就是先执⾏奇数输出。⼀个线程执⾏完之后，就释放下⼀个信号。</p><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Odd : <span class="number">1</span></span><br><span class="line">Even : <span class="number">2</span></span><br><span class="line">Odd : <span class="number">3</span></span><br><span class="line">Even : <span class="number">4</span></span><br><span class="line">Odd : <span class="number">5</span></span><br><span class="line">Even : <span class="number">6</span></span><br><span class="line">Odd : <span class="number">7</span></span><br><span class="line">Even : <span class="number">8</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Odd : <span class="number">95</span></span><br><span class="line">Even : <span class="number">96</span></span><br><span class="line">Odd : <span class="number">97</span></span><br><span class="line">Even : <span class="number">98</span></span><br><span class="line">Odd : <span class="number">99</span></span><br><span class="line">Even : <span class="number">100</span></span><br></pre></td></tr></table></figure><hr><h2 id="交替打印-ABC"><a href="#交替打印-ABC" class="headerlink" title="交替打印 ABC"></a>交替打印 ABC</h2><p><strong>问题描述：写三个线程打印 “ABC”，⼀个线程打印 A，⼀个线程打印 B，⼀个线程打印 C，⼀共打印 10 轮。</strong></p><p>这个问题其实和上⾯的交替打印奇偶数是⼀样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphoreC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ABCPrinter</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerA</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreA, semaphoreB, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerB</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreB, semaphoreC, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerC</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreC, semaphoreA, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Semaphore cur, Semaphore next, String x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cur.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + x);</span><br><span class="line">                next.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ABCPrinter</span> <span class="variable">abcPrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ABCPrinter</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(abcPrinter::printerA, <span class="string">&quot;Thread 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(abcPrinter::printerB, <span class="string">&quot;Thread 2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(abcPrinter::printerC, <span class="string">&quot;Thread 3&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> : A</span><br><span class="line">Thread <span class="number">2</span> : B</span><br><span class="line">Thread <span class="number">3</span> : C</span><br><span class="line">Thread <span class="number">1</span> : A</span><br><span class="line">Thread <span class="number">2</span> : B</span><br><span class="line">Thread <span class="number">3</span> : C</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Thread <span class="number">1</span> : A</span><br><span class="line">Thread <span class="number">2</span> : B</span><br><span class="line">Thread <span class="number">3</span> : C</span><br></pre></td></tr></table></figure><hr><h2 id="三个线程交替打印-1-到-99"><a href="#三个线程交替打印-1-到-99" class="headerlink" title="三个线程交替打印 1 到 99"></a>三个线程交替打印 1 到 99</h2><p><strong>问题描述：写三个线程 A、B、C，A 线程打印 3n+1，B 线程打印 3n+2，C 线程打印 3n+3。</strong></p><p>这道题和三个线程交替打印 ABC 这道题有挺多相似之处，唯一不同之处就是对count计数的调整，这次我们选用线程安全的原子类<code>AtomicInteger</code> 来作替代。话不多说上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="comment">// 用线程安全的原子类来替代count变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphoreA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphoreB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphoreC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumPrinter</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerA</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreA, semaphoreB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerB</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreB, semaphoreC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printerC</span><span class="params">()</span> &#123;</span><br><span class="line">        print(semaphoreC, semaphoreA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Semaphore cur, Semaphore next)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cur.acquire();</span><br><span class="line">                <span class="comment">// 取值并逐渐递增</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> count.getAndIncrement();</span><br><span class="line">                <span class="keyword">if</span> (value &gt; max) &#123;  <span class="comment">// 超出范围，释放信号量防止死锁</span></span><br><span class="line">                    next.release();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">                next.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneTo99</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NumPrinter</span> <span class="variable">numPrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumPrinter</span>(<span class="number">99</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(numPrinter::printerA,<span class="string">&quot;Thread A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(numPrinter::printerB,<span class="string">&quot;Thread B&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(numPrinter::printerC,<span class="string">&quot;Thread C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread A : <span class="number">1</span></span><br><span class="line">Thread B : <span class="number">2</span></span><br><span class="line">Thread C : <span class="number">3</span></span><br><span class="line">Thread A : <span class="number">4</span></span><br><span class="line">Thread B : <span class="number">5</span></span><br><span class="line">Thread C : <span class="number">6</span></span><br><span class="line">Thread A : <span class="number">7</span></span><br><span class="line">Thread B : <span class="number">8</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Thread A : <span class="number">94</span></span><br><span class="line">Thread B : <span class="number">95</span></span><br><span class="line">Thread C : <span class="number">96</span></span><br><span class="line">Thread A : <span class="number">97</span></span><br><span class="line">Thread B : <span class="number">98</span></span><br><span class="line">Thread C : <span class="number">99</span></span><br></pre></td></tr></table></figure><hr><h2 id="实现⼀个线程安全的计数器"><a href="#实现⼀个线程安全的计数器" class="headerlink" title="实现⼀个线程安全的计数器"></a>实现⼀个线程安全的计数器</h2><p><strong>问题描述：实现⼀个线程安全的计数器，100 个线程，每个线程累加 100 次。</strong></p><p><code>AtomicLong</code> 通过使⽤ <strong>CAS（Compare-And-Swap）</strong> 操作，实现了⽆锁的线程安全机制，能够对⻓整型数据进⾏原⼦操作。⾼并发的场景下，乐观锁相⽐悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜⼀筹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建⼀个线程安全的计数器</span></span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">        <span class="comment">// 创建⼀个固定⼤⼩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 100 个线程，每个线程累加 100 次</span></span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    counter.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;Final Counter Value: &quot;</span> + counter.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p>虽然 <code>AtomicLong</code> 的性能已经相当优秀，但在⾼并发场景下仍存在⼀些效率问题。JDK 8 新增了⼀个原⼦性递增或者递减类 <code>LongAdder</code> ⽤来克服在⾼并发下使⽤ <code>AtomicLong</code> 的⼀些缺点。</p><p>使⽤ <code>LongAdder</code> 改造后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        <span class="comment">// 创建⼀个固定⼤⼩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 100 个线程，每个线程累加 100 次</span></span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;Final Counter Value: &quot;</span> + counter.sum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LongAdder 使⽤ <code>increment()</code> ⽅法累加，所有累加的总和通过 <code>sum()</code> ⽅法获取。</p><hr><h2 id="控制三个线程的执⾏顺序"><a href="#控制三个线程的执⾏顺序" class="headerlink" title="控制三个线程的执⾏顺序"></a>控制三个线程的执⾏顺序</h2><p><strong>问题描述：假设有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执⾏完后执⾏，T3 在 T2 执⾏完后执⾏？</strong></p><p>这道题不难，⼤部分⼈都是⽤ <code>join()</code> 或者 <code>CountDownLatch</code> 实现。话不多说上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// join();</span></span><br><span class="line">        countDownLatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countDownLatch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch1.countDown(); <span class="comment">// T1 完成后释放 latch1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 T1 完成</span></span><br><span class="line">                latch1.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;T2 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch2.countDown(); <span class="comment">// T2 完成后释放 latch2</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 T2 完成</span></span><br><span class="line">                latch2.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;T3 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T2 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T2 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T3 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T3 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动 T1 并等待其完成</span></span><br><span class="line">            t1.start();</span><br><span class="line">            t1.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// T1 完成后启动 T2 并等待其完成</span></span><br><span class="line">            t2.start();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// T2 完成后启动 T3 并等待其完成</span></span><br><span class="line">            t3.start();</span><br><span class="line">            t3.join();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五⼈赛跑裁判"><a href="#五⼈赛跑裁判" class="headerlink" title="五⼈赛跑裁判"></a>五⼈赛跑裁判</h2><p><strong>问题描述：有 5 个⼈赛跑，请你设计⼀个多线程的裁判程序给出他们赛跑的结果顺序，5 个⼈的速度随机处理。</strong></p><p>我们借助<code>线程池</code>和 <code>CountDownLatch</code> 来实现这⼀需求即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Racing</span> &#123;</span><br><span class="line">    <span class="comment">// 使⽤ AtomicInteger 确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建⼀个固定⼤⼩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(threadCount);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟随机耗时</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">sleepTime</span> <span class="operator">=</span> random.nextInt(<span class="number">401</span>) + <span class="number">100</span>; <span class="comment">// 100ms ~ 500ms</span></span><br><span class="line">                    Thread.sleep(sleepTime);</span><br><span class="line">                    <span class="comment">// 使⽤ AtomicInteger 确保线程安全</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> num.getAndIncrement();</span><br><span class="line">                    res[index] = <span class="string">&quot;运动员&quot;</span> + id + <span class="string">&quot;消耗的时间为&quot;</span> + sleepTime;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (String x : res) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运动员<span class="number">5</span>消耗的时间为<span class="number">162</span></span><br><span class="line">运动员<span class="number">2</span>消耗的时间为<span class="number">181</span></span><br><span class="line">运动员<span class="number">4</span>消耗的时间为<span class="number">266</span></span><br><span class="line">运动员<span class="number">3</span>消耗的时间为<span class="number">425</span></span><br><span class="line">运动员<span class="number">1</span>消耗的时间为<span class="number">452</span></span><br></pre></td></tr></table></figure><p>解题的核⼼是 <code>AtomicInteger</code> 和 <code>CountDownLatch</code> 类的运⽤：</p><ul><li><code>AtomicInteger</code> 是⼀个线程安全的整数类，⽀持原⼦性操作。</li><li><code>CountDownLatch</code> 是⼀个线程同步⼯具类，⽤于让主线程等待其他线程完成⼯作。在本题中，初始化计数器为线程数 5。每个线程完成任务后，调⽤<code>countDownLatch.countDown() </code>，主线程调⽤<code>countDownLatch.await()</code> 。</li></ul><p>完整的执⾏流程如下：</p><ol><li>创建⼀个固定⼤⼩的线程池和⼀个 <code>CountDownLatch</code> ，初始化为5。</li><li>提交5个线程任务到线程池，模拟每个运动员完成⽐赛的过程：<ul><li>每个线程随机等待⼀定时间 <strong>（100ms~500ms）</strong>，表示运动员⽐赛时⻓。</li><li>使⽤ <code>AtomicInteger</code> 确保线程安全，将⽐赛结果写⼊数组。</li><li>每个线程完成后，调⽤ <code>countDown()</code> 减少计数器值。</li></ul></li><li>主线程调⽤ <code>await()</code> ，等待所有线程完成。</li><li>所有线程完成后，主线程输出⽐赛结果。</li></ol><hr><h2 id="LRU缓存（升级版：带缓存过期时间）"><a href="#LRU缓存（升级版：带缓存过期时间）" class="headerlink" title="LRU缓存（升级版：带缓存过期时间）"></a>LRU缓存（升级版：带缓存过期时间）</h2><p><a href="https://blog.csdn.net/weixin_74199893/article/details/142991194">👉详情见该博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速通买卖股票的最佳时机（动态规划一网打尽）</title>
      <link href="/2025/03/24/%E9%80%9F%E9%80%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2025/03/24/%E9%80%9F%E9%80%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>阅读完本篇文章，你可以在力扣顺便解决以下题目：</p><table><thead><tr><th align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机(简单)</a></th><th align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II(中等)</a></th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III(困难)</a></td><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV(困难)</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期(中等)</a></td><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费(中等)</a></td></tr></tbody></table><p><img src="https://pic1.imgdb.cn/item/67e0e6f488c538a9b5c59d3a.png" alt="在这里插入图片描述"></p><p>👊虽然在处理某些股票相关的问题时，直接使用简单的方法可能看起来更直接也更容易实现，但我希望通过采用一种更为通用的方法——比如<strong>动态规划</strong>来解决问题，即便这在开始时可能会让人觉得有些复杂或繁琐。实际上，使用如<strong>贪心算法</strong>等方法可能在解决这类问题时更加直观且效率更高。然而，我们的目标是通过动态规划这种更具普遍性的策略，帮助大家建立起解决这类问题的能力，使得在未来面对更多类似挑战时可以更加从容不迫，并且能够用<strong>最少的记忆负担应对更多的题目类型</strong>。这样做是为了长远考虑，帮助积累解决问题的通用技巧，而不是仅仅针对单一问题寻找捷径。</p><p>💪接下来，让我们探讨一下如何运用动态规划来解决这一类与股票相关的题目。一旦你掌握了通过动态规划解决一个问题的方法，之后只需要对<strong>递推公式稍作调整，并正确设置初始条件</strong>，就能够解决其他类似的问题了。这种方法的核心在于理解并应用动态规划的基本原理，从而达到举一反三的效果。</p><h1 id="121-买卖股票的最佳时机-简单"><a href="#121-买卖股票的最佳时机-简单" class="headerlink" title="121.买卖股票的最佳时机(简单)"></a>121.买卖股票的最佳时机(简单)</h1><h2 id="🐚核心思路"><a href="#🐚核心思路" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><h3 id="1）确定dp数组以及下标的含义"><a href="#1）确定dp数组以及下标的含义" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>dp[i][0] 表示第i天持有股票所得最多现金<br>dp[i][1] 表示第i天不持有股票所得最多现金</p><blockquote><p>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</p></blockquote><h3 id="2）确定递推公式"><a href="#2）确定递推公式" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><p>如果在第 i 天持有股票 (<code>dp[i][0]</code>)，那么有两种可能性：</p><ol><li>我们在第 i-1 天就已经持有股票，并且在第 i 天没有进行任何操作，这意味着我们继续持有前一天的股票状态：<code>dp[i - 1][0]</code>。</li><li>我们在第 i 天买入股票，此时我们手中的现金减少了 <code>prices[i]</code>，因此现金变为 <code>-prices[i]</code>。</li></ol><p>为了最大化手中的现金，我们需要在这两种情况中选择较大的值。因此，我们有：<br><code>dp[i][0] = max(dp[i - 1][0], -prices[i]);</code></p><p>如果在第 i 天不持有股票 (<code>dp[i][1]</code>)，同样有两种可能性：</p><ol><li>我们在第 i-1 天就不持有股票，并且在第 i 天没有进行任何操作，这意味着我们继续保持不持有股票的状态：<code>dp[i - 1][1]</code>。</li><li>我们在第 i 天卖出股票，这时我们增加的现金为股票的价格 <code>prices[i]</code> 加上我们在第 i-1 天持有股票时的最大现金 <code>dp[i - 1][0]</code>。</li></ol><p>同样地，为了使手中的现金最大化，我们需要在这两种情况中选择较大的值。因此，我们有：<br><code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</code></p><p>这样，我们就定义了每一天的状态转移规则，以确保在每个决策点上都能做出最佳的选择。</p><h3 id="3）初始化"><a href="#3）初始化" class="headerlink" title="3）初始化"></a>3）初始化</h3><p>根据递推公式 <code>dp[i][0] = max(dp[i - 1][0], -prices[i])</code> 和 <code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])</code>，我们知道整个动态规划过程是从第一天的状态开始逐步推进的。</p><p>对于 <code>dp[0][0]</code>，它代表在第0天持有股票的情况。由于这是第一天，没有前一天的状态可以参考，所以唯一的情况就是在第0天买入股票。这意味着我们花费了 <code>prices[0]</code> 购买了股票，因此 <code>dp[0][0]</code> 的值应该是 <code>-prices[0]</code>（因为我们支付了这个金额来购买股票）。</p><p>而对于 <code>dp[0][1]</code>，它表示在第0天不持有股票的情况。在这种情况下，我们没有买入股票，所以我们的现金仍然是初始值，通常设定为 <code>0</code>。</p><p>因此，我们可以这样初始化：</p><ul><li><code>dp[0][0] = -prices[0]</code> （因为我们在第0天买入了股票）</li><li><code>dp[0][1] = 0</code> （因为我们没有持有股票，现金保持不变）</li></ul><p>这样我们就明确了初始状态，可以基于此进行后续的动态规划计算，从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，所以我们从前向后遍历即可。</p><h2 id="🌴代码实现"><a href="#🌴代码实现" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码"><a href="#JAVA代码" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// [0][0]持有   [0][1]不持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 这里只能有一次买入哦！！！</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机-II-中等"><a href="#122-买卖股票的最佳时机-II-中等" class="headerlink" title="122. 买卖股票的最佳时机 II(中等)"></a>122. 买卖股票的最佳时机 II(中等)</h1><h2 id="🐚核心思路-1"><a href="#🐚核心思路-1" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>在这道题中，股票可以买卖多次了！这也是和<strong>121. 买卖股票的最佳时机</strong>的唯一区别。重点在于递推公式的不同。</p><p>在回顾一下dp数组的含义：</p><p><strong>dp[i][0] 表示第i天持有股票所得现金。<br>dp[i][1] 表示第i天不持有股票所得最多现金。</strong></p><h3 id="递推公式："><a href="#递推公式：" class="headerlink" title="递推公式："></a>递推公式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br></pre></td></tr></table></figure><p>大家可以发现本题和<strong>121. 买卖股票的最佳时机</strong> 的代码几乎一样，唯一的区别在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br></pre></td></tr></table></figure><p>这正是因为本题的股票可以买卖多次！ 所以买入股票的时候，可能会有之前买卖的利润即：<code>dp[i - 1][1]</code>，所以<code>dp[i - 1][1] - prices[i]</code>。</p><h2 id="🌴代码实现-1"><a href="#🌴代码实现-1" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-1"><a href="#JAVA代码-1" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机-III-困难"><a href="#123-买卖股票的最佳时机-III-困难" class="headerlink" title="123. 买卖股票的最佳时机 III(困难)"></a>123. 买卖股票的最佳时机 III(困难)</h1><h2 id="🐚核心思路-2"><a href="#🐚核心思路-2" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>在这道题中，股票最多只能完成两笔交易。这意味着可以买卖一次，可以买卖两次，也可以不买卖。相比较于上两个题稍微复杂一点，不过就是多了几种讨论情况而已。</p><h3 id="1）确定dp数组以及下标的含义-1"><a href="#1）确定dp数组以及下标的含义-1" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>一天一共就有4个状态：</p><ul><li>第一次买入</li><li>第一次卖出</li><li>第二次买入</li><li>第二次卖出</li></ul><h3 id="2）确定递推公式-1"><a href="#2）确定递推公式-1" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">dp[i][<span class="number">3</span>] = max(dp[i-<span class="number">1</span>][<span class="number">3</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h3 id="3）初始化-1"><a href="#3）初始化-1" class="headerlink" title="3）初始化"></a>3）初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>; </span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-2"><a href="#🌴代码实现-2" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-2"><a href="#JAVA代码-2" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// [0][0] 第一次买入 [0][2] 第二次买入</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>],prices[i]+dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="188-买卖股票的最佳时机-IV-困难"><a href="#188-买卖股票的最佳时机-IV-困难" class="headerlink" title="188. 买卖股票的最佳时机 IV(困难)"></a>188. 买卖股票的最佳时机 IV(困难)</h1><h2 id="🐚核心思路-3"><a href="#🐚核心思路-3" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>在这道题中，股票最多可以完成 k 笔交易。相对于上一道动态规划：<strong>123.买卖股票的最佳时机III</strong> ，本题需要通过前两次的交易，来类比前k次的交易。其实也很简单，对着上一题找规律就行。<strong>但是有一点需要注意，我们要把[0][1]作为第一次买入了，为的就是处理第一次买入时的情况。</strong><br><img src="https://pic1.imgdb.cn/item/67e0e75f88c538a9b5c59d4d.png" alt="在这里插入图片描述"></p><p>如果按照规律我们是不是要这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k*<span class="number">2</span> - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">        dp[i][j] = Math.<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">        dp[i][j + <span class="number">1</span>] = Math.<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这肯定就矛盾了！我们最起码要从dp[0][0]开始初始化！</p><p><img src="https://pic1.imgdb.cn/item/67e0e78988c538a9b5c59d5b.png" alt="在这里插入图片描述"></p><h3 id="1）确定dp数组以及下标的含义-2"><a href="#1）确定dp数组以及下标的含义-2" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</p><p>j的状态表示为：</p><p>0 表示不操作<br>1 第一次买入<br>2 第一次卖出<br>3 第二次买入<br>4 第二次卖出<br>…..<br>除了0以外，<strong>偶数就是卖出，奇数就是买入</strong>。</p><h3 id="2）确定递推公式-2"><a href="#2）确定递推公式-2" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">    dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题和动态规划：<strong>123.买卖股票的最佳时机III</strong> 最大的区别就是这里<strong>要类比</strong> <code>j</code> 为奇数是买，偶数是卖的状态。</p><h3 id="3）初始化-2"><a href="#3）初始化-2" class="headerlink" title="3）初始化"></a>3）初始化</h3><p><code>dp[0][j]</code>当j为奇数的时候都初始化为 <code>-prices[0]</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-3"><a href="#🌴代码实现-3" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-3"><a href="#JAVA代码-3" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k*<span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个地方必须要从[0][1]开始买入算起，不能从[0][0]算第一次买入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k*<span class="number">2</span> - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是[0][0]算第一次买入，那下面这个式子的 j 不就成负数了</span></span><br><span class="line">                dp[i][j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][k*<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="309-买卖股票的最佳时机含冷冻期-中等"><a href="#309-买卖股票的最佳时机含冷冻期-中等" class="headerlink" title="309. 买卖股票的最佳时机含冷冻期(中等)"></a>309. 买卖股票的最佳时机含冷冻期(中等)</h1><p>在这道题中，尽可能地完成更多的交易（多次买卖一支股票），但有冷冻期，冷冻期为1天。相对于动态规划：<strong>122.买卖股票的最佳时机II</strong> ，本题加上了一个冷冻期。</p><h2 id="🐚核心思路-4"><a href="#🐚核心思路-4" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><h3 id="1）确定dp数组以及下标的含义-3"><a href="#1）确定dp数组以及下标的含义-3" class="headerlink" title="1）确定dp数组以及下标的含义"></a>1）确定dp数组以及下标的含义</h3><p>本题则需要第三个状态：不持有股票（冷冻期）的最多现金。</p><p>dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。</p><p>j的状态为：</p><p>0：持有股票后的最多现金<br>1：不持有股票（能购买）的最多现金<br>2：不持有股票（冷冻期）的最多现金</p><ul><li>dp[i][0] 表示第 i 天结束时持有股票的最大利润。</li><li>dp[i][1] 表示第 i 天结束时不持有股票并且不在冷冻期的最大利润。</li><li>dp[i][2] 表示第 i 天结束时不持有股票并且处于冷冻期的最大利润（即前一日刚卖出股票）。</li></ul><h3 id="2）确定递推公式-3"><a href="#2）确定递推公式-3" class="headerlink" title="2）确定递推公式"></a>2）确定递推公式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br></pre></td></tr></table></figure><h3 id="3）初始化-3"><a href="#3）初始化-3" class="headerlink" title="3）初始化"></a>3）初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-4"><a href="#🌴代码实现-4" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-4"><a href="#JAVA代码-4" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// [0][0]持有  [0][1]不持有  [0][2]冷冻</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);<span class="comment">// 保持持有或买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);<span class="comment">// 保持不持有或冷冻期结束</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i];<span class="comment">// 卖出后进入冷冻期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">2</span>],dp[prices.length-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>)); <span class="comment">// [持有股票, 不持有股票, 冷冻期]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 持有股票的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不持有股票的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 第一天不可能处于冷冻期</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 保持持有或买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 保持不持有或冷冻期结束</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]; <span class="comment">// 卖出后进入冷冻期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果是不持有股票并且不在冷冻期的最大利润</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="714-买卖股票的最佳时机含手续费-中等"><a href="#714-买卖股票的最佳时机含手续费-中等" class="headerlink" title="714. 买卖股票的最佳时机含手续费(中等)"></a>714. 买卖股票的最佳时机含手续费(中等)</h1><h2 id="🐚核心思路-5"><a href="#🐚核心思路-5" class="headerlink" title="🐚核心思路"></a>🐚核心思路</h2><p>这个题没什么难的，相比于<strong>122. 买卖股票的最佳时机II</strong> 无非就是多了一步最后计算手续费的步骤而已。</p><p>递推公式这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br></pre></td></tr></table></figure><h2 id="🌴代码实现-5"><a href="#🌴代码实现-5" class="headerlink" title="🌴代码实现"></a>🌴代码实现</h2><h3 id="JAVA代码-5"><a href="#JAVA代码-5" class="headerlink" title="JAVA代码"></a>JAVA代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架相关面试题</title>
      <link href="/2025/03/23/SSM%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/23/SSM%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="面试官：-Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#面试官：-Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="面试官： Spring,Spring MVC,Spring Boot 之间什么关系?"></a><strong>面试官：</strong> Spring,Spring MVC,Spring Boot 之间什么关系?</h3><p><strong>Spring MVC</strong> 是 <strong>Spring</strong> 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>![image-20250220112745225](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250220112745225.png)</p><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！<strong>Spring Boot</strong> 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 <strong>Spring MVC</strong> 作为 MVC 框架，只是说 <strong>Spring Boot</strong> 帮你简化了 <strong>Spring MVC</strong> 的很多配置，真正做到开箱即用！</p><h3 id="面试官：-RestController-vs-Controller"><a href="#面试官：-RestController-vs-Controller" class="headerlink" title="面试官：@RestController vs @Controller"></a><strong>面试官</strong>：@RestController vs @Controller</h3><p><strong>候选人</strong>：</p><blockquote><p>@Controller + @ResponseBody &#x3D; @RestController</p></blockquote><p><strong>Controller</strong> <strong>返回⼀个⻚⾯</strong></p><p>单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要<strong>返回⼀个视图</strong>的情况，这种情况属于⽐传统的Spring MVC 的应⽤，对应于前后端不分离的情况。</p><p>![image-20250220112800901](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250220112800901.png)</p><p><strong>@RestController 返回JSON 或 XML 形式数据</strong></p><p>@RestController <strong>只返回对象</strong>，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离）。</p><p>![image-20250220112812238](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250220112812238.png)</p><blockquote><p>@ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的<strong>转换器转换为指定的格式</strong>之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐多。</p></blockquote><p>![image-20250220112822929](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250220112822929.png)</p><h3 id="面试官：BeanFactory和FactoryBean有什么区别？"><a href="#面试官：BeanFactory和FactoryBean有什么区别？" class="headerlink" title="面试官：BeanFactory和FactoryBean有什么区别？"></a><strong>面试官</strong>：BeanFactory和FactoryBean有什么区别？</h3><p><strong>候选人</strong>：</p><p>1）BeanFactory是IoC容器，在程序启动时根据传入参数产生各种类型的bean，并添加到IoC容器的<strong>singletonObject</strong>属性中。</p><p>2）FactoryBean是个bean，存放在BeanFactory当中，在程序运行中产生指定类型的bean，并添加到IoC容器的factoryBeanObjectCache（缓存）当中。</p><blockquote><p>当你定义了一个 FactoryBean，Spring 通过它来创建真正的 bean，而不是将 FactoryBean 本身作为 bean 提供。</p></blockquote><h3 id="面试官：-Autowired-和-Resource-的区别是什么？"><a href="#面试官：-Autowired-和-Resource-的区别是什么？" class="headerlink" title="面试官：@Autowired 和 @Resource 的区别是什么？"></a><strong>面试官</strong>：@Autowired 和 @Resource 的区别是什么？</h3><p><strong>候选人</strong>：</p><ul><li><p><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</p></li><li><p><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</p></li><li><p>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过<strong>名称</strong>才能正确匹配到对应的 Bean。<code>@Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显示指定名称。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure><h3 id="面试官：-Spring-Bean-默认是单例的，如何保证并发安全"><a href="#面试官：-Spring-Bean-默认是单例的，如何保证并发安全" class="headerlink" title="面试官： Spring Bean 默认是单例的，如何保证并发安全?"></a><strong>面试官：</strong> Spring Bean 默认是单例的，如何保证并发安全?</h3><p><strong>候选人：</strong></p><p>Spring 的 Bean 默认都是单例的，某些情况下，单例是并发不安全的，以 <code>Controller</code> 举例，问题根源在于，我们可能会在 <code>Controller</code> 中定义成员变量，如此一来，多个请求来临，进入的都是同一个单例的 <code>Controller</code> 对象，并对此成员变量的值进行修改操作，因此会互相影响，无法达到并发安全（不同于线程隔离的概念，后面会解释到）的效果。</p><p>首先来举个例子，证明单例的并发不安全性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;testsingleton1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次访问此 url，可以看到每次的结果都是自增的，所以这样的代码显然是并发不安全的。</p><p>我们为了让无状态的海量 HTTP 请求之间不受影响，我们可以采取以下几种措施：</p><h4 id="1、单例变原型"><a href="#1、单例变原型" class="headerlink" title="1、单例变原型"></a><strong>1、单例变原型</strong></h4><p>对 web 项目，可以 <code>Controller</code> 类上加注解 <code>@Scope(&quot;prototype&quot;)</code> 或 <code>@Scope(&quot;request&quot;)</code>，</p><p>对非 web 项目，在 <code>Component</code> 类上添加注解 <code>@Scope(&quot;prototype&quot;)</code> 。</p><p>这种方式实现起来非常简单，但是很大程度上<strong>增大了 Bean 创建实例化销毁的服务器资源开销</strong>。</p><h4 id="2、尽量避免使用成员变量"><a href="#2、尽量避免使用成员变量" class="headerlink" title="2、尽量避免使用成员变量"></a><strong>2、尽量避免使用成员变量</strong></h4><p>有人说，单例 Bean 的成员变量这么麻烦，能不用成员变量就尽量避免这么用，在业务允许的条件下，将成员变量替换为方法中的局部变量，多省事。这种方式自然是最恰当的。代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;testsingleton1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// TODO biz code</span></span><br><span class="line">         <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但当很少的某种情况下，必须使用成员变量呢，我们该怎么处理？</p><h4 id="3、使用并发安全的容器"><a href="#3、使用并发安全的容器" class="headerlink" title="3、使用并发安全的容器"></a><strong>3、使用并发安全的容器</strong></h4><p>Java 作为功能性超强的编程语言，API 丰富，如果非要在单例 Bean 中使用成员变量，可以考虑使用并发安全的容器，如 <code>ConcurrentHashMap</code>、<code>ConcurrentHashSet</code> 等等。</p><h4 id="4、分布式或微服务的并发安全"><a href="#4、分布式或微服务的并发安全" class="headerlink" title="4、分布式或微服务的并发安全"></a><strong>4、分布式或微服务的并发安全</strong></h4><p>如果还要进一步考虑到微服务或分布式服务的影响，方式 4 便不足以处理了，所以可以借助于可以共享某些信息的分布式缓存中间件如 Redis 等，这样即可保证同一种服务的不同服务实例都拥有同一份共享信息（如当前运行中的任务列表等这类变量）。</p><h3 id="面试官：谈谈⾃⼰对于-Spring-IoC-和-AOP-的理解（高频）"><a href="#面试官：谈谈⾃⼰对于-Spring-IoC-和-AOP-的理解（高频）" class="headerlink" title="面试官：谈谈⾃⼰对于 Spring IoC 和 AOP 的理解（高频）"></a><strong>面试官</strong>：谈谈⾃⼰对于 Spring IoC 和 AOP 的理解<code>（高频）</code></h3><p><strong>候选人</strong>：</p><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>IoC（Inverse of Control：控制反转）是⼀种<strong>设计思想</strong>，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 容器实际上就是个Map（key，value），Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。</p><p> <strong>IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</strong> 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP是<strong>面向切面编程</strong>，在spring中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为<code>公共日志保存</code>，<code>事务处理</code>等。</p><p>Spring AOP 主要依赖<strong>动态代理</strong>来实现，接下来我会讲述 Spring AOP 的执行流程，主要分为六步。</p><p>当 Spring AOP 拦截一个方法调用时：</p><p>第一步是要<strong>定义切面（Aspect）</strong>，可以使用 <code>@Aspect</code> 标注类，并在其中定义切点（Pointcut）和通知（Advice），如 @Before、@After、@Around 等。</p><p>第二步是要<strong>解析切点</strong>，Spring 会解析 <code>@Pointcut</code> 表达式，确定需要增强的方法。</p><p>第三步是要<strong>创建代理对象</strong>，如果目标类实现了接口，Spring 使用 <strong>JDK 动态代理</strong>，通过 <code>Proxy.newProxyInstance</code> 生成代理对象；如果目标类没有实现接口，Spring 使用 <strong>CGLIB 动态代理</strong>，通过创建目标类的子类来生成代理对象。</p><p>第四步是要<strong>方法调用拦截</strong>，如果是JDK 动态代理，代理对象会拦截方法调用，并调用invoke，执行增强逻辑后，再调用目标方法；如果是CGLIB 动态代理，代理对象则通过 intercept 代理方法调用，执行增强逻辑后，再调用目标方法。</p><p>第五步是要<strong>执行增强逻辑</strong>，根据通知类型，在方法执行前后或异常时，执行对应的 AOP 逻辑，如日志记录、事务提交等。</p><p>第六步是要<strong>执行目标方法</strong>，最终调用目标对象的方法，完成实际业务逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/springcloud-community/image-bucket/2023/02/23/cb09feeb81d74dcc8dda0f5eac8fc795.png" alt="Comparison and application of Spring AOP and AspectJ - Spring Cloud"></p><h3 id="面试官：-什么是动态代理？（高频）"><a href="#面试官：-什么是动态代理？（高频）" class="headerlink" title="面试官： 什么是动态代理？（高频）"></a><strong>面试官：</strong> 什么是动态代理？<code>（高频）</code></h3><p>动态代理是一种在运行时动态生成代理对象，并在代理对象中增强目标对象方法的技术。它被广泛用于 AOP（面向切面编程）、权限控制、日志记录等场景，使得程序更加灵活、可维护。动态代理可以通过 JDK 原生的 Proxy 机制或 CGLIB 方式实现。接下来我会讲述动态代理的实现方式和执行流程。</p><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>首先，<strong>JDK 动态代理</strong>基于接口，适用于代理实现了接口的对象，当使用 JDK 动态代理时，主要分为四步，</p><p>第一步是<strong>定义接口</strong>，由于动态代理是基于接口进行代理的，因此目标对象必须实现接口。</p><p>第二步是<strong>创建并实现 InvocationHandler 接口</strong>，并在 invoke 方法中定义增强逻辑。</p><p>第三步是<strong>生成代理对象</strong>，使用 Proxy.newProxyInstance 创建代理对象，代理对象内部会调用 invoke 方法。</p><p>第四步是<strong>调用代理方法</strong>，当调用代理对象的方法时，invoke 方法会被触发，执行增强逻辑，并最终调用目标方法。</p><h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h4><p>其次，<strong>CGLIB</strong> 通过子类继承目标类，适用于没有实现接口的类，当使用 CGLIB 动态代理时，主要分为四步，</p><p>第一步是通过 Enhancer <strong>创建代理对象</strong>。</p><p>第二步是<strong>设置父类</strong>，CGLIB 代理基于子类继承，因此代理对象是目标类的子类。</p><p>第三步是<strong>定义并实现 MethodInterceptor 接口</strong>，在 intercept 方法中增强目标方法。</p><p>第四步是<strong>调用代理方法</strong>，当调用代理对象的方法时，intercept 方法会被触发，执行增强逻辑，并最终调用目标方法。</p><h3 id="面试官：-动态代理和静态代理的区别（高频）"><a href="#面试官：-动态代理和静态代理的区别（高频）" class="headerlink" title="面试官： 动态代理和静态代理的区别（高频）"></a><strong>面试官：</strong> 动态代理和静态代理的区别<code>（高频）</code></h3><p>动态代理和静态代理都属于代理模式，它们都用于在不修改目标对象代码的情况下增强其功能。接下来我会详细讲述动态代理和静态代理的五点区别。</p><p>第一点是<strong>实现方式</strong>的不同，静态代理需要手动编写代理类，而动态代理在运行时动态生成代理类。</p><p>第二点是<strong>灵活性</strong>的不同，静态代理不够灵活，代理类与目标类一一对应；而动态代理更加灵活，适用于多种目标类。</p><p>第三点是<strong>维护成本</strong>的不同，静态代理的维护成本较高，因为每个目标类都需要一个代理类；而动态代理的维护成本较低，因为代理逻辑是通用的。</p><p>第四点是<strong>技术依赖</strong>的不同，静态代理基于普通 Java 类；动态代理依赖反射或字节码技术。</p><p>第五点是<strong>适用场景</strong>的不同，静态代理则适用于简单的、目标类较少的场景；而动态代理适合需要为多个目标类添加相同逻辑的场景。</p><h3 id="面试官：将⼀个类声明为Spring的-bean-的注解有哪些"><a href="#面试官：将⼀个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="面试官：将⼀个类声明为Spring的 bean 的注解有哪些?"></a><strong>面试官</strong>：将⼀个类声明为Spring的 bean 的注解有哪些?</h3><p><strong>候选人</strong>：</p><p>我们⼀般使⽤ <code>@Autowired</code> 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现：</p><ol><li><p><code>@Component</code> ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。</p></li><li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要⽤于数据库相关操作。</p></li><li><p><code>@Service</code> : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。</p></li><li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯。</p></li></ol><h3 id="面试官：Spring中事务失效的场景有哪些（高频）"><a href="#面试官：Spring中事务失效的场景有哪些（高频）" class="headerlink" title="面试官：Spring中事务失效的场景有哪些（高频）"></a><strong>面试官</strong>：Spring中事务失效的场景有哪些<code>（高频）</code></h3><p><strong>候选人</strong>：<a href="https://blog.csdn.net/weixin_74199893/article/details/137992711?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522F5257AA1-4F50-4779-BD73-4A87810B06F3%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=F5257AA1-4F50-4779-BD73-4A87810B06F3&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-137992711-null-null.nonecase&utm_term=%E5%A4%B1%E6%95%88&spm=1018.2226.3001.4450">见文章：详解Spring事务失效的八种常见场景</a></p><p>第一个，如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了抛出去就行。</p><p>第二个，如果事务方法内部抛出了 <strong>运行时异常（RuntimeException）</strong>，Spring 会默认回滚事务。如果抛出了 <strong>受检查异常（Checked Exception）</strong>，Spring 默认不会回滚事务，除非使用 <code>@Transactional(rollbackFor = Exception.class)</code> 明确指定应当回滚受检查异常。</p><p>第三个，如果方法上不是public修饰的，也会导致事务失效。为了解决这个问题，我们需要将事务方法的访问修饰符改为public即可。</p><p>第四个，当方法内部通过 <strong>this</strong> 调用事务也会失败，需要通过上下文获取代理对象才能重启事务。</p><p>第五个，同一个Service类中非事务方法调用了事务性的方法，也会导致事务失效。解决方法：确保所有涉及数据库操作的方法都被<code>@Transactional</code>注解修饰。</p><p>第六个，当使用不支持事务的数据库引擎时，例如 MySQL 的 <strong>MyISAM</strong> 引擎不支持事务，即使代码中配置了事务管理，也无法生效。因此，确保使用的数据库引擎（如 <strong>InnoDB</strong>）支持事务是非常重要的。</p><h3 id="面试官：Spring的bean的生命周期（高频）"><a href="#面试官：Spring的bean的生命周期（高频）" class="headerlink" title="面试官：Spring的bean的生命周期（高频）"></a><strong>面试官</strong>：Spring的bean的生命周期<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>首先会通过一个非常重要的类，叫做<strong>BeanDefinition</strong>获取bean的定义信息，这里面就封装了bean的所有信息。在创建bean的时候：</p><p>第一步是调用构造函数实例化bean</p><p>第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成</p><p>第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行</p><p>第四步是执行了bean的前置处理器BeanPostProcessor对象的<strong>postProcessBeforeInitialization()</strong> ⽅法</p><p>第五步是初始化方法，比如实现了接口InitializingBean或者自定义init方法</p><p>第六步是执行了bean的后置处理器BeanPostProcessor对象的<strong>postProcessAfterInitialization()</strong> ⽅法，主要是对bean进行增强，有可能在这里产生<strong>代理对象</strong></p><p>最后一步是销毁bean</p><p><img src="https://chaycao-1302020836.cos.ap-shenzhen-fsi.myqcloud.com/chaycao%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2020/2020-02-14-%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E6%A6%82%E8%A6%81%EF%BC%89.png" alt="如何记忆Spring Bean的生命周期- 草捏子"></p><h3 id="面试官：Spring中的循环引用"><a href="#面试官：Spring中的循环引用" class="headerlink" title="面试官：Spring中的循环引用"></a><strong>面试官</strong>：Spring中的循环引用</h3><p><strong>候选人</strong>：</p><p>循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于A。</p><p>循环依赖在spring中是允许存在，spring框架依据<strong>三级缓存</strong>已经解决了<code>大部分</code>的循环依赖问题：</p><p>①一级缓存：单例池，缓存（已经经历了完整的生命周期，已经初始化完成的）bean对象</p><p>②二级缓存：缓存早期的bean对象（生命周期还没走完）</p><p>③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p><h3 id="面试官：那具体解决流程清楚吗？"><a href="#面试官：那具体解决流程清楚吗？" class="headerlink" title="面试官：那具体解决流程清楚吗？"></a><strong>面试官</strong>：那具体解决流程清楚吗？</h3><p><strong>候选人</strong>：</p><p>第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第二，A在初始化的时候需要B对象，这个走B的创建的逻辑</p><p>第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键</p><p>第五，B通过从通过二级缓存earlySingletonObjects  获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects  </p><p>第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一级缓存singletonObjects </p><p>第七，二级缓存中的临时对象A清除 </p><p>![image-20250220131739478](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250220131739478.png)</p><h3 id="面试官：构造方法出现了循环依赖怎么解决？"><a href="#面试官：构造方法出现了循环依赖怎么解决？" class="headerlink" title="面试官：构造方法出现了循环依赖怎么解决？"></a><strong>面试官</strong>：构造方法出现了循环依赖怎么解决？</h3><p><strong>候选人</strong>：</p><p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入，可以使用<code>@Lazy</code>懒加载，什么时候需要对象再进行bean对象的创建。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@lazy</span> B b)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：SpringMVC的执行流程知道嘛（高频）"><a href="#面试官：SpringMVC的执行流程知道嘛（高频）" class="headerlink" title="面试官：SpringMVC的执行流程知道嘛（高频）"></a><strong>面试官</strong>：SpringMVC的执行流程知道嘛<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>![image-20250220131759779](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250220131759779.png)</p><p>1、用户发送出请求到前端控制器DispatcherServlet，这是一个调度中心</p><p>2、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。</p><p>3、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p><p>4、DispatcherServlet调用HandlerAdapter（处理器适配器）。</p><p>5、HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）。</p><p>6、Controller执行完成返回ModelAndView对象。</p><p>7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</p><p>8、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。</p><p>9、ViewReslover解析后返回具体View（视图）。</p><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p><p>11、DispatcherServlet响应用户。</p><p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接返回结果。</p><h3 id="面试官：-和-的区别是什么？（高频）"><a href="#面试官：-和-的区别是什么？（高频）" class="headerlink" title="面试官：#{ }和${ }的区别是什么？（高频）"></a><strong>面试官</strong>：#{ }和${ }的区别是什么？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ol><li><p>符号类型</p><p><strong>#{ }</strong>：参数占位符，即预编译，对传入参数自动加单引号</p><p><strong>${ }</strong>：字符串替换符，即SQL拼接，对传入参数不加任何引号</p><blockquote><p><code>预编译（Prepared Statement）</code>是指将SQL语句模板提前编译为可执行计划，参数（如用户输入）在运行时绑定。这样可以避免SQL注入，并提高重复执行的效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PREPARE</span> stmt <span class="keyword">FROM</span> <span class="string">&#x27;SELECT * FROM users WHERE id = ?&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> stmt <span class="keyword">USING</span> <span class="variable">@id</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>防止注入问题</p><p><strong>#{ }</strong>：能防止SQl注入</p><p><strong>${ }</strong>：不能防止SQL注入</p></li><li><p>sql执行过程</p><p><strong>#{ }</strong>：先编译再取值</p><p><strong>${ }</strong>：先取值后编译</p></li><li><p>MyBatis排序时使用order by用${ }而不是#{ }</p></li><li><p>使用场景</p><p><strong>大部分情况下</strong>，特别是传入的值为用户输入、动态条件时，推荐使用 <code>#&#123; &#125;</code> 进行参数绑定。它能有效防止 SQL 注入，并且让代码更安全和简洁。</p><p><strong>表名、列名的动态拼接</strong>：这些不能作为参数绑定的元素，只能使用 <code>$&#123; &#125;</code> 进行拼接。<strong>拼接 SQL 片段</strong>：在一些复杂 SQL 语句（比如动态构造的 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句）中，可以使用 <code>$&#123; &#125;</code> 直接拼接。</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 插入用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO users (username, password, email) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 更新用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">    UPDATE users SET password = #&#123;password&#125; WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据动态表名查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRecordsByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Record&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM $&#123;tableName&#125; WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态列名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserOrderByColumn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users ORDER BY $&#123;columnName&#125; ASC</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态 SQL 片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsersWithConditions&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users</span><br><span class="line">    WHERE 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">        AND age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">        AND gender = #&#123;gender&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    ORDER BY $&#123;sortColumn&#125; $&#123;sortOrder&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="面试官：SpringBoot-是如何实现自动装配的？（高频）"><a href="#面试官：SpringBoot-是如何实现自动装配的？（高频）" class="headerlink" title="面试官：SpringBoot 是如何实现自动装配的？（高频）"></a><strong>面试官</strong>：SpringBoot 是如何实现自动装配的？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>在SpringBoot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是：</p><ul><li><code>@SpringBootConfiguration</code>：这也是一个配置类</li><li><code>@EnableAutoConfiguration</code>：springboot实现自动装配的<strong>核心注解</strong></li><li><code>@ComponentScan</code>: 组件扫描</li></ul><p>其中**@EnableAutoConfiguration**是实现自动装配的核心注解。</p><p>它通过 <code>@Import</code> 注解来导入一个特殊的配置类，这个配置类会读取项目及其依赖库中的 <code>META-INF/spring.factories</code> 文件里定义的自动配置类，并将它们注册到 Spring 容器中。</p><p>在这些配置类中所定义的Bean会根据<strong>条件注解</strong>所指定的条件决定是否需要将其导入到Spring容器中。</p><h3 id="面试官：Spring-的常见注解有哪些？"><a href="#面试官：Spring-的常见注解有哪些？" class="headerlink" title="面试官：Spring 的常见注解有哪些？"></a><strong>面试官</strong>：Spring 的常见注解有哪些？</h3><p><strong>候选人</strong>：</p><p>第一类是：声明bean，有**@Component、@Service、@Repository、@Controller**</p><p>第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse</p><p>第三类是：设置作用域 @Scope（singleton、prototype, request, session, global-session等）</p><p>第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和 @Bean </p><p>第五类是：跟aop相关做增强的注解  @Aspect，@Before，@After，@Around，@Pointcut</p><h3 id="面试官：SpringMVC常见的注解有哪些？"><a href="#面试官：SpringMVC常见的注解有哪些？" class="headerlink" title="面试官：SpringMVC常见的注解有哪些？"></a><strong>面试官</strong>：SpringMVC常见的注解有哪些？</h3><p><strong>候选人</strong>：</p><p>@RequestMapping：用于映射请求路径；</p><p><code>@RequestBody：</code>注解实现接收http请求的json数据，<strong>将json转换为java对象</strong>；</p><p>@RequestParam：指定请求参数的名称；</p><p><code>@PathViriable：</code>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数；</p><p><code>@ResponseBody：</code>注解实现将controller方法返回对象转化为指定类型对象响应给客户端。</p><p>@RequestHeader：获取指定的请求头数据，还有像@PostMapping、@GetMapping这些。</p><h3 id="面试官：MyBatis执行流程"><a href="#面试官：MyBatis执行流程" class="headerlink" title="面试官：MyBatis执行流程"></a><strong>面试官</strong>：MyBatis执行流程</h3><p><strong>候选人</strong>：</p><p>①读取MyBatis配置文件（mybatis-config.xml） ，加载运行环境和映射文件</p><p>②构造会话工厂SqlSessionFactory，一个项目只需要一个，单例的，一般由spring进行管理</p><p>③会话工厂创建SqlSession对象，这里面就含了执行SQL语句的所有方法</p><p>④操作数据库的接口，Executor执行器，同时负责查询缓存的维护</p><p>⑤Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</p><p>⑥输入参数映射</p><p>⑦输出结果映射</p><h3 id="面试官：MyBatis分⻚插件的原理是什么？"><a href="#面试官：MyBatis分⻚插件的原理是什么？" class="headerlink" title="面试官：MyBatis分⻚插件的原理是什么？"></a><strong>面试官</strong>：MyBatis分⻚插件的原理是什么？</h3><p><strong>候选人</strong>：</p><p>分⻚插件的基本原理是使⽤ Mybatis 提供的插件接⼝，实现⾃定义插件，在插件的拦截⽅法内拦截待执⾏的 sql，然后重写 sql，根据 dialect ⽅⾔，添加对应的物理分⻚语句和物理分⻚参数。</p><p>举例： <code>select _ from student</code> ，拦截 sql 后重写为： <code>select t._ from select \* from student t limit 0 10</code></p><h3 id="面试官：Mybatis是否支持延迟加载？"><a href="#面试官：Mybatis是否支持延迟加载？" class="headerlink" title="面试官：Mybatis是否支持延迟加载？"></a><strong>面试官</strong>：Mybatis是否支持延迟加载？</h3><p><strong>候选人</strong>：</p><p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p><p>Mybatis 仅⽀持 <strong>association 关联对象</strong>和 <strong>collection 关联集合对象</strong>的延迟加载，association 指的就是⼀对⼀，collection 指的就是⼀对多查询。</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载，默认是关闭的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazyLoadingEnabled=true|false</span><br></pre></td></tr></table></figure><h3 id="面试官：延迟加载的底层原理知道吗？"><a href="#面试官：延迟加载的底层原理知道吗？" class="headerlink" title="面试官：延迟加载的底层原理知道吗？"></a><strong>面试官</strong>：延迟加载的底层原理知道吗？</h3><p><strong>候选人</strong>：</p><p>延迟加载在底层主要使用的<strong>CGLIB动态代理</strong>完成的。</p><p>第一是，使用CGLIB创建目标对象的代理对象。</p><p>第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值（第一次延迟加载肯定为空），再执行sql查询。</p><p>第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了。</p><h3 id="面试官：Mybatis的一级、二级缓存用过吗？"><a href="#面试官：Mybatis的一级、二级缓存用过吗？" class="headerlink" title="面试官：Mybatis的一级、二级缓存用过吗？"></a><strong>面试官</strong>：Mybatis的一级、二级缓存用过吗？</h3><p><strong>候选人</strong>：</p><p>MyBatis的一级缓存基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。</p><blockquote><p><strong>PerpetualCache</strong>：持久化的缓存接口PerpetualCache，其内部实现是一个HashMap，用于存储查询结果。</p></blockquote><p>关于二级缓存需要单独开启：</p><p>二级缓存是基于Namespace和Mapper的作用域起作用的，不是依赖于Session，默认也是采用 PerpetualCache的HashMap 存储。</p><p>如果想要开启二级缓存需要在<strong>全局配置文件</strong>和<strong>映射文件</strong>中开启配置才行。</p><h3 id="面试官：Mybatis的二级缓存什么时候会清理缓存中的数据"><a href="#面试官：Mybatis的二级缓存什么时候会清理缓存中的数据" class="headerlink" title="面试官：Mybatis的二级缓存什么时候会清理缓存中的数据"></a><strong>面试官</strong>：Mybatis的二级缓存什么时候会清理缓存中的数据</h3><p><strong>候选人</strong>：</p><p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h3 id="相关阅读：手写SSM、手写SpringBoot"><a href="#相关阅读：手写SSM、手写SpringBoot" class="headerlink" title="相关阅读：手写SSM、手写SpringBoot"></a>相关阅读：<a href="https://blog.csdn.net/weixin_74199893/category_12663760.html?spm=1001.2014.3001.5482">手写SSM、手写SpringBoot</a></h3>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合相关面试题</title>
      <link href="/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java常见的集合类"><a href="#1-Java常见的集合类" class="headerlink" title="1 Java常见的集合类"></a>1 Java常见的集合类</h2><h3 id="面试官：说一说Java提供的常见集合？（高频）"><a href="#面试官：说一说Java提供的常见集合？（高频）" class="headerlink" title="面试官：说一说Java提供的常见集合？（高频）"></a><strong>面试官</strong>：说一说Java提供的常见集合？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>在java中提供了量大类的集合框架，主要分为两类：</p><p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p><ul><li>在Collection中有三个子接口List、Set和Queue。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。在Queue接口中有实现类PriorityQueue等。</li><li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的ConcurrentHashMap</li></ul><p>![image-20250303094632756](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250303094632756.png)</p><h3 id="面试官：说说List-Set-Map三者的区别？"><a href="#面试官：说说List-Set-Map三者的区别？" class="headerlink" title="面试官：说说List,Set,Map三者的区别？"></a><strong>面试官</strong>：说说List,Set,Map三者的区别？</h3><p><strong>候选人</strong>：</p><ul><li><p>List (对付顺序的好帮⼿)： 存储的元素是<strong>有序的</strong>、<strong>可重复</strong>的。</p></li><li><p>Set (注重独⼀⽆⼆的性质): 存储的元素是**⽆序的**、<strong>不可重复</strong>的。</p></li><li><p>Map (⽤ Key 来搜索的专家): 使⽤键值对（kye-value）存储，类似于数学上的函数y&#x3D;f(x)，“x”代表 key，”y”代表 value，<strong>Key 是⽆序的、不可重复的</strong>，<strong>value 是⽆序的、可重复的</strong>，每个键最多映射到⼀个值。</p></li></ul><h3 id="面试官：-常见集合的时间复杂度分析"><a href="#面试官：-常见集合的时间复杂度分析" class="headerlink" title="面试官： 常见集合的时间复杂度分析"></a><strong>面试官：</strong> 常见集合的时间复杂度分析</h3><p><strong>候选人</strong>：以下是各种常见数据结构的基本操作时间复杂度的简要概述：</p><h4 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h4><ul><li><strong>访问</strong>：O(1)，因为可以直接通过索引访问。</li><li><strong>插入&#x2F;删除</strong>：平均 O(n)，因为在中间位置插入或删除元素需要移动后续元素。</li><li><strong>搜索</strong>：O(n)，除非数组有序且使用二分查找，否则需要遍历整个数组。</li></ul><h4 id="2-单向链表（Singly-Linked-List）"><a href="#2-单向链表（Singly-Linked-List）" class="headerlink" title="2. 单向链表（Singly Linked List）"></a>2. 单向链表（Singly Linked List）</h4><ul><li><strong>访问</strong>：O(n)，因为需要从头节点开始遍历。</li><li><strong>插入&#x2F;删除</strong>：O(1)，如果已知前驱节点的话；否则需要 O(n) 来找到前驱节点。</li><li><strong>搜索</strong>：O(n)，因为需要遍历链表直到找到目标元素。</li></ul><h4 id="3-双向链表（Doubly-Linked-List）"><a href="#3-双向链表（Doubly-Linked-List）" class="headerlink" title="3. 双向链表（Doubly Linked List）"></a>3. 双向链表（Doubly Linked List）</h4><ul><li><strong>访问</strong>：O(n)，因为也需要从头节点或尾节点开始遍历。</li><li><strong>插入&#x2F;删除</strong>：O(1)，如果已知前驱或后继节点的话；否则需要 O(n) 来找到前驱或后继节点。</li><li><strong>搜索</strong>：O(n)，因为需要遍历链表直到找到目标元素。</li></ul><h4 id="4-二叉搜索树（Binary-Search-Tree）"><a href="#4-二叉搜索树（Binary-Search-Tree）" class="headerlink" title="4. 二叉搜索树（Binary Search Tree）"></a>4. 二叉搜索树（Binary Search Tree）</h4><ul><li><strong>最佳情况（平衡）</strong>：<ul><li><strong>访问&#x2F;搜索</strong>：O(log n)，如果树是平衡的。</li><li><strong>插入&#x2F;删除</strong>：O(log n)，如果树是平衡的。</li></ul></li><li><strong>最坏情况（不平衡）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(n)，如果树退化成链式结构。</li></ul></li></ul><h4 id="5-红黑树（Red-Black-Tree）"><a href="#5-红黑树（Red-Black-Tree）" class="headerlink" title="5. 红黑树（Red-Black Tree）"></a>5. 红黑树（Red-Black Tree）</h4><ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(log n)，因为红黑树是一种自平衡的二叉搜索树，能够保持树的高度较低。</li></ul><h4 id="6-散列表（Hash-Table）"><a href="#6-散列表（Hash-Table）" class="headerlink" title="6. 散列表（Hash Table）"></a>6. 散列表（Hash Table）</h4><ul><li><strong>理想情况（均匀分布）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：平均 O(1)，理想情况下，哈希函数将键均匀分布在哈希表中，减少了冲突。</li></ul></li><li><strong>最坏情况（严重冲突）</strong>：<ul><li><strong>访问&#x2F;搜索&#x2F;插入&#x2F;删除</strong>：O(n)，如果哈希函数导致大量冲突，性能退化。</li></ul></li></ul><h2 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h2><h3 id="面试官：ArrayList底层是如何实现的？-jdk1-8源码解析"><a href="#面试官：ArrayList底层是如何实现的？-jdk1-8源码解析" class="headerlink" title="面试官：ArrayList底层是如何实现的？(jdk1.8源码解析)"></a><strong>面试官</strong>：ArrayList底层是如何实现的？(jdk1.8源码解析)</h3><p><strong>候选人</strong>：</p><ol><li>类定义与成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部使用的数组，用于存储元素</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列表的实际大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初识容量为10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认的空数组，用于初始化空的 ArrayList</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空闲数组，用于优化 ArrayList 的行为</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>构造函数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，初始化为空数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始容量的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从 Collection 初始化 ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="comment">// 第一步：确保数组已使用长度（size）加1之后足够存下下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 第三步：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 第四步：返回添加成功布尔值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>获取元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查索引是否合法。</span></span><br><span class="line">    RangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">RangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#面试官：ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="面试官：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a><strong>面试官</strong>：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h3><p><strong>候选人</strong>：</p><p>在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p><h3 id="面试官：说⼀说-ArrayList-的扩容机制吧？"><a href="#面试官：说⼀说-ArrayList-的扩容机制吧？" class="headerlink" title="面试官：说⼀说 ArrayList 的扩容机制吧？"></a><strong>面试官</strong>：说⼀说 ArrayList 的扩容机制吧？</h3><p>**候选人：**在添加元素时会检查当前数组的容量是否足够存放新的元素。如果不足够，则会触发扩容操作。扩容机制主要包括以下几个步骤：</p><ol><li><p><strong>检测容量不足</strong>：当尝试添加新元素时，<code>ArrayList</code> 会先检查当前的容量是否足以容纳新的元素。</p></li><li><p><strong>触发扩容</strong>：如果当前容量不足，则会调用 <code>ensureCapacityInternal</code> 方法来确保有足够的空间。</p></li><li><p><strong>计算新容量</strong>：通常情况下，新容量为当前容量的 1.5 倍。</p></li><li><p><strong>执行扩容</strong>：使用 <code>Arrays.copyOf</code> 方法来创建一个新的数组，并将旧数组的内容拷贝到新数组中。</p></li></ol><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保有足够的容量来存放新的元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将新元素放置在当前 size 的位置，并将 size 增加 1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回添加成功的标志</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果所需的最小容量大于当前数组的长度，则调用 grow 方法</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算新的容量，默认情况下是旧容量的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量仍然小于所需的最小容量，则使用所需的最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量超过最大数组大小，则使用大的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用新的容量创建一个新的数组，并拷贝旧数组的内容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：-为什么数组索引从0开始？"><a href="#面试官：-为什么数组索引从0开始？" class="headerlink" title="面试官： 为什么数组索引从0开始？"></a><strong>面试官：</strong> 为什么数组索引从0开始？</h3><p><strong>候选人：</strong></p><p>在根据数据索引获取元素的时候，会用索引和寻址公式来计算内存中所对应的元素数据。</p><blockquote><p>数组索引从0开始，寻址公式可以简化为：</p><p><strong>arr[i] &#x3D; baseAddress + i * dataTypeSize</strong><br>地址&#x3D;基地址+(索引×元素大小)</p></blockquote><p>如果数组的索引从1开始，寻址公式中就会增加一次减法操作，对CPU来说就多了一条指令，性能不高。</p><blockquote><p>如果索引从1开始，则寻址公式变为：</p><p><em><em>arr[i] &#x3D; baseAddress + (i - 1)</em> dataTypeSize</em>*<br>地址&#x3D;基地址+((索引−1)×元素大小)</p></blockquote><h3 id="面试官：如何实现数组和List之间的转换"><a href="#面试官：如何实现数组和List之间的转换" class="headerlink" title="面试官：如何实现数组和List之间的转换"></a><strong>面试官</strong>：如何实现数组和List之间的转换</h3><p><strong>候选人</strong>：</p><ol><li><p><strong>数组转List</strong>：可以使用 <code>Arrays.asList(T... a)</code> 方法将数组转换为 <code>List</code>。该方法返回一个基于原数组的 <code>List</code>，所以它是一个固定大小的列表，不能进行添加或删除操作，但可以修改元素。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br></pre></td></tr></table></figure></li><li><p><strong>List 转数组</strong>：可以使用 <code>List</code> 的 <code>toArray()</code> 方法将 <code>List</code> 转换为数组。</p><ul><li><strong><code>toArray()</code></strong>：返回一个包含所有 <code>List</code> 元素的数组，但该数组类型是 <code>Object[]</code>，需要类型转换。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>toArray(new String[0])</code> 中的 <code>new String[0]</code> 是为了确保返回的数组类型正确，而不是使用 <code>new String[list.size()]</code>，这样可以避免在一些情况下的性能问题。</p></blockquote></li></ol><h3 id="面试官：用Arrays-asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗"><a href="#面试官：用Arrays-asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗" class="headerlink" title="面试官：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗"></a><strong>面试官</strong>：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗</h3><p><strong>候选人</strong>：</p><ul><li><strong>Arrays.asList</strong> 转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是<strong>同一个内存地址</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] array = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改数组的元素</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;List: &quot;</span> + list); <span class="comment">// 输出 List: [X, B, C]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Array: &quot;</span> + Arrays.toString(array)); <span class="comment">// 输出 Array: [X, B, C]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list用了 <strong>toArray</strong> 转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了<strong>数组的拷贝</strong>，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 toArray 方法转换为数组</span></span><br><span class="line">        String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 List</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;List: &quot;</span> + list); <span class="comment">// 输出 List: [X, B, C]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Array: &quot;</span> + Arrays.toString(array)); <span class="comment">// 输出 Array: [A, B, C]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：ArrayList-和-LinkedList-的区别是什么？（高频）"><a href="#面试官：ArrayList-和-LinkedList-的区别是什么？（高频）" class="headerlink" title="面试官：ArrayList 和 LinkedList 的区别是什么？（高频）"></a><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ol><li><p><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>底层数据结构：</strong> Arraylist 底层使⽤的是 <strong>Object</strong> <strong>数组</strong>； LinkedList 底层使⽤的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</p></li><li><p><strong>插⼊和删除是否受元素位置的影响：</strong> ① <strong>ArrayList</strong> <strong>采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。</strong> ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置插⼊和删除元素的话时间复杂度就为 O(n)。②<strong>LinkedList</strong> <strong>采⽤链表存储，所以对于</strong> <strong>add(E e)</strong> <strong>⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似O(1)</strong>，如果是要在指定位置插⼊和删除元素的话（ (add(int index, Eelement) ） 时间复杂度近似为o(n)。</p></li><li><p><strong>是否⽀持快速随机访问：</strong> LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。（数组天然⽀持随机访问，时间复杂度为 <strong>O(1)</strong>，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 <strong>O(n)</strong>，所以不⽀持快速随机访问。）</p></li><li><p><strong>内存空间占⽤：</strong> ArrayList 底层是数组，内存连续，节省内存；LinkedList 是双向链表需要存储数据和两个指针，更占用内存。</p></li><li><p>**应用场景：**访问频繁选数组，插删频繁选链表。</p></li></ol><blockquote><p>补充：<strong>双向链表和双向循环链表</strong></p><p><strong>双向链表：</strong> 包含两个指针，⼀个 prev 指向前⼀个节点，⼀个 next 指向后⼀个节点。</p><p>![image-20250218112654847](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112654847.png)</p><p><strong>双向循环链表：</strong> 最后⼀个节点的 next 指向 head，⽽ head 的 prev 指向最后⼀个节点，构成⼀个环。</p><p>![image-20250218112704475](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112704475.png)</p></blockquote><blockquote><p>补充：<strong>RandomAccess接⼝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接⼝中什么都没有定义。所以，在我看来<code>RandomAccess</code> 接⼝不过是⼀个标识罢了。标识什么？ 标识实现这个接⼝的类具有随机访问功能。ArrayList 实现了 <code>RandomAccess</code> 接⼝，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接⼝只是标识，<strong>并不是说 ArrayList实现 RandomAccess 接⼝才具有快速随机访问功能的！</strong></p></blockquote><h3 id="面试官：-ArrayList-与-Vector-区别？"><a href="#面试官：-ArrayList-与-Vector-区别？" class="headerlink" title="面试官：  ArrayList 与 Vector 区别？"></a><strong>面试官：</strong>  ArrayList 与 Vector 区别？</h3><p><strong>候选人：</strong></p><p>• <strong>线程安全性:</strong> Vector是线程安全的，ArrayList不是线程安全的。</p><p>• <strong>扩容策略:</strong> ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</p><blockquote><p>ArrayList和Vector都支持动态扩容，都属于动态数组。</p></blockquote><h3 id="面试官：刚才你说了ArrayList-和-LinkedList-不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？"><a href="#面试官：刚才你说了ArrayList-和-LinkedList-不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？" class="headerlink" title="面试官：刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？"></a><strong>面试官</strong>：刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</h3><p><strong>候选人</strong>：</p><p>主要有两种解决方案：</p><p>第一：我们使用这个集合，优先在方法内使用，定义为<strong>局部变量</strong>，且不能逃离方法的作用范围。这样的话，就不会出现线程安全问题。</p><p>第二：如果非要在成员变量中使用的话，可以使用<strong>线程安全的集合</strong>来替代</p><ul><li><p>ArrayList可以通过Collections 的 <strong>synchronizedList</strong> 方法将 ArrayList 转换成线程安全的容器后再使用。</p></li><li><p>LinkedList 换成<strong>ConcurrentLinkedQueue</strong>来使用</p></li></ul><h2 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3 HashMap"></a>3 HashMap</h2><h3 id="前提知识：红黑树和二叉搜索树（Binary-Search-Tree-BST）"><a href="#前提知识：红黑树和二叉搜索树（Binary-Search-Tree-BST）" class="headerlink" title="前提知识：红黑树和二叉搜索树（Binary Search Tree,BST）"></a>前提知识：红黑树和二叉搜索树（Binary Search Tree,BST）</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型。</p><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p><p>![image-20250218112825681](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112825681.png)</p><h4 id="红黑树（高频）"><a href="#红黑树（高频）" class="headerlink" title="红黑树（高频）"></a>红黑树<code>（高频）</code></h4><p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）。</p><p>![image-20250218112839568](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112839568.png)</p><p>（2）红黑树的特质</p><p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p><p>性质2：根节点是<strong>黑色</strong></p><p>性质3：叶子节点都是黑色的空节点</p><p>性质4：红黑树中红色节点的子节点都是黑色</p><p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p><p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong>。</p><h3 id="面试官：说一下HashMap的实现原理？"><a href="#面试官：说一下HashMap的实现原理？" class="headerlink" title="面试官：说一下HashMap的实现原理？"></a><strong>面试官</strong>：说一下HashMap的实现原理？</h3><p><strong>候选人</strong>：</p><p>1，底层使用hash表数据结构，即<strong>数组 + 链表 &#x2F; 红黑树</strong>。</p><p>2，添加数据时，计算key的值确定元素在数组中的下标。</p><ul><li><p>key相同则替换</p></li><li><p>不同则存入链表或红黑树中</p></li></ul><p>3，获取数据通过key的hash计算数组下标获取元素。</p><h3 id="面试官：HashMap的jdk1-7和jdk1-8有什么区别（高频）"><a href="#面试官：HashMap的jdk1-7和jdk1-8有什么区别（高频）" class="headerlink" title="面试官：HashMap的jdk1.7和jdk1.8有什么区别（高频）"></a><strong>面试官</strong>：HashMap的jdk1.7和jdk1.8有什么区别<code>（高频）</code></h3><p><strong>候选人</strong>：</p><ul><li><p>JDK1.7采用的是拉链法，<strong>数组+链表</strong>。在扩容时使用**“头插法”<strong>插入新元素。这种方式会导致链表顺序反转，在多线程环境下，可能引发环形链表问题，导致程序死循环。扩容是</strong>“先扩容后插入”**，无论是否发生哈希冲突，都会执行扩容操作，可能导致无效扩容。</p></li><li><p>JDK1.8之后采用<strong>数组+链表+红黑树</strong>，链表长度大于8且数组长度大于64则会从链表转化为红黑树。改为**“尾插法”<strong>插入，保证链表顺序一致，避免了扩容中的死循环问题。扩容变为</strong>“先插入再扩容”**，只有当插入后超过阈值或发生哈希冲突时，才会触发扩容，减少了不必要的操作。</p></li></ul><blockquote><p>补充：什么是拉链法？</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建⼀个链表数组，数组中每⼀格就是⼀个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></blockquote><blockquote><p>jdk1.8 中将链表改造红黑树还有一个非常重要的原因，可以防止DDos攻击。</p><p><strong>DDos 攻击</strong>：分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS）</p><p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个。</p></blockquote><h3 id="面试官：知道hashmap在1-7情况下的多线程死循环问题吗？"><a href="#面试官：知道hashmap在1-7情况下的多线程死循环问题吗？" class="headerlink" title="面试官：知道hashmap在1.7情况下的多线程死循环问题吗？"></a><strong>面试官</strong>：知道hashmap在1.7情况下的多线程死循环问题吗？</h3><p><strong>候选人</strong>：</p><h4 id="Java-1-7-中的死循环问题"><a href="#Java-1-7-中的死循环问题" class="headerlink" title="Java 1.7 中的死循环问题"></a>Java 1.7 中的死循环问题</h4><p>在Java 1.7中，<code>HashMap</code>采用的是“头插法”进行扩容。这意味着在扩容时，旧数组中的元素会根据新的索引位置被插入到新数组对应的链表头部。当两个或更多的线程几乎同时进行扩容操作时，可能会导致如下情形：</p><ol><li><strong>线程一读取并开始扩容</strong>：假设线程一开始读取<code>HashMap</code>并准备进行扩容。此时，它读取到了某个链表，该链表包含节点A和节点B（顺序为A -&gt; B）。</li><li><strong>线程二介入并完成扩容</strong>：在线程一还没有完成扩容之前，线程二也开始了扩容操作。线程二按照头插法将节点A和节点B重新插入新数组中的对应位置，但是顺序变成了B -&gt; A（因为A先插入，然后B插入到A的前面）。</li><li><strong>线程一继续执行</strong>：当线程一恢复执行时，它尝试将节点A插入新数组中的对应位置。按照头插法，它会将A插入到链表的头部。然而，此时节点B已经在链表的头部，并且B的<code>next</code>已经指向了A。因此，当线程一将A插入时，A的<code>next</code>又指向了B，这就形成了一个循环链表（A -&gt; B -&gt; A）。</li></ol><h4 id="解决方法：Java-1-8-的尾插法"><a href="#解决方法：Java-1-8-的尾插法" class="headerlink" title="解决方法：Java 1.8 的尾插法"></a>解决方法：Java 1.8 的尾插法</h4><p>Java 1.8中的<code>HashMap</code>采用了“尾插法”，而不是头插法来进行扩容。这意味着在扩容时，元素会插入到链表的末尾，而不是头部。这样做的好处在于，即使多个线程几乎同时进行扩容，也不会改变链表原有的顺序，从而避免了循环链表的产生。</p><h3 id="面试官：说下HashMap中put方法的具体流程（高频）"><a href="#面试官：说下HashMap中put方法的具体流程（高频）" class="headerlink" title="面试官：说下HashMap中put方法的具体流程（高频）"></a><strong>面试官</strong>：说下HashMap中put方法的具体流程<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p>![image-20250218112948771](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218112948771.png)</p><ul><li>首先判断键值对数组table是否为空，如果为空则执行resize()进行扩容（初始化长度为16的数组）</li><li>如果不为空则根据key计算hash值，得到数组的索引</li><li>判断该索引位置是否为空，如果为空直接<strong>插入</strong>即可，否则进行后续操作</li><li>判断当前索引位置上的key是否与要插入元素的key相同（是否存在），存在相同的话直接<strong>覆盖value</strong>就可以了</li><li>不相同的话判断该位置是否为红黑树，如果是红黑树，则直接在树中<strong>插入</strong>键值对即可</li><li>如果不是的话就要遍历链表，判断该位置的key是否存在，如果存在相同的直接<strong>覆盖value</strong>即可</li><li>如果不相同的话就使用尾插法，并判断链表长度是否大于8，大于8的话把链表转换为红黑树，走红黑树<strong>插入</strong>的逻辑</li><li>最后一步，就是在以上所有涉及到插入的操作中，判断<strong>实际存在的键值对数量size</strong>（也就是++size）是否超出了最大容量threshold，如果超过，就进行扩容。</li></ul><p>添加元素的时候至少考虑三种情况：</p><blockquote><ol><li>数组位置为null</li><li>数组位置不为null，键重复，元素覆盖</li><li>数组位置不为null，键不重复，挂在下面形成链表或者红黑树</li></ol></blockquote><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//参数一：键</span></span><br><span class="line">    <span class="comment">//参数二：值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值：被覆盖元素的值，如果没有覆盖，返回null</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用键计算出对应的哈希值，再把哈希值进行一些额外的处理</span></span><br><span class="line"><span class="comment">//简单理解：返回值就是返回键的哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个局部变量，用来记录哈希表中数组的地址值。</span></span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="comment">//临时的第三方变量，用来记录键值对对象的地址值</span></span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="comment">//表示当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//表示索引</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//把哈希表中数组的地址值，赋值给局部变量tab</span></span><br><span class="line">    tab = table;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//1.如果当前是第一次添加数据，底层会创建一个默认长度为16，加载因子为0.75的数组</span></span><br><span class="line">        <span class="comment">//2.如果不是第一次添加数据，会看数组中的元素是否达到了扩容的条件</span></span><br><span class="line">        <span class="comment">//如果没有达到扩容条件，底层不会做任何操作</span></span><br><span class="line">        <span class="comment">//如果达到了扩容条件，底层会把数组扩容为原先的两倍，并把数据全部转移到新的哈希表中</span></span><br><span class="line">        tab = resize();</span><br><span class="line">        <span class="comment">//表示把当前数组的长度赋值给n</span></span><br><span class="line">        n = tab.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿着数组的长度跟键的哈希值进行计算，计算出当前键值对对象，在数组中应存入的位置</span></span><br><span class="line">    i = (n - <span class="number">1</span>) &amp; hash;   <span class="comment">//index</span></span><br><span class="line">    <span class="comment">//获取数组中对应元素的数据</span></span><br><span class="line">    p = tab[i];</span><br><span class="line">    <span class="comment">//判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//等号的左边：数组中键值对的哈希值</span></span><br><span class="line">        <span class="comment">//等号的右边：当前要添加键值对的哈希值</span></span><br><span class="line">        <span class="comment">//如果键不一样，此时返回false</span></span><br><span class="line">        <span class="comment">//如果键一样，返回true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> p.hash == hash;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (b1 &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            <span class="comment">//判断数组中获取出来的键值对是不是红黑树中的节点</span></span><br><span class="line">            <span class="comment">//如果是，则调用方法putTreeVal，把当前的节点按照红黑树的规则添加到树当中。</span></span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果从数组中获取出来的键值对不是红黑树中的节点</span></span><br><span class="line">            <span class="comment">//表示此时下面挂的是链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//判断当前链表长度是否超过8，如果超过8，就会调用方法treeifyBin</span></span><br><span class="line">                    <span class="comment">//treeifyBin方法的底层还会继续判断:判断数组的长度是否大于等于64</span></span><br><span class="line">                    <span class="comment">//如果同时满足这两个条件，就会把这个链表转成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为覆盖操作</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                    p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出旧值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//threshold：记录的就是数组的长度 * 0.75，哈希表的扩容时机  16 * 0.75 = 12</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//表示当前没有覆盖任何元素，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：讲一讲HashMap的扩容机制（高频）"><a href="#面试官：讲一讲HashMap的扩容机制（高频）" class="headerlink" title="面试官：讲一讲HashMap的扩容机制（高频）"></a><strong>面试官</strong>：讲一讲HashMap的扩容机制<code>（高频）</code></h3><p><strong>候选人</strong>：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/29843beb4a42651eaf128ed6fc316417.jpeg" alt="请添加图片描述"></p><ul><li>在添加元素或初始化的时候需要调用resize()方法进行扩容，第一次添加数据初始化数组长度为16，以后每次扩容都是达到了扩容阈值（数组长度 * 0.75）</li></ul><blockquote><p>扩容阈值 &#x3D; 数组容量 * 加载因子（默认为0.75）</p><p>负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。</p></blockquote><ul><li><p>每次扩容的时候，都是扩容之前容量的2倍； </p></li><li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p></li><li><p>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p></li><li><p>有冲突节点的话，如果是红黑树，就走红黑树的添加</p></li><li><p>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ul><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？"><a href="#面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="面试官：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？"></a><strong>面试官</strong>：了解hashMap的寻址算法吗？为何HashMap的数组长度一定是2的次幂？</h3><p><strong>候选人</strong>：JDK 1.8 的 hash ⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二次哈希：首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p><p>在putValue的方法中，计算数组下标的时候使用<strong>hash值与数组长度取模</strong>得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了<strong>数组长度-1</strong> 得到一个值，用这个值按位<strong>与运算</strong>hash值，最终得到数组的位置。（也就是说 **hash%length&#x3D;&#x3D;hash&amp;(length-1)**的前提是 length 是2的 <strong>n</strong> <strong>次⽅）<strong>并且采⽤⼆进制位操作 &amp;，相对于 % 能够提⾼运算效率，这就解释了</strong>HashMap</strong> <strong>的⻓度为什么是2的幂次⽅。</strong></p><h3 id="面试官：好的，hashmap是线程安全的吗？"><a href="#面试官：好的，hashmap是线程安全的吗？" class="headerlink" title="面试官：好的，hashmap是线程安全的吗？"></a><strong>面试官</strong>：好的，hashmap是线程安全的吗？</h3><p><strong>候选人</strong>：不是线程安全的</p><h3 id="面试官：那我们想要使用线程安全的map该怎么做呢？"><a href="#面试官：那我们想要使用线程安全的map该怎么做呢？" class="headerlink" title="面试官：那我们想要使用线程安全的map该怎么做呢？"></a><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</h3><p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p><h3 id="面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）"><a href="#面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）" class="headerlink" title="面试官：那你能聊一下ConcurrentHashMap的原理吗？（高频）"></a><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？<code>（高频）</code></h3><blockquote><p>《Java并发编程的艺术》 6.1.1 为什么要使用 ConcurrentHashMap?</p><p>在并发编程中使用 HashMap 可能导致程序死循环。而使用线程安全的 HashTable 效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap 的登场机会。</p><p>（1）线程不安全的HashMap</p><p>在多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近100%，所以在并发情况下不能使用 HashMap。HashMap 在并发执行 put 操作时会引起死循环，是因为多线程会导致 HashMap 的 Entry 链表形成<strong>环形数据结构</strong>，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取 Entry。</p><p>（2）效率低下的HashTable（一锁就锁全表）</p><p>HashTable 容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable 的效率非常低下。因为当一个线程访问HashTable 的同步方法，其他线程也访问HashTable 的同步方法时，会进入阻塞或轮询状态。如线程1使用 put 进行元素添加，线程2 不但不能使用 put 方法添加元素，也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p><p>（3）ConcurrentHashMap 的锁分段技术可有效提升并发访问率</p><p>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap 所使用的锁分段技术。</p></blockquote><p><strong>候选人</strong>：ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong>。</li></ul><p>在jdk1.7中ConcurrentHashMap 是由Segment 数组结构和HashEntry数组结构组成。Segment 是一种可重入锁(类似ReentrantLock)，扮演锁的⻆⾊。HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个Segment数组。一个Segment 里包含一个 HashEntry 数组，<strong>每个 HashEntry 是一个链表结构的元素</strong>，每个 Segment 守护着一个 HashEntry 数组，当对 HashEntry 数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p><p>![image-20250218113808758](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218113808758.png)</p><p>在jdk1.8中ConcurrentHashMap 取消了 Segment 分段锁，采⽤ <strong>CAS 和 synchronized</strong> 来保证并发安全。虽然 <code>CAS</code> 能保证<strong>单个变量</strong>的原子更新，但在 <strong>多个变量关联修改</strong> 时，就会产生<strong>ABA 问题</strong>或 <strong>自旋失败问题</strong>，因此 JDK 1.8 <code>ConcurrentHashMap</code> 仍然<strong>结合 <code>synchronized</code></strong> 来保证更复杂场景的安全。</p><blockquote><p>ABA 问题是 <strong>CAS（Compare-And-Swap）</strong> 机制中的一种特殊并发问题，指的是：<br><strong>某个变量的值从 A 变为 B，然后又变回 A，CAS 机制无法察觉这个变化，从而导致错误的结果。</strong></p><p>在 <strong>高并发环境</strong> 下，如果线程在 CAS 操作时仅仅判断值是否相等，而不检查是否发生过中间修改，就可能出现 ABA 问题。</p></blockquote><h3 id="面试官：说说ConcurrentHashMap的get、put、size操作"><a href="#面试官：说说ConcurrentHashMap的get、put、size操作" class="headerlink" title="面试官：说说ConcurrentHashMap的get、put、size操作"></a><strong>面试官</strong>：说说ConcurrentHashMap的get、put、size操作</h3><p><strong>候选人</strong>：（源自《Java并发编程的艺术》 6.1.5节）</p><p><strong>get操作：</strong></p><p>先经过一次散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key.hashcode());</span><br><span class="line">  <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。我们知道 HashTable 容器的 get 方法是需要加锁的，那么 <strong>ConcurrentHashMap 的 get 操作是如何做到不加锁</strong>的呢？原因是它的 get方法里将要使用的共享变量都定义成 <strong>volatile</strong> 类型。定义成 volatile 的变量，能够在线程之间保持可见性，<strong>能够被多线程同时读，并且保证不会读到过期的值</strong>，但是只能被单线程写(有一种情况可以被多线程写，就是写入的值不依赖于原值)，在get操作里只需要读不需要写共享变量 count 和 value，所以可以不用加锁。之所以不会读到过期的值，是因为根据 <strong>Java 内存模型的 happens-before 原则</strong>，对 volatile 字段的写入操作先于读操作，即使两个线程同时修改和获取 volatile 变量，get操作也能拿到最新的值，这是用 volatile替换锁的经典应用场景。</p><p><strong>put操作：</strong></p><p>由于 put 方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放在 HashEnty 数组里。</p><p>1）是否需要扩容</p><p>在插入元素前会先判断Segment 里的 HashEnty数组是否超过容量(threshold)，如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比 HashMap 更恰当，因为 HashMap 是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，可能扩容之后没有新元素插入，这时 HashMap 就进行了一次无效的扩容。</p><p>2）如何扩容</p><p>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个 Segment 进行扩容。</p><p><strong>size 操作：</strong></p><p>如果要统计整个 ConcurrentHashMap 里元素的大小，就必须统计所有 Segment 里元素的大小后求和。Segment里的全局变量 count 是一个 volatile 变量，那么在多线程场景下，是不是直接把所有 Segment 的 count 相加就可以得到整个 ConcurrentHashMap 大小了呢? 不是的，虽然相加时可以获取每个 Segment 的 count 的最新值，但是可能累加前使用的 count 发生了变化，那么统计结果就不准了。所以，最安全的做法是在统计size的时候把所有Segment 的put、remove 和 clean 方法全部锁住，但是这种做法显然非常低效。</p><p>因为在累加 count 操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap 的做法是<strong>尝试2次</strong>：通过不锁住Segment的方式来统计各个Segment大小；如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment 的大小。</p><p>那么 ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢?使用modCount 变量，在 put、remove 和 clean 方法里操作元素前都会将变量 modCount 进行加1.那么在统计 size 前后比较 modCount 是否发生变化，从而得知容器的大小是否发生变化。</p><h3 id="面试官：ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#面试官：ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="面试官：ConcurrentHashMap用了悲观锁还是乐观锁?"></a><strong>面试官</strong>：ConcurrentHashMap用了悲观锁还是乐观锁?</h3><p><strong>候选人</strong>：悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空:</p><p>• 如果为空则使用 <code>volatile + CAS (乐观锁)</code> 来初始化。</p><p>• 如果容器不为空，则根据存储的元素计算该位置是否为空。</p><p>•如果根据存储的元素计算结果为空，则利用<code>CAS(乐观锁)</code> 设置该节点;</p><p>• 如果根据存储的元素计算结果不为空，则使用 synchronized(悲观锁)，然后遍历桶中的数据并替换或新增节点到桶中，最后再判断是否需要转为红黑树,这样就能保证并发访问时的线程安全了。</p><h3 id="面试官：HashSet与HashMap的区别？"><a href="#面试官：HashSet与HashMap的区别？" class="headerlink" title="面试官：HashSet与HashMap的区别？"></a><strong>面试官</strong>：HashSet与HashMap的区别？</h3><p><strong>候选人</strong>：HashSet 底层就是基于 HashMap 实现的。</p><p>![image-20250218113836389](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218113836389.png)</p><h3 id="面试官：HashTable与HashMap的区别"><a href="#面试官：HashTable与HashMap的区别" class="headerlink" title="面试官：HashTable与HashMap的区别"></a><strong>面试官</strong>：HashTable与HashMap的区别</h3><p><strong>候选人</strong>：</p><table><thead><tr><th align="center"><strong>区别</strong></th><th align="center"><strong>HashTable</strong></th><th align="center"><strong>HashMap</strong></th></tr></thead><tbody><tr><td align="center">数据结构</td><td align="center">数组+链表</td><td align="center">数组+链表+红黑树</td></tr><tr><td align="center">是否可以为null</td><td align="center">Key和value都不能为null</td><td align="center">可以为null</td></tr><tr><td align="center">hash算法</td><td align="center">key的hashCode()</td><td align="center">二次hash</td></tr><tr><td align="center">扩容方式</td><td align="center">当前容量翻倍 +1（2n + 1）</td><td align="center">当前容量翻倍(2n)</td></tr><tr><td align="center">线程安全</td><td align="center">同步(synchronized)的，线程安全</td><td align="center">非线程安全</td></tr></tbody></table><p>在实际开发中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE相关面试题</title>
      <link href="/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）"><a href="#面试官：-面向对象-OOP-和面向过程-POP-的区别（高频）" class="headerlink" title="面试官： 面向对象(OOP)和面向过程(POP)的区别（高频）"></a><strong>面试官</strong>： 面向对象(OOP)和面向过程(POP)的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>⾯向过程</strong> ：<strong>⾯向过程性能⽐⾯向对象⾼。</strong> ⽐如单⽚机、嵌⼊式开发、Linux&#x2F;Unix 等⼀般采⽤⾯向过程开发。以函数为中心，强调逻辑流程。</p></li><li><p><strong>⾯向对象</strong> ：<strong>⾯向对象易维护、易复⽤、易扩展。</strong> 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>⾯向对象性能⽐⾯向过程低</strong>。以对象为中心，强调数据和行为的封装。</p></li></ul><blockquote><p>拓展：为什么⾯向过程性能⽐⾯向对象⾼？</p><p>⾯向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是⾯向对象语⾔，⽽是 Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的⼆进制机械码。⽽⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏。</p></blockquote><h3 id="面试官：Java的基本数据类型"><a href="#面试官：Java的基本数据类型" class="headerlink" title="面试官：Java的基本数据类型"></a><strong>面试官</strong>：Java的基本数据类型</h3><p><strong>候选人：</strong> Java 语言一共提供了八种原始的数据类型(byte、short、int、long、float、double、char、boolean)。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png" alt="img"></p><p>以上这些基本类型可以分为如下三种类型：</p><p>1）数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</p><p>2）字符型：char</p><p>3）布尔型：boolean</p><p>8种基本数据类型的默认值、位数、取值范围，如下表所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="img"></p><h3 id="面试官：说说JVM-、-JDK-和-JRE的区别？"><a href="#面试官：说说JVM-、-JDK-和-JRE的区别？" class="headerlink" title="面试官：说说JVM 、 JDK 和 JRE的区别？"></a><strong>面试官</strong>：说说JVM 、 JDK 和 JRE的区别？</h3><p><strong>候选人：</strong></p><ul><li><strong>Java Virtual Machine（JVM）</strong> 是运⾏ Java 字节码的虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li></ul><blockquote><p>拓展：什么是字节码?采⽤字节码的好处是什么?</p><p>在 Java 中，JVM 可以理解的代码就叫做  （即扩展名为 .class 的⽂件），它<strong>不⾯向任何特定的处理器，只⾯向虚拟机</strong>。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔<strong>执⾏效率低</strong>的问题，同时⼜保留了解释型语⾔<strong>可移植</strong>的特点。</p></blockquote><ul><li><strong>Java Runtime Environment（JRE）</strong> 包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包。</li><li><strong>Java Development Kit（JDK）</strong> 是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed34206201fcfe5a01689c30e3113972.png" alt="img"></p><h3 id="面试官：Java-程序从源代码到运⾏分为哪几步？"><a href="#面试官：Java-程序从源代码到运⾏分为哪几步？" class="headerlink" title="面试官：Java 程序从源代码到运⾏分为哪几步？"></a><strong>面试官</strong>：Java 程序从源代码到运⾏分为哪几步？</h3><p><strong>候选人：</strong> Java程序从源代码到运⾏⼀般有下⾯3步：</p><p>![image-20250218110538905](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110538905.png)</p><p>我们需要格外注意的是 <strong>.class-&gt;机器码</strong> 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过解释器逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的<strong>热点代码</strong>)，所以后⾯引进了 <strong>JIT 编译器</strong>，⽽ JIT 属于<strong>运⾏时编译</strong>。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。这也解释了我们为什么经常会说 Java 是编译与解释共存的语⾔。</p><h3 id="面试官：Java和C-的区别"><a href="#面试官：Java和C-的区别" class="headerlink" title="面试官：Java和C++的区别"></a><strong>面试官</strong>：Java和C++的区别</h3><p><strong>候选人：</strong></p><ul><li>都是面向对象的语言，都支持封装、继承和多态。</li><li>Java不提供指针来直接访问内存，程序内存更加安全。</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以有多个实现类。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存。</li><li>在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符‘\0’来表示结束。但是，Java 语⾔中没有结束符这⼀概念。</li></ul><blockquote><p>深度思考：</p><p>在C语言中，字符串是以空字符（’\0’）结尾的字符数组。这种设计的好处是简单直接，但缺点是在访问字符串时每次都需要检查空字符来确定字符串的长度，这可能会导致额外的计算开销。在Java中，字符串是一个类（<code>String</code>），它包含了字符串的值以及其长度信息。这种设计使得字符串的长度可以在创建时确定，并且可以通过内置的方法（如<code>length()</code>）轻松获取。这种方法提高了效率，减少了因字符串处理不当而导致的安全隐患。</p></blockquote><h3 id="面试官：-什么是序列化-什么是反序列化"><a href="#面试官：-什么是序列化-什么是反序列化" class="headerlink" title="面试官： 什么是序列化?什么是反序列化?"></a><strong>面试官</strong>： 什么是序列化?什么是反序列化?</h3><p><strong>候选人：</strong></p><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>：将<strong>数据结构或对象</strong>转换成可以存储或传输的形式，通常是<strong>二进制字节流</strong>，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为<strong>原始数据结构或者对象</strong>的过程</li></ul><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到 <strong>数据库（如 Redis）</strong> 之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><h3 id="面试官：-重载和重写的区别（高频）"><a href="#面试官：-重载和重写的区别（高频）" class="headerlink" title="面试官： 重载和重写的区别（高频）"></a><strong>面试官</strong>： 重载和重写的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>重载（编译时多态）是同一个类中方法之间的关系，是水平关系。</p><p>重写（运行时多态）是子类和父类之间的关系，是垂直关系。</p><p>![image-20250218110611282](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110611282.png)</p><h3 id="面试官：面向对象的特征有哪些方面？（高频）"><a href="#面试官：面向对象的特征有哪些方面？（高频）" class="headerlink" title="面试官：面向对象的特征有哪些方面？（高频）"></a><strong>面试官</strong>：面向对象的特征有哪些方面？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。<strong>继承是多态的前提。</strong></p><blockquote><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol></blockquote><p><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。例如，如果父类 Animal 有一个 <code>makeSound()</code> 方法，子类 Dog 和 Cat 可以分别重写这个方法，当调用 <code>animal.makeSound()</code> 时，具体执行的是 Dog 或 Cat 的实现。</p><h3 id="面试官：面向对象的设计原则你知道有哪些吗"><a href="#面试官：面向对象的设计原则你知道有哪些吗" class="headerlink" title="面试官：面向对象的设计原则你知道有哪些吗"></a><strong>面试官</strong>：面向对象的设计原则你知道有哪些吗</h3><p><strong>候选人：</strong> 面向对象编程中的五大原则:</p><ul><li><strong>单一职责原则(SRP)</strong>:一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子:考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li><li><strong>开放封闭原则(OCP)</strong>:软件实体应该对扩展开放，对修改封闭。例子:通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li><li><strong>里氏替换原则(LSP)</strong>:子类对象应该能够替换掉所有父类对象。例子:一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li><li><strong>接口隔离原则(ISP)</strong> :客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子:通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li><li><strong>依赖倒置原则(DIP)</strong>:高层模块不应该依赖低层模块，二者都应该依赖于抽象;抽象不应该依赖于细节，细节应该依赖于抽象。例子:如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类。</li></ul><h3 id="面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）"><a href="#面试官：-String-、StringBuffer-和-StringBuilder-的区别是什么-（高频）" class="headerlink" title="面试官： String 、StringBuffer 和 StringBuilder 的区别是什么?（高频）"></a><strong>面试官</strong>： String 、StringBuffer 和 StringBuilder 的区别是什么?<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>可变性：</strong></p><ul><li><p>String对象是不可变类，也就是说String对象一旦被创建，其值将不能被改变。String 类中使⽤ <code>final</code> 关键字修饰字符数组来保存字符串， <code>private final char[] value</code> ，所以 String 对象是不可变的。</p><blockquote><p>拓展：在 Java 9 之后，String 类的实现改⽤ byte 数组存储字符串</p><p><strong>private final byte[] value</strong></p></blockquote></li><li><p>StringBuilder 与 StringBuffer 都继承⾃ <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使⽤字符数组保存字符串 <code>char[] value</code> 但是没有⽤ <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>线程安全性</strong>：</p><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>StringBuffer 对<code>AbstractStringBuilder</code>⽅法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对⽅法加同步锁，线程不安全。</li></ul><p><strong>性能</strong>：</p><ul><li><p>每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象。性能最好。</p></li><li><p>StringBuffer 每次都会对<strong>对象本身</strong>进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。性能最差。</p></li><li><p>相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 <strong>10%~15%</strong> 左右的性能提升，但却要冒多线程不安全的⻛险。(如下)</p></li></ul><p><strong>实例化&#x2F;初始化：</strong></p><blockquote><p>《Java程序员面试笔试宝典》第二版 1.18节</p><p>当实例化String的时候，可以利用构造方法（String s1 &#x3D; new String(“world”)）的方式来对其初始化，也可以使用赋值（String s1 &#x3D; “Hello”）的方式来初始化，而StringBuffer和StringBuilder只能使用构造方法（StringBuffer s &#x3D; new StringBuffer(“world”)）的方式来初始化。</p></blockquote><p><strong>在频繁字符串拼接或修改情况下：</strong></p><p>String 字符串修改实现的原理为：当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuilder，然后调用 StingBuilder 的append 方法，最后调用 StingBuilder 的 toString方法把结果返回。举例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码等价于下述代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">s.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">s = sb.toString();</span><br></pre></td></tr></table></figure><p>由此可以看出，上述过程比使用 StingBuilder 多了一些附加的操作，同时也生成了一些临时的对象，导致程序的执行效率降低。</p><p><strong>对于三者使⽤的总结：</strong></p><ol><li>操作少量的数据: 适⽤ String</li><li><strong>单线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li><strong>多线程</strong>操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ol><h3 id="面试官：接⼝和抽象类的区别是什么？（高频）"><a href="#面试官：接⼝和抽象类的区别是什么？（高频）" class="headerlink" title="面试官：接⼝和抽象类的区别是什么？（高频）"></a><strong>面试官</strong>：接⼝和抽象类的区别是什么？<code>（高频）</code></h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">参数</th><th align="center">抽象类（从属关系is-a）</th><th align="center">接口（特定功能的实现has-a）</th></tr></thead><tbody><tr><td align="center">声明</td><td align="center">抽象类使用abstract关键字声明</td><td align="center">接口使用interface关键字声明</td></tr><tr><td align="center">实现</td><td align="center">子类使用extends关键字来继承抽象类</td><td align="center">子类使用implements关键字来实现接口</td></tr><tr><td align="center">构造器</td><td align="center">抽象类可以有构造器</td><td align="center">接口不能有构造器</td></tr><tr><td align="center">访问修饰符</td><td align="center">抽象类中的方法可以是任意访问修饰符</td><td align="center">接口方法默认修饰符是public。并且不允许定义为private 或者 protected</td></tr><tr><td align="center">多继承</td><td align="center">一个类最多只能继承一个抽象类</td><td align="center">一个类可以实现多个接口</td></tr><tr><td align="center">字段声明</td><td align="center">抽象类的字段声明可以是任意的</td><td align="center">接口的字段默认都是 static 和 final 的</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sparrow</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating seeds.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：成员变量与局部变量的区别有哪些？"><a href="#面试官：成员变量与局部变量的区别有哪些？" class="headerlink" title="面试官：成员变量与局部变量的区别有哪些？"></a><strong>面试官</strong>：成员变量与局部变量的区别有哪些？</h3><p><strong>候选人：</strong></p><table><thead><tr><th align="center">属性</th><th align="center">成员变量</th><th align="center">局部变量</th></tr></thead><tbody><tr><td align="center"><strong>作用域</strong></td><td align="center">针对整个类有效</td><td align="center">只在某个范围内有效，通常在方法或语句体内</td></tr><tr><td align="center"><strong>存储位置</strong></td><td align="center">随着对象的创建而存在，存储在堆内存中</td><td align="center">在方法被调用或语句被执行的时候存在，存储在栈内存中</td></tr><tr><td align="center"><strong>生命周期</strong></td><td align="center">随着对象的创建而存在，随着对象的消失而消失</td><td align="center">当方法调用完，或者语句结束后，就自动释放</td></tr><tr><td align="center"><strong>初始值</strong></td><td align="center">有默认初始值，如数字类型为0，布尔类型为false，引用类型为null</td><td align="center">没有默认初始值，使用前必须显式赋值</td></tr><tr><td align="center"><strong>使用原则</strong></td><td align="center">就近原则（首先在局部范围找，有就使用；接着在成员位置找）</td><td align="center">就近原则</td></tr></tbody></table><h3 id="面试官：-什么是自动拆箱-装箱？（高频）"><a href="#面试官：-什么是自动拆箱-装箱？（高频）" class="headerlink" title="面试官： 什么是自动拆箱&#x2F;装箱？（高频）"></a><strong>面试官：</strong> 什么是自动拆箱&#x2F;装箱？<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p>自动装箱是指将基本数据类型（如 int、double、boolean 等）自动转换为对应的包装类对象（如 Integer、Double、Boolean 等）。这个过程由<strong>编译器</strong>自动完成，当存储一个基本数据类型到需要用到对象的场景中(例如集合)，Java 编译器会检测到基本数据类型需要被转换为包装类对象，编译器会自动调用包装类的 <code>valueOf()</code> 方法来创建对应的包装类对象，生成的对象会被存储到目标位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> Integer.valueOf(num);</span><br></pre></td></tr></table></figure></li><li><p>自动拆箱是指将包装类对象（如 Integer、Double、Boolean 等）自动转换为对应的基本数据类型（如 int、double、boolean 等）。同样，这个过程也是由<strong>编译器</strong>自动完成的。当你从一个需要对象的场景中取出值并赋给基本数据类型时，Java 编译器会检测到目标变量是一个基本数据类型。编译器会自动调用包装类的 <code>xxxValue()</code> 方法，比如 <code>intValue()</code>、<code>doubleValue()</code> 等，来获取基本数据类型的值。返回的基本数据类型值会被赋给目标变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integerObj</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> integerObj.intValue();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>一共有3点需要注意</p><p>第一个是<strong>性能问题</strong>，频繁的自动装箱和拆箱可能会导致额外的性能开销，因为每次都需要创建或转换对象。</p><p>第二个是<strong>空指针异常</strong>，如果对一个 null 的包装类对象进行自动拆箱操作，会抛出 NullPointerException。</p><p>第三个是<strong>缓存机制</strong>，某些包装类（如 Integer、Boolean 等）会对常用值进行缓存。</p></blockquote><h3 id="面试官：-int和Integer的区别（高频）"><a href="#面试官：-int和Integer的区别（高频）" class="headerlink" title="面试官： int和Integer的区别（高频）"></a><strong>面试官：</strong> int和Integer的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p><ol><li><p><strong>定义上的区别:</strong></p><ul><li><p>int 是 Java 的基本数据类型，<strong>直接存储数值</strong>，占用固定的 4 字节内存空间，范围是从 -2,147,483,648 到 2,147,483,647。</p></li><li><p>而 Integer 是 int 的包装类，<strong>它是一个对象</strong>，通过引用指向存储的数值，因此除了存储数值本身外，还需要额外的内存开销。</p></li></ul></li><li><p><strong>使用方式上的区别:</strong></p><ul><li><p>int 是一种原始类型，可以直接声明和赋值。</p></li><li><p>而 Integer 必须实例化后才能使用，它提供了更多的功能，比如支持泛型、序列化、缓存以及一些实用方法。</p></li></ul></li><li><p><strong>使用场景上的区别:</strong></p><ul><li><p>当需要高效处理整数时，优先使用 int。</p></li><li><p>当需要将整数作为对象使用时，选择 Integer。</p></li></ul></li></ol><blockquote><p>Java 是一门面向对象的语言，很多场景需要将数据封装成对象。例如：泛型（Generics）要求参数必须是对象类型，而不能是基本数据类型。序列化（Serialization）需要对象支持，以便将数据持久化或通过网络传输。缓存机制需要对整数进行复用，以提高性能和节省内存。</p><p>因此，Java 设计了 Integer 作为 int 的包装类，解决了这些面向对象的需求。</p></blockquote><h3 id="面试官：-与-equals（高频）"><a href="#面试官：-与-equals（高频）" class="headerlink" title="面试官：  &#x3D;&#x3D; 与 equals（高频）"></a><strong>面试官：</strong>  &#x3D;&#x3D; 与 equals<code>（高频）</code></h3><p><strong>候选人：</strong></p><p><strong>&#x3D;&#x3D;</strong> : 它的作⽤是判断两个对象的地址是不是相等。(基本数据类型&#x3D;&#x3D;⽐的是值，引⽤数据类型&#x3D;&#x3D;⽐的是内存地址)。</p><p><strong>equals()</strong> : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：</p><ul><li><p>情况 1：类<strong>没有覆盖 equals()</strong> ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“&#x3D;&#x3D;”⽐这两个对象地址。</p></li><li><p>情况 2：类<strong>覆盖了 equals()</strong> ⽅法。⼀般我们都覆盖 equals() ⽅法来⽐两个对象的内容是否相等；若它们的内容相等，则返回 true 。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true，因为String内部重写了equals.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？"><a href="#面试官：你重写过-hashcode-和-equals-么，为什么重写equals时必须重写hashCode方法？" class="headerlink" title="面试官：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？"></a><strong>面试官</strong>：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？</h3><p><strong>候选人：</strong></p><p><strong>1）hashCode()介绍:</strong></p><p>hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><strong>2）以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3）为啥hashcode相同了，这两个对象还有可能不相同呢？</strong></p><p>这是由于哈希码值的空间有限（通常是32位整数），而对象的状态空间可能非常大，因此可能会发生**“哈希碰撞”**，即不同的对象拥有相同的哈希码值。举个例子，考虑一个简单的类 <code>Person</code>，它有两个属性 <code>name</code> 和 <code>age</code>。你可以为这个类重写 <code>hashCode()</code> 和 <code>equals()</code> 方法来确保当两个 <code>Person</code> 对象具有相同的 <code>name</code> 和 <code>age</code> 时，它们的哈希码相同并且 <code>equals()</code> 方法也返回 <code>true</code>。但是，如果你仅仅让 <code>hashCode()</code> 方法基于 <code>name</code> 属性计算哈希码，那么即使 <code>age</code> 不同，两个具有相同名字的 <code>Person</code> 对象也会有相同的哈希码值，尽管它们实际上是不同的对象。</p><p><strong>4）为什么重写equals 时必须重写 hashCode ⽅法？</strong></p><p>如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等,对两个对象分别调⽤ equals⽅法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。<strong>因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖。</strong></p><h3 id="面试官：值传递和引用传递有什么区别？（高频）"><a href="#面试官：值传递和引用传递有什么区别？（高频）" class="headerlink" title="面试官：值传递和引用传递有什么区别？（高频）"></a><strong>面试官</strong>：值传递和引用传递有什么区别？<code>（高频）</code></h3><p><strong>候选人：</strong> Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。（《Java 核⼼技术 卷Ⅰ基础知识》第⼗版 4.5 节）</p><ul><li><strong>值传递</strong>：指的是在方法调用时，传递的参数是<strong>按值的拷贝传递</strong>，也就是说传递后就互不相关了。Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>![image-20250218110642119](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110642119.png)</p><p><strong>解析：</strong> 在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><ul><li><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，<strong>其实传递的引用的地址</strong>，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>![image-20250218110654146](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110654146.png)</p><p><strong>解析：</strong> array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p>![image-20250218110707866](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110707866.png)</p><p>![image-20250218110721206](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110721206.png)</p><p>解析：通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</strong></p><h3 id="面试官：final-、finally-、finalize区别"><a href="#面试官：final-、finally-、finalize区别" class="headerlink" title="面试官：final 、finally 、finalize区别"></a><strong>面试官</strong>：final 、finally 、finalize区别</h3><p><strong>候选人：</strong></p><ul><li>final可以修饰类、变量、方法。修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。（如果是<strong>基本数据类型</strong>的变量，则其数值⼀旦在初始化之后便不能更改；如果是<strong>引⽤类型</strong>的变量，则在对其初始化之后便不能再让其指向另⼀个对象。）</li><li>finally一般作用在<strong>try-catch</strong>代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾。</li></ul><h3 id="面试官：finally块中的代码什么时候被执行？"><a href="#面试官：finally块中的代码什么时候被执行？" class="headerlink" title="面试官：finally块中的代码什么时候被执行？"></a><strong>面试官</strong>：finally块中的代码什么时候被执行？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.19节）<br>在 Java 语言的异常处理中，finally 语句块的作用就是保证无论出现什么情况，finally 块里的代码一定会被执行。由于当程序执行 return 的时候就意味着结束对当前方法的调用并跳出这个方法体，任何语句要执行都只能在 return 前执行(除非碰到 exit 函数)，因此 fnally 块里的代码也是在return 前执行的。<strong>此外，如果 try-finally 或者 catch-finally 中都有 return，则 finally 块中的 return 语句将会覆盖别处的 return 语句，最终返回到调用者的是 finally 中 return 的值</strong>。下面通过两个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>从上面这个例子中可以看出，在执行 return 前确实执行了 finally 中的代码。紧接着，在 finally块里面放置 return 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testFinally</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;execute finally&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">execute <span class="keyword">finally</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>在以下</strong> <strong>3</strong> <strong>种特殊情况下，</strong> <strong>finally</strong> <strong>块不会被执⾏：</strong></p><ol><li><p>在 try 或 finally 块中⽤了 System.exit(0) 退出程序。</p></li><li><p>当程序在进入try语句块之前就出现异常的时候（int i &#x3D; 5&#x2F;0;）。</p></li><li><p>程序所在的线程死亡。</p></li><li><p>关闭 CPU。</p></li></ol><h3 id="面试官：this与super的区别"><a href="#面试官：this与super的区别" class="headerlink" title="面试官：this与super的区别"></a><strong>面试官</strong>：this与super的区别</h3><p><strong>候选人：</strong></p><ul><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h3 id="面试官：Java程序初始化的顺序可以说下吗？"><a href="#面试官：Java程序初始化的顺序可以说下吗？" class="headerlink" title="面试官：Java程序初始化的顺序可以说下吗？"></a><strong>面试官</strong>：Java程序初始化的顺序可以说下吗？</h3><p><strong>候选人：</strong>（摘自《Java程序员面试笔试宝典》第二版 1.1节）</p><p>Java程序的初始化工作可以在许多不同的代码块中来完成(例如:静态代码块、构造函数等)，它们执行的顺序为:<strong>父类静态变量</strong>→父类静态代码块→<strong>子类静态变量</strong>→子类静态代码→<strong>父类非静态变量</strong>→父类非静态代码块→父类构造方法→<strong>子类非静态变量</strong>→子类非静态代码块→子类构造方法。下面给出一个不同模块初始化时执行顺序的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Base <span class="keyword">static</span> block</span><br><span class="line">Derived <span class="keyword">static</span> block</span><br><span class="line">Base block</span><br><span class="line">Base constructor</span><br><span class="line">Derived block</span><br><span class="line">Derived constructor</span><br></pre></td></tr></table></figure><p>这里需要注意的是，(静态)非静态成员域在定义时初始化和(静态)非静态块中初始化的优先级是平级的，也就是说按照从上到下初始化，最后一次初始化为最终的值(不包括非静态的成员域在构造器中初始化)。所以在(静态)非静态块中初始化的域甚至能在该域声明的上方，因为分配存储空间在初始化之前就完成了。如下例所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="面试官：说下构造方法（构造器）吧！"><a href="#面试官：说下构造方法（构造器）吧！" class="headerlink" title="面试官：说下构造方法（构造器）吧！"></a><strong>面试官</strong>：说下构造方法（构造器）吧！</h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.2节）</p><p>Java 语言中，构造方法具有以下特点:</p><p>1）构造方法必须与类的名字相同，并且不能有返回值(返回值也不能为 void)。</p><p>2）每个类可以有多个构造方法。</p><p>3）构造方法可以有0个、1 个或1个以上的参数。</p><p>4）构造方法总是伴随着 new 操作一起调用。</p><p>5）构造方法的主要作用是完成对象的初始化工作。</p><p>6）构造方法不能被继承，因此就不能被重写(Override)，但是构造方法能够被重载(Overload)。</p><p>7）当父类和子类都没有定义构造方法的时候，编译器会为父类生成一个默认的无参数的构造方法，给子类也生成一个默认的无参数的构造方法。</p><h3 id="面试官：break、continue以及return的区别"><a href="#面试官：break、continue以及return的区别" class="headerlink" title="面试官：break、continue以及return的区别"></a><strong>面试官</strong>：break、continue以及return的区别</h3><p><strong>候选人：</strong></p><ul><li>break：跳出上一层循环，不再执行循环(结束当前的循环体)。所以，当多层循环嵌套，break 语句出现在嵌套循环中的内层循环，它将仅仅只是终止了内层循环的执行，而不影响外层循环的执行。</li></ul><blockquote><p>拓展：由于 break 只能跳出当前的循环，那么如何才能实现跳出多重循环呢?可以在多重循环的外面定义一个标识，然后在循环体里使用带有标识的 break 语句即可跳出多重循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     out:</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) <span class="keyword">break</span> out;</span><br><span class="line">             System.out.println(j);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在 C&#x2F;C++中，goto 常被用作跳出多重循环，在 Java 语言中，可以使用 break 和 continue 来达到同样的效果。那么既然 goto 没有在 Java 语言中使用，为什么还要作为保留字呢?其中一个可能的原因就是这个关键字有可能会在将来被使用。这里需要注意的是，在 Java 语言中，虽然没有 goto 语句，但是却能使用标识符加冒号 (:)的形式定义标签，其目的主要是在多重循环中方便使用 break 和 continue。</p></blockquote><ul><li>continue：跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)。简单地说，continue 只是中断一次循环的执行而己。</li><li>return：程序返回，不再执行下面的代码(结束当前的方法直接返回)。</li></ul><h3 id="面试官：-说说你对Java-中的异常处理的理解？"><a href="#面试官：-说说你对Java-中的异常处理的理解？" class="headerlink" title="面试官： 说说你对Java 中的异常处理的理解？"></a><strong>面试官</strong>： 说说你对Java 中的异常处理的理解？</h3><p>**候选人：**在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类有两个重要的⼦类 Exception （异常）和 Error （错误）。 Exception 能被程序本身处理( trycatch )， Error 是⽆法处理的(只能尽量避免)。Exception 和 Error ⼆者都是 Java 异常处理的重要⼦类，各⾃都包含⼤量⼦类。</p><ul><li><strong>Exception</strong>：程序本身可以处理的异常，可以通过 catch 来进⾏捕获。 Exception ⼜可以分为 <strong>受检异常</strong>(必须处理) 和 <strong>非受检异常</strong>(可以不处理)。</li></ul><blockquote><p><strong>受检查异常</strong>：Java 代码在编译过程中，如果受检查异常没有被 catch &#x2F; throw 处理的话，就没办法通过编译。除了 RuntimeException 及其⼦类以外，其他的 Exception 类及其⼦类都属于检查异常 。常⻅的受检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException …。</p><p><strong>不受检查异常</strong>：Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException 及其⼦类都统称为⾮受检查异常，例如： NullPointExecrption（空指针异常） 、 NumberFormatException （字符串转换为数字）、 ArrayIndexOutOfBoundsException （数组越界）、 ClassCastException （类型转换错误）等。</p></blockquote><ul><li><strong>Error</strong>：Error 属于程序⽆法处理的错误 ，我们没办法通过 catch 来进⾏捕获 。例如，Java 虚拟机运⾏错误（ Virtual MachineError ）、虚拟机内存不够错误( OutOfMemoryError )、类定义错误（NoClassDefFoundError ）等 。这些异常发⽣时，Java虚拟机（JVM）⼀般会选择线程终⽌。</li></ul><p>![image-20250218110747074](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110747074.png)</p><h3 id="面试官：-BIO-NIO-AIO-有什么区别-（高频）"><a href="#面试官：-BIO-NIO-AIO-有什么区别-（高频）" class="headerlink" title="面试官： BIO,NIO,AIO 有什么区别?（高频）"></a><strong>面试官</strong>： BIO,NIO,AIO 有什么区别?<code>（高频）</code></h3><p><strong>候选人：</strong></p><ul><li><p><strong>BIO (Blocking I&#x2F;O):</strong>  <strong>同步阻塞</strong> I&#x2F;O 模式，数据的读取写⼊必须<strong>阻塞</strong>在⼀个线程内等待其完成（每个线程只能处理一个连接）。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型不错的，可以让每⼀个连接专注于⾃⼰的 I&#x2F;O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。但是，当⾯对⼗万甚⾄百万级连接的时候，这种方式需要创建大量的线程，而系统的资源都是有限的，大量的线程会降低系统的性能。</p></li><li><p><strong>NIO (Non-blocking I&#x2F;O):</strong> <strong>同步⾮阻塞</strong> 的 I&#x2F;O 模型。NIO通过 <code>Channels , Selector，Buffers</code> 来实现非阻塞的IO操作。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I&#x2F;O 操作⽅法。它最主要的特点是，提供了基于Selector的异步网络I&#x2F;O，使得一个线程可以管理多个连接。</p><p>（图片源自《Java程序员面试笔试宝典》第二版 2.4节）</p><p>![image-20250218110800609](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110800609.png)</p></li></ul><blockquote><p>扩展：Channel（通道） , Selector（选择器），Buffer（缓冲区）</p><p>(1) Channel(通道)<br>为了更容易地理解什么是 <code>Channel</code>，这里以 <code>InputStream</code> 为例来介绍什么是 <code>Channel</code>。传统的 IO 中经常使用下面的代码来读取文件(此处忽略异常处理):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;imput.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">byte</span>[] tempbyte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((tempbyte=is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><p><code>InputStream</code> 其实就是一个用来读取文件的通道。只不过 <code>InputStream</code> 是一个单向的通道，只能用来读取数据。而 NIO 中的 <code>Channel</code> 是一个双向的通道，不仅能读取数据，而且还能写入数据。</p><p>(2) Buffer(缓冲区)<br>在上面的示例代码中，<code>InputSteam</code> 把读取到的数据放在了 byte 数组中，如果用 <code>OutputSteam</code> 写数据，那么也可以把 byte 数组中的数据<strong>写到文件</strong>中。而在 NIO 中，数据只能被<strong>写到 Buffer</strong> 中，同理读取的数据也只能放在 Buffer 中，由此可见 Bufer 是 Channel 用来读写数据的非常重要的一个工具。</p><p>![image-20250218110814433](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250218110814433.png)</p><p>(3) Selector(选择器)<br><code>Selector</code> 是 NIO 中最重要的部分，是实现一个线程管理多个连接的关键，它的作用就是<strong>轮询</strong>所有被注册的<code>Channel</code>，一旦发现 <code>Channel</code> 上被注册的事件发生，就可以对这个事件进行处理。</p></blockquote><ul><li><strong>AIO (Asynchronous I&#x2F;O):</strong> AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是<strong>异步⾮阻塞</strong>的 IO 模型。虽然 NIO 在⽹络操作中，也提供了⾮阻塞的⽅法，但它本身仍然是同步的，选择器仍然需要通过<strong>轮询</strong>主动检查数据请求。而异步 IO （AIO）是<strong>基于事件和回调机制</strong>实现的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</li></ul><h3 id="面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"><a href="#面试官：-NIO是如何实现同步非阻塞的？主线程是只有一个嘛？" class="headerlink" title="面试官： NIO是如何实现同步非阻塞的？主线程是只有一个嘛？"></a><strong>面试官：</strong> NIO是如何实现同步非阻塞的？主线程是只有一个嘛？</h3><p><strong>候选人：</strong></p><p>在NIO中，使用了多路复用器Selector来实现同步非阻塞的IO操作。Selector是一个可以监控多个通道（Channel）是否有数据可读或可写的对象，当一个或多个Channel准备好读或写时，Selector会通知程序进行读写操作，而不是像BIO一样阻塞等待IO操作完成。</p><p>在NIO中，主线程<strong>通常只有一个</strong>，但是可以使用Selector来管理多个Channel，实现多个连接的非阻塞读写操作。当有多个Channel需要进行IO操作时，Selector会<strong>轮询</strong>这些Channel，检查它们的状态是否可读或可写，如果有可读或可写的Channel，就将其加入到一个已选择键集合中，等待程序处理。这样，一个线程就可以同时处理多个Channel，提高了系统的并发处理能力。</p><h3 id="面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"><a href="#面试官：-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）" class="headerlink" title="面试官： 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？（高频）"></a><strong>面试官：</strong> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？<code>（高频）</code></h3><ul><li><p>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接<strong>复制内部对象的引用地址</strong>，也就是说<strong>拷贝对象和原对象共用同一个内部对象</strong>。浅拷贝实现简单，使用 <code>clone()</code> 即可。</p></li><li><p>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。**增加了一个指针并且申请了一个新的内存，使这个新增的指针指向新的内存。**深拷贝需要递归复制或序列化，实现较复杂。</p><blockquote><p>联想：在租房的场景中，租客和房东共享房子的使用权，任何改动都会影响对方；而在买房的场景中，买方拥有独立的房子，可以自由改造而不影响他人。通过租房和买房的类比，轻松理解浅拷贝和深拷贝的不同。</p><p>浅拷贝 → 租房（租客和房东共享房子，改动家具会影响房东）。</p><p>深拷贝 → 买房（买房后拥有完全独立的房子，改动家具不会影响房东）。</p></blockquote></li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p>![image-20250303092129835](&#x2F;Users&#x2F;suyue&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250303092129835.png)</p><h3 id="面试官：-什么是泛型？有什么作用？（高频）"><a href="#面试官：-什么是泛型？有什么作用？（高频）" class="headerlink" title="面试官： 什么是泛型？有什么作用？（高频）"></a><strong>面试官：</strong> 什么是泛型？有什么作用？<code>（高频）</code></h3><p><strong>候选人：</strong></p><p>泛型是一种在编译时提供类型安全检查的机制，它允许我们将类型作为参数传递给类、接口或方法，从而避免硬编码具体的类型。通过泛型，我们可以编写适用于多种数据类型的代码，同时确保类型安全。</p><p>泛型的作用主要有4点：</p><p>第一点是<strong>提高代码的复用性</strong>，它允许我们编写与类型无关的通用代码。</p><p>第二点是<strong>增强类型安全性</strong>，在没有泛型的情况下，集合类（如 ArrayList）默认存储的是 Object 类型，取出元素时需要手动进行类型转换，容易引发 ClassCastException。而泛型在编译时就会进行类型检查，避免了运行时的类型错误。</p><p>第三点是<strong>简化代码</strong>，使用泛型后，我们无需显式地进行类型转换，减少了冗余代码，提高了代码的可读性和维护性。</p><p>第四点是<strong>支持复杂的类型约束</strong>，泛型可以通过通配符（如 ? extends T 和 ? super T）实现更复杂的类型限制，满足特定场景下的需求。</p><h3 id="面试官：-Java反射机制以及获取反射对象的几种方式（高频）"><a href="#面试官：-Java反射机制以及获取反射对象的几种方式（高频）" class="headerlink" title="面试官： Java反射机制以及获取反射对象的几种方式（高频）"></a><strong>面试官：</strong> Java反射机制以及获取反射对象的几种方式<code>（高频）</code></h3><p><strong>候选人：</strong>（《Java程序员面试笔试宝典》第二版 1.4节）</p><p>在Java语言中，反射机制是指对于运行时类，都能够动态地获取到这个类的所有属性和方法。对于任意的一个对象，都能够调用它的任意一个方法以及访问它的属性；这种动态地获取类或对象的属性以及方法从而完成调用功能被称为Java语言的反射机制。</p><p>反射机制中Class是一个非常重要的类，在Java语言中获取Class对象主要有如下几种方法。</p><ol><li>通过<code>.class</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = A.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>Class.forName()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><ol start="3"><li>通过<code>.getClass()</code>来获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamic block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">new</span> <span class="title class_">A</span>().getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;className:&quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">static</span> block</span><br><span class="line">dynamic block</span><br><span class="line">className:A</span><br></pre></td></tr></table></figure><p>从上面的例子可知，虽然这三种方式都可以获得类的Class对象，但是它们还是有区别的，主要区别如下所示：</p><p>方法1）<strong>不执行静态块和普通代码块</strong></p><p>方法2）<strong>只执行静态块，而不执行普通代码块</strong></p><p>方法3）<strong>因为需要创建对象，所以会执行静态块和普通代码块</strong></p><h3 id="面试官：-Java创建对象除了new还有别的什么方式"><a href="#面试官：-Java创建对象除了new还有别的什么方式" class="headerlink" title="面试官： Java创建对象除了new还有别的什么方式?"></a><strong>面试官：</strong> Java创建对象除了new还有别的什么方式?</h3><p><strong>候选人：</strong></p><ul><li><p><strong>通过反射创建对象</strong>:通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newinstance() 方法或者通过 Constructor 类来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; clazz=MyClass.class;</span><br><span class="line">    MyClass obj=(MyClass)clazz.newInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过反序列化创建对象</strong>:通过将对象序列化(保存到文件或网络传输)然后再反序列化(从文件或网络传输中读取对象)的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Serialize object</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialize object</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过clone创建对象</strong>:所有 Java 对象都继承自 Object 类，Object 类中有一个 clone()方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/22/hello-world/"/>
      <url>/2025/03/22/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="🎉-Hello-World"><a href="#🎉-Hello-World" class="headerlink" title="🎉 Hello, World!"></a>🎉 Hello, World!</h1><p>欢迎来到我的个人网站！这是一个承载思考与创意的空间，也是我与世界对话的窗口。从构思到上线，这个小小的角落凝聚了我的热情与心血。</p><h2 id="🌿-为什么是“Hello-World”"><a href="#🌿-为什么是“Hello-World”" class="headerlink" title="🌿 为什么是“Hello, World”?"></a>🌿 为什么是“Hello, World”?</h2><p>“Hello, World!” 是程序员的第一课。它不仅是一句简单的问候，更象征着探索与创造的开始。每一个程序员在学习一门新语言时，都会用它来向世界宣告自己的到来。</p><p>而我的个人网站，也像是一次数字世界的问候。它不仅代表着技术上的实现，更是我向世界展示自我的方式。在这里，我记录思考、分享作品、交流想法。这个名字承载了我对新起点的期待，也寄托着我不断学习和成长的决心。</p><h2 id="🌿-关于这里"><a href="#🌿-关于这里" class="headerlink" title="🌿 关于这里"></a>🌿 关于这里</h2><p>在这里，你会找到：</p><ul><li><strong>📝 日常分享</strong>：记录生活中的点滴瞬间，感悟万物之美。</li><li><strong>🎨 绘画作品</strong>：用色彩描绘内心世界，捕捉灵感的瞬间。</li><li><strong>💡 技术探索</strong>：分享我的学习笔记和项目经验，共同成长。</li></ul><h2 id="💬-与我互动"><a href="#💬-与我互动" class="headerlink" title="💬 与我互动"></a>💬 与我互动</h2><p>每一篇文章、每一幅作品，都是我世界的一部分。我希望你在这里找到共鸣，也欢迎留下你的想法和故事。</p><ul><li>想法碰撞？留下评论吧！</li><li>想了解更多？敬请期待更新！</li><li>有问题？<a href="#">联系我</a> 我很乐意听到你的声音。</li></ul><h2 id="🚀-未来可期"><a href="#🚀-未来可期" class="headerlink" title="🚀 未来可期"></a>🚀 未来可期</h2><p>未来还有更多精彩内容等待解锁。感谢你的到来，让我们一起探索这场数字旅程吧！</p><p>再次欢迎你，愿你在这里度过美好的时光！🌟</p>]]></content>
      
      
      <categories>
          
          <category> 个人碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
