<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JVM相关面试题 | 和睦的拾光物语</title><meta name="keywords" content="JAVA面经"><meta name="author" content="玦尘"><meta name="copyright" content="玦尘"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JVM相关面试题"><meta name="application-name" content="JVM相关面试题"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="JVM相关面试题"><meta property="og:url" content="http://miahemu.github.io/2025/03/30/JVM相关面试题/index.html"><meta property="og:site_name" content="和睦的拾光物语"><meta property="og:description" content="基于技术书籍对Java面试过程中所遇到的重点问题进行深度解读，整合了来自JavaGuide等著名博主的面经分享，并回归课本进行了重写与补充。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d6225m.jpg"><meta property="article:author" content="玦尘"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d6225m.jpg"><meta name="description" content="基于技术书籍对Java面试过程中所遇到的重点问题进行深度解读，整合了来自JavaGuide等著名博主的面经分享，并回归课本进行了重写与补充。"><link rel="shortcut icon" href="https://pic1.imgdb.cn/item/67dfd64f88c538a9b5c51349.png"><link rel="canonical" href="http://miahemu.github.io/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"此去经年，别忘了归途","backTitle":"还知道回来？"},
  LA51: {"enable":true,"ck":"3LdBYNynGFmvRJ0D","LingQueMonitorID":null},
  greetingBox: {"enable":true,"default":"晚上好👋 愿你拥有美好的时光！","list":[{"greeting":"夜深了，早点休息，晚安😴","startTime":0,"endTime":5},{"greeting":"早上好☀️ 愿你的一天从愉快开始！","startTime":6,"endTime":9},{"greeting":"上午好👋 状态满满，加油迎接新的一天！","startTime":10,"endTime":10},{"greeting":"11点多啦，午餐时间快到了，继续加油！","startTime":11,"endTime":11},{"greeting":"午安！🌿 休息一下，享受美好的午后时光。","startTime":12,"endTime":14},{"greeting":"下午好！☕ 工作辛苦了，别忘了适当放松一下~","startTime":14,"endTime":18},{"greeting":"晚餐时间到啦！🍽️ 奖励自己一顿美食吧！","startTime":19,"endTime":19},{"greeting":"晚上好👋 愿你在属于自己的时间里放松身心~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":2},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🚀 数码科技探索者","🌿 乐于分享，热心助人","🏡 智能家居智造者","🛠 全栈式设计与开发","🎯 专注交互体验优化","🏃 执行力满分的实干家","⚙️ 团队协作的驱动力","💪 低调务实的实力派"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 玦尘","link":"链接: ","source":"来源: 和睦的拾光物语","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '和睦的拾光物语',
  title: 'JVM相关面试题',
  postAI: '',
  pageFillDescription: '1 JVM组成, 面试官：JVM由那些部分组成运行流程是什么？, 面试官：能简单说一下 JVM 运行时数据区吗？（高频）, 面试官：详细介绍一下程序计数器的作用？, 面试官：什么是虚拟机栈, 面试官：能不能解释一下本地方法栈？, 面试官：你能给我详细的介绍Java堆吗?, 面试官：你听过方法区吗？, 面试官： 说下直接内存？, 面试官：能说一下堆栈的区别是什么吗？, 面试官：方法中定义的局部变量是否是线程安全的？, 2 类加载器, 面试官：什么是类加载器类加载器有哪些?, 面试官： 什么是TLAB？与Eden区的关系？, 面试官：对象创建的过程了解吗？（高频）, 面试官：说一下类装载的执行过程？（高频）, 面试官：什么是双亲委派模型？（高频）, 面试官：JVM为什么采用双亲委派机制, 面试官：怎样破坏双亲委派机制？, 3 垃圾回收, 前提知识：, 并行与并发：, 内存溢出与内存泄漏：, 面试官：简述Java垃圾回收机制？（GC是什么？为什么要GC）, 面试官：强引用、软引用、弱引用、虚引用的区别？, 面试官：如何判断对象是否存活？, 面试官：如何判断对象是否真正死亡？fnalize()与System.gc(), 面试官： （回收方法区）如何判断⼀个常量是废弃常量?如何判断⼀个类是⽆⽤的类?, 面试官： JVM 垃圾回收算法有哪些？（高频）, 面试官： 你能详细聊一下分代回收吗？, 面试官：讲一下新生代、老年代、永久代的区别？, 面试官：说一下 JVM 有哪些垃圾回收器？（高频）, 面试官： 你能解释一下三色标记、增量更新算法和原始快照（STAB）算法吗？, 面试官：说说 CMS 垃圾回收器？（高频）, 面试官：说说 G1（Garbage First） 垃圾回收器？（高频）, 面试官：说说 G1 和 CMS 垃圾回收器的区别？(记忆集、卡表、写屏障), 面试官：说说你对ZGC（Z Garbage Collector） 收集器的理解？（可选高频）, 面试官：Minor GC、Major GC、Mixed GC、Full GC是什么？, 4 JVM实践（调优）, 面试官：JVM 调优的参数可以在哪里设置参数值？, 面试官：用的 JVM 调优的参数都有哪些？, 堆内存管理参数, 年轻代管理参数, 垃圾收集器选择参数, 垃圾收集器优化参数, 日志和调试参数, 面试官：平时调试 JVM都用了哪些工具呢？, 面试官：假如项目中产生了Java内存泄露（OOM）你说一下你的排查思路？, 面试官：你的GC调优经验？本文为原创内容转载请注明出处并附带原文链接感谢您的尊重与支持你必须非常努力才能看起来毫不费劲组成面试官由那些部分组成运行流程是什么候选人在中共有四大部分分别是类加载器运行时数据区内存分区执行引擎本地库接口它们的运行流程是第一类加载器把代码转换为字节码第二运行时数据区把字节码加载到内存中而字节码文件只是的一套指令集规范并不能直接交给底层系统去执行而是有执行引擎运行第三执行引擎将字节码翻译为底层系统指令再交由执行去执行此时需要调用其他语言的本地库接口来实现整个程序的功能图为深入理解虚拟机第三版图为面试笔记面试官能简单说一下运行时数据区吗高频候选人运行时数据区包含了堆方法区元空间虚拟机栈本地方法栈程序计数器这几部分每个功能作用不一样堆解决的是对象实例存储的问题垃圾回收器管理的主要区域方法区可以认为是线程共享区域用于存储已被虚拟机加载的信息常量静态变量即时编译器编译后的代码虚拟机栈为虚拟机执行方法也就是字节码服务不需要执行本地方法栈执行的是本地方法不需要执行程序计数器中存放的是当前线程所执行的字节码的行数工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令面试官详细介绍一下程序计数器的作用候选人源自深入理解虚拟机第三版节程序计数器是一块较小的内存空间它可以看作是当前线程所执行的字节码的行号指示器字节码解释器作时通过改变这个计数器的值来选取下条需要执的字节码指令分循环跳转异常处理线程恢复等功能都需要依赖这个计数器来完成另外为了线程切换后能恢复到正确的执位置每条线程都需要有个独的程序计数器各线程之间计数器互不影响独存储我们称这类内存区域为线程私有的内存如果线程正在执行的是一个方法这个计数器记录的是正在执行的虚拟机字节码指令的地址如果正在执行的是本地方法这个计数器值则应为空此内存区域是唯一一个在虚拟机规范中没有规定任何情况的区域通过一个简单的例子来说明程序计数器的行为假设我们有以下代码这段代码首先打印了一条消息到控制台然后调用了一个本地方法在这个过程中程序计数器的行为如下执行方法时当方法开始执行时程序计数器会指向类的方法的第一条字节码指令随着语句的执行程序计数器会依次指向该语句对应的字节码指令比如可能有一条字节码指令用于创建对象另一条用于调用方法等执行本地方法时当方法调用时程序计数器的值会变成因为一旦进入本地方法的执行控制权就从转移到了本地代码上而本地代码的执行不是通过字节码指令来进行的因此程序计数器无法记录这些指令的位置当返回后程序计数器会恢复到调用之后的下一条字节码指令处继续执行剩下的方法中的代码面试官什么是虚拟机栈候选人源自深入理解虚拟机第三版节与程序计数器样虚拟机栈也是线程私有的它的命周期和线程相同虚拟机栈描述的是法执的线程内存模型每个方法被执行的时候虚拟机都会同步创建一个栈帧用于存储局部变量表操作数栈动态连接方法出口等信息每一个方法被调用直至执行完毕的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程经常有人把内存区域笼统地划分为堆内存和栈内存这种划分方式直接继承自传统的程序的内存布局结构在语言里就显得有些粗糙了实际的内存区域划分要比这更复杂不过这种划分方式的流行也间接说明了程序员最关注的与对象内存分配关系最密切的区域是堆和栈两块其中堆在稍后笔者会专门讲述而栈通常就是指这里讲的虚拟机栈或者更多的情况下只是指虚拟机栈中局部变量表部分局部变量表主要存放了编译期可知的各种数据类型对象引类型它不同于对象本身可能是个指向对象起始地址的引指针也可能是指向个代表对象的句柄或其他与此对象相关的位置和类型指向了一条字节码指令的地址在虚拟机规范中对这个内存区域规定了两类异常状况如果线程请求的栈深度大于虚拟机所允许的深度将抛出异常如果虚拟机栈容量可以动态扩展当栈扩展时无法申请到足够的内存会抛出异常栈内存溢出的两种可能栈帧过多导致栈内存溢出递归调用栈帧过大导致栈内存溢出栈内存分配越大越好吗未必默认栈内存通常栈帧过大会导致线程数变少面试官能不能解释一下本地方法栈候选人源自深入理解虚拟机第三版节和虚拟机栈所发挥的作常相似区别是虚拟机栈为虚拟机执法也就是字节码服务本地法栈则为虚拟机使到的法服务在虚拟机中虚拟机栈和本地方法栈合为与虚拟机栈一样本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出和异常面试官你能给我详细的介绍堆吗候选人源自深入理解虚拟机第三版节虚拟机所管理的内存中最的块堆是所有线程共享的块内存区域在虚拟机启动时创建此内存区域的唯的就是存放对象实例乎所有的对象实例以及数组都在这分配内存世界中乎所有的对象都在堆中分配但是随着编译器即时编译技术的发展与逃逸分析技术逐渐成熟栈上分配标量替换优化技术将会导致些微妙的变化所有的对象都分配到堆上也渐渐变得不那么绝对了从开始已经默认开启逃逸分析如果某些法中的对象引没有被返回或者未被外使也就是未逃逸出去那么对象可以直接在栈上分配内存堆是垃圾收集器管理的主要区域因此也被称作堆从垃圾回收的度由于现在收集器基本都采分代垃圾收集算法所以堆还可以细分为新代和年代再细致点有空间空间等进步划分的的是更好地回收内存或者更快地分配内存如果在堆中没有内存完成实例分配并且堆也无法再扩展时虚拟机将会抛出异常在版本及版本之前堆内存被通常被分为下三部分新代内存代永代版本之后法区的永久代被彻底移除了就已经开始了取代之是元空间元空间使的是直接内存面试官你听过方法区吗候选人源自深入理解虚拟机第三版节法区也叫堆外内存与堆样是各个线程共享的内存区域它于存储已被虚拟机加载的类信息常量静态变量即时编译器编译后的代码等数据根据虚拟机规范的规定如果方法区无法满足新的内存分配需求时将抛出异常法区和永久代的关系虚拟机规范只是规定了有法区这么个概念和它的作并没有规定如何去实现它那么在不同的上法区的实现肯定是不同的了法区和永久代的关系很像中接和类的关系类实现了接永久代就是虚拟机对虚拟机规范中法区的种实现式也就是说永久代是的概念法区是虚拟机规范中的定义是种规范永久代是种实现个是标准个是实现其他的虚拟机实现并没有永久代这说法为什么要将永久代替换为元空间呢整个永久代有个本身设置固定上限法进调整很容易造成元空间使的是直接内存受本机可内存的限制不会进行也因此提升了性能面试官说下直接内存候选人源自深入理解虚拟机第三版节直接内存并不是虚拟机运时数据区的部分也不是虚拟机规范中定义的内存区域但是这部分内存也被频繁地使且也可能导致错误出现中新加的类引了种基于通道与缓存区的式它可以直接使函数库直接分配堆外内存然后通过个存储在堆中的对象作为这块内存的引进操作这样就能在些场景中显著提性能因为避免了在堆和堆之间来回复制数据本机直接内存的分配不会受到堆的限制但是既然是内存就会受到本机总内存以及处理器寻址空间的限制面试官能说一下堆栈的区别是什么吗候选人栈内存一般会用来存储局部变量和方法调用但堆内存是用来存储对象和数组的堆会垃圾回收而栈不会栈内存是线程私有的而堆内存是线程共有的两者异常错误不同但如果栈内存或者堆内存不足都会抛出异常栈空间不足堆空间不足面试官方法中定义的局部变量是否是线程安全的候选人这个得分情况讨论的声明方式是线程安全的因为线程私有不会被其他线程调用线程不安全因为是外面传进来的有可能被多个线程调用线程不安全因为返回了一个对象有可能被其他线程共享线程安全返回的是相当于了一个对象可以去看源码没有被其他线程共享的可能类加载器面试官什么是类加载器类加载器有哪些候选人虚拟机设计团队有意把类加载阶段中的通过一个类的全限定名来获取描述该类的二进制字节流这个动作放到虚拟机外部去实现以便让应用程序自己决定如何去获取所需的类实现这个动作的代码被称为类加载器常见的类加载器有个启动类加载器由编写实现用于加载目录下的类库加载中最核心的类扩展类加载器主要加载目录中的类库允许扩展中比较通用的类在之后变成平台类加载器应用类加载器主要用于加载用户类路径上所有的类库也就是加载开发者自己编写的类自定义类加载器开发者自定义类继承类实现自定义类加载规则面试官什么是与区的关系候选人是区的一部分它的目的是减少多线程分配对象时的锁竞争提高分配效率可以简单理解为区是所有线程共享的用于存放新创建的对象是区在每个线程中的私有缓存每个线程在区预分配一小块区域用于减少并发竞争当线程需要分配对象时优先在自己的中分配避免区的全局锁竞争只有当用完后才会尝试直接在区分配如果空间足够或者触发面试官对象创建的过程了解吗高频候选人第一步是进行类加载检查当程序执行到指令时会先检查对应的类是否已经被加载解析和初始化过如果类尚未加载会按照类加载机制加载验证准备解析初始化完成类的加载过程第二步是进行内存的分配会为新对象分配内存空间对象所需的内存大小在类加载完成后就可以确定因此分配内存的过程就是从堆中划分一块连续的空间主要有两种方式一种是通过指针碰撞如果堆中的内存是规整的已使用和空闲区域之间有明确分界可以通过移动指针来分配内存另一种是通过空闲列表如果堆中的内存是碎片化的会维护一个空闲列表记录可用的内存块并从中分配合适的区域分配内存在并发环境下如果存在锁的竞争如何解决这个问题线程本地缓存为每个线程分配一块私有的小内存区域线程在内部分配对象时不会加锁避免了竞争只有当不够用时才会触发全局堆分配可能涉及锁的竞争重试内存不足时如果对象需要在全局堆内存中分配采用重试机制更新内存分配指针避免传统的锁开销提高并发性能如果失败说明有多个线程竞争会自动重试直到成功第三步是将零值初始化会对分配的内存空间进行初始化将其所有字段设置为零值如为为引用类型为这一步确保了对象的实例字段在未显式赋值前有一个默认值从而避免未初始化的变量被访问第四步是设置对象头其中包含和数组长度用于存储对象的哈希码分代年龄锁状态标志等信息指向对象所属类的元数据即的地址第五步是执行构造方法用方法完成对象的初始化构造方法会根据代码逻辑对对象的字段进行赋值并调用父类的构造方法完成继承链的初始化这一步完成后对象才真正可用面试官说一下类装载的执行过程高频候选人源自深入理解虚拟机第三版节一个类型从被加载到虚拟机内存中开始到卸载出内存为止它的整个生命周期将会经历加载验证准备解析初始化使用和卸载七个阶段其中验证准备解析三个部分统称为连接这七个阶段的发生顺序如图所示加载通过一个类的全限定名来获取定义此类的二进制字节流加载完类之后将字节码信息保存到方法区中生成一个对象保存类的所有信息最后在堆区生成一个代表这个类的对象为什么要在堆区生成一个对象不直接使用方法区呢虽然类的信息主要保存在方法区但是为了提供一个可访问的接口支持反射操作便于垃圾回收以及增强安全性设计者选择在堆区生成一个对象这种方法使得类的信息更加易于管理和访问同时也保持了方法区的纯粹性使其专注于存储类的元数据验证保证加载类的准确性如验证字节流是否以魔数开头主次版本号是否在当前虚拟机接受范围之内等准备为静态变量分配内存并设置类变量初始值关于准备阶段还有两个容易产生混淆的概念需要着重强调首先是这时候进内存分配的仅包括类变量而不包括实例变量实例变量将会在对象实例化时随着对象起分配在堆中其次是这里所说的初始值通常情况下是数据类型的零值假设个类变量的定义为那变量在准备阶段过后的初始值为而不是因为这时尚未开始执行任何方法而把赋值为的指令是程序被编译后存放于类构造器方法之中所以把赋值为的动作要到类的初始化阶段才会被执行为什么要赋初始值如果不赋初始值当类初始化时得到的就是系统残留的随机值不友好解析把类中的符号引用转换为直接引用补充符号引用和直接引用符号引用符号引用以一组符号来描述所引用的目标符号可以是任何形式的字面量只要使用时能无歧义地定位到目标即可直接引用直接引用是可以直接指向目标的指针相对偏移量或者是一个能间接定位到目标的句柄解析的目的在于让能够正确地调用类的方法访问类的字段等只有当符号引用被解析成了直接引用才能知道在内存中定位到具体的地址并执行相应的操作初始化执行静态代码块为静态变量赋值初始化阶段就是执行类构造器方法的过程使用开始从入口方法开始执行用户的程序代码卸载当用户程序代码执行完毕后便开始销毁创建的对象最后负责运行的也退出内存面试官什么是双亲委派模型高频候选人双亲委派模型的工作过程是如果一个类加载器收到了类加载的请求它首先不会自己尝试加载这个类而是把这请求委派给父类加载器去完成每一个层次的类加载器都是如此因此所有的加载请求最终都应该传送到顶层的启动类加载器中只有当父类加载器返回自己无法完成这个加载请求它的搜索返回中没有找到所需的类时子类加载器才会尝试自己去加载双亲委派模型的实现这段代码的逻辑清晰易懂先检查请求加载的类型是否已经被加载过若没有则调用父加载器的方法若父加载器为空则默认使用启动类加载器作为父加载器假如父类加载器加载失败抛出异常的话才调用自己的方法尝试进行加载面试官为什么采用双亲委派机制候选人主要有两个原因第一通过双亲委派机制可以避免某一个类被重复加载当父类已经加载后子类无需重复加载保证唯一性第二为了安全保证类库不会被修改保证安全性在工程中新建包接着在该包下新建类并定义函数此时无法执行函数会出现异常在类中找不到方法出现该信息是因为由双亲委派的机制的在启动类加载器得到加载因为在核心库中有其相同名字的类文件但该类中并没有方法这样就能防止恶意篡改核心库面试官怎样破坏双亲委派机制候选人自定义类加载器并且重写方法就可将双亲委派机制破坏服务使用线程上下文类加载器去加载所需的服务代码这是一种父类加载器去请求子类加载器完成类加载的行为框架的类加载器垃圾回收前提知识并行与并发并行并行说明同一时间有多条这样的线程在协同工作通常默认此时用户线程是处于等待状态并发并发说明同一时间垃圾收集器线程与用户线程都在运行由于用户线程并未被冻结所以程序仍然能响应服务请求有可能对象引用被修改内存溢出与内存泄漏内存泄漏在中如果不再使用一个对象但是该对象依然在的引用链上这个对象就不会被垃圾回收器回收这种情况就称之为内存泄漏大多数都是由堆内存泄漏引起的少量的内存泄漏可以容忍但是如果发生持续的内存泄漏就像滚雪球雪球越滚越大不管有多大的内存迟早会被消耗完最终导致的结果就是内存溢出但是产生内存溢出并不是只有内存泄漏这一种原因面试官简述垃圾回收机制是什么为什么要候选人为了让程序员更专注于代码的实现而不用过多的考虑内存释放的问题所以在语言中有了自动的垃圾回收机制也就是我们熟悉的有了垃圾回收机制后程序员只需要关心内存的申请即可内存的释放由系统自动识别完成引入垃圾回收机制的主要目的是为了减轻程序员的负担提高程序的健壮性和效率同时减少内存泄漏等问题面试官强引用软引用弱引用虚引用的区别候选人源自深入理解虚拟机第三版节在版之前里面的引用是很传统的定义一个对象在这种定义下只有被引用或者未被引用两种状态对于描述一些食之无味弃之可惜的对象就显得无能为力譬如我们希望能描述一类对象当内存空间还足够时能保留在内存之中如果内存空间在进行垃圾收集后仍然非常紧张那就可以抛弃这些对象很多系统的缓存功能都符合这样的应用场景在版之后对引用的概念进行了扩充将引用分为强引用软引用弱引用和虚引用种这种引用强度依次逐渐减弱强引用是最传统的引用的定义是指在程序代码之中普遍存在的引用赋值即类似这种引用关系无论任何情况下只要强引用关系还存在垃圾收集器就永远不会回收掉被引用的对象软引用是用来描述一些还有用但非必须的对象只被软引用关联着的对象在系统将要发生内存溢出异常前会把这些对象列进回收范围之中进行第二次回收如果这次回收还没有足够的内存才会抛出内存溢出异常在版之后提供了类来实现软引用下面举个例子说明首先限制其最大堆内存移除强引用创建多个大对象来模拟内存压力尝试让垃圾收集器工作检查软引用是否仍然有效占用内存创建更多大对象输出结果如果把堆大小设置很大时就会输出弱引用也是用来描述那些非必须对象但是它的强度比软引用更弱一些被弱引用关联的对象只能生存到下一次垃圾收集发生为止当垃圾收集器开始工作无论当前内存是否足够都只会回收掉被弱引用关联的对象在版之后提供了类来实现弱引用下面举个例子说明移除强引用只要执行了那么都会输出占用内存虚引用也称为幽灵引用或者幻影引用它是最弱的一种引用关系为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知虚引必须和引队列联合使在版之后提供了类来实现虚引用移除强引用触发垃圾回收后等待虚引用被加入队列表明对象已被回收检查队列是否有新的引用对象等待直到垃圾收集完成面试官如何判断对象是否存活候选人源自深入理解虚拟机第三版节一共可以有两种方法判定引用计数法在对象中添加一个引用计数器每当有一个地方引用它时计数器值就加一当引用失效时计数器值就减一任何时刻计数器为零的对象就是不可能再被使用的客观地说引用计数算法虽然占用了一些额外的内存空间来进行计数但它的原理简单判定效率也很高在大多数情况下它都是一个不错的算法却没有选用引用计数法来管理内存主要原因是这个看似简单的算法有很多例外情况要考虑必须要配合大量额外处理才能保证正确地工作譬如单纯的引用计数就很难解决对象之间相互循环引用的问题举个简单的例子对象和都有字段赋值令及除此之外这两个对象再无任何引用实际上这两个对象已经不可能再被访问但是它们因为互相引用着对方导致它们的引用计数都不为零引用计数算法也就无法回收它们可达性分析算法这个算法的基本思路就是通过一系列称为的根对象作为起始节点集从这些节点开始根据引用关系向下搜索搜索过程所走过的路径称为引用链如果某个对象到间没有任何引用链相连或者用图论的话来说就是从到这个对象不可达时则证明此对象是不可能再被使用的它们将会被判定为可回收的对象面试官如何判断对象是否真正死亡与候选人源自深入理解虚拟机第三版节要真正宣告一个对象死亡最多会经历两次标记过程如果对象在进行达性分析后发现没有与相连接的引用链那它将会被第一次标记随后进行一次筛选筛选的条件是此对象是否有必要执行方法假如对象没有覆盖方法或者方法已经被虚拟机调用过那么虚拟机将这两种情况都视为没有必要执行如果这个对象被判定为确有必要执行方法那么该对象将会被放置在一个名为的队列之中并在稍后由一条由虚拟机自动建立的低调度优先级的线程去执行它们的方法方法是对象逃脱死亡命运的最后一次机会稍后收集器将对中的对象进行第二次小规模的标记如果对象要在中成功拯救自己只要重新与引用链上的任何一个对象建立关联即可譬如把自己关键字赋值给某个类变量或者对象的成员变量那在第二次标记时它将被移出即将回收的集合如果对象这时候还没有逃脱那基本上它就真的要被回收了一次对象自我拯救的演示对象第一次成功拯救自己因为方法优先级很低暂停秒以等待它下面这段代码与上面完全相同但是这次自救却失败了因为方法优先级很低暂停秒以等待它运行结果值得一提的是代码中有两段完全一样的代码片段执行结果却是一次逃脱成功一次失败了这是因为任何一个对象的方法都只会被系统自动调用一次如果对象面临下一次回收它的方法不会被再次执行因此第二段代码的自救行动失败了面试官回收方法区如何判断个常量是废弃常量如何判断个类是的类候选人源自深入理解虚拟机第三版节方法区的垃圾收集主要回收两部分内容废弃的常量和不再使用的类回收废弃常量与回收堆中的对象非常类似举个常量池中字面量回收的例子假如一个字符串曾经进入常量池中但是当前系统又没有任何一个字符串对象的值是换句话说已经没有任何字符串对象引用常量池中的常量且虚拟机中也没有其他地方引用这个字面量如果在这时发生内存回收而且垃圾收集器判断确有必要的话这个常量就将会被系统清理出常量池判定一个常量是否废弃还是相对简单而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了需要同时满足下面三个条件该类所有的实例都已经被回收也就是堆中不存在该类及其任何派生子类的实例加载该类的类加载器已经被回收这个条件除非是经过精心设计的可替换类加载器的场景如的重加载等否则通常是很难达成的该类对应的对象没有在任何地方被引用无法在任何地方通过反射访问该类的方法虚拟机被允许对满足上述三个条件的无用类进行回收这里说的仅仅是被允许而并不是和对象一样没有引用了就必然会回收关于是否要对类型进行回收虚拟机提供了一些参数进行控制面试官垃圾回收算法有哪些高频候选人源自深入理解虚拟机第三版节我记得一共有四种分别是标记清除算法最早出现标记复制算法第二代标记整理算法第三代分代回收最新出现标记清除算法最早出现如它的名字一样算法分为标记和清除两个阶段首先标记出所有需要回收的对象在标记完成后统一回收掉所有被标记的对象也可以反过来标记存活的对象统一回收掉所有未被标记的对象它的主要缺点有两个第一个是执行效率不稳定如果堆中包含大量对象而且其中大部分是需要被回收的这时必须进行大量标记和清除的动作导致标记和清除两个过程的执行效率都随对象数量增长面降低第二个是内存空间的碎片化问题标记清除之后会产生大量不连续的内存碎片空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作标记复制算法第二代为了解决标记清除算法面对大量可回收对象时执行效率低的问题年提出了一种称为半区复制的垃圾收集算法它将可用内存按容量划分为大小相等的两块每次只使用其中的一块当这一块的内存用完了就将还存活着的对象复制到另外一块上面然后再把已使用过的内存空间一次清理掉这样实现简单运行高效不会发生碎片化不过其缺陷也显而易见这种复制回收算法的代价是将可用内在缩小为了原来的一半空问浪费未免太多了一点标记整理算法第三代年提出了另外一种有针对性的标记整理算法其中的标记过程仍然与标记清除算法一样但后续步骤不是直接对可回收对象进行清理而是让所有存活的对象都向内存空间一端移动然后直接清理掉边界以外的内存标记清除算法与标记整理算法的本质差异在于前者是一种非移动式的回收算法而后者是移动式的优点内存使用效率高不会发生碎片化缺点整体阶段的效率不高面试官你能详细聊一下分代回收吗候选人关于分代回收是这样的在时堆被分为了两份新生代和老年代它们默认空间占用比例是对于新生代内部又被分为了三个区域区区区默认空间占用比例是具体的工作机制当创建一个对象的时候那么这个对象会被分配在新生代的区当区要满了时候触发当进行后此时在区存活的对象被移动到区并且当前对象的年龄会加清空区当再一次触发的时候会把区中存活下来的对象和区中的对象移动到区中这些对象的年龄会加清空区和区当再一次触发的时候会把区中存活下来的对象和中的对象移动到区中这些对象的年龄会加清空区和区对象的年龄达到了某一个限定的值默认岁那么这个对象就会进入到老年代中当然也有特殊情况如果进入区的是一个大对象在触发的时候会直接存放到老年代当老年代满了之后触发同时回收新生代和老年代当前只会存在一个的线程进行执行其他的线程全部会被挂起我们在程序中要尽量避免的出现补充那些比例为什么要这么划分呢大部分对象都是短暂存在的而少数长期存活的对象则需要更多的空间通过合理分配空间给新生代和老年代可以最大化垃圾回收的效率并最小化对应用程序性能的影响这种比例设计是为了优化新生代内的对象管理和垃圾回收使系统能够在处理大量短寿命对象的同时也能有效地管理那些存活时间较长的对象通过这种方式可以提高整体的内存使用效率和垃圾回收效率面试官讲一下新生代老年代永久代的区别候选人新生代主要用来存放新生的对象老年代主要存放应用中生命周期长的内存对象永久代指的是永久保存区域主要存放和元数据的信息在中永久代已经被移除取而代之的是一个称之为元数据区元空间的区域元空间和永久代类似不过元空间与永久代之间最大的区别在于元空间并不在虚拟机中而是使用本地内存因此默认情况下元空间的大小仅受本地内存的限制面试官说一下有哪些垃圾回收器高频候选人在中实现了多种垃圾收集器包括串行垃圾收集器并行垃圾收集器默认垃圾收集器垃圾收集器默认衡量垃圾收集器的三项最重要的指标是内存占用吞吐量和延迟三者共同构成了一个不可能三角一款优秀的收集器通常最多可以同时达成其中的两项垃圾收集器分类作用位置使用算法特点适用场景串行运行作用于新生代复制算法响应速度优先适用于单环境下的模式并行运行作用于新生代复制算法响应速度优先多环境模式下与配合使并行运行作用于新生代复制算法吞吐量优先适用于后台运算而不需太多交互的场串行运行作用于老年代标记整理算法响应速度优先适用于单环境下的模式并行运行作用于老年代标记整理算法吞吐量优先适用于后台运算而不需太多交互的场并发运行作用于老年代标记清除算法低延迟适用于互联网或业务并发并行作用于新生代老年代标记整理算法复制吞吐量优先面向服务端应用并发并行全堆标记整理算法极低延迟高吞吐量适用于需要极高吞吐量和低延迟的发展阶段并行并发面试官你能解释一下三色标记增量更新算法和原始快照算法吗候选人三色标记是一种用于垃圾收集过程中对象标记的技术它将对象分为三种颜色白色表示尚未被访问的对象灰色表示部分访问的对象黑色表示完全访问的对象通过这种标记方法垃圾收集器可以从根节点开始逐步标记对象并最终清除白色对象如果用户线程此时是冻结的只有收集器线程在工作那不会有任何问题但如果用户线程与收集器是并发工作的收集器在对象图上标记颜色同时用户线程在修改引用关系这样就会可能出现两种后果一种是把原本消亡的对象错误标记为存活这不是好事但其实是可以容忍的只不过产生了点逃过本次收集的浮动垃圾而已下次收集清理掉就好另一种是把原本存活的对象错误标记为已消亡这就是非常致命的后果了当且仅当以下两个条件同时满足时会产生对象消失的问题即原本是黑色的对象被误标为白色赋值器插入了一条或多条从黑色对象到白色对象的新引用赋值器删除了全部从灰色对象到该白色对象的直接或间接引用因此我们要解决并发扫描时的对象消失问题只需破坏这两个条件的任意一个即可由此分别产生了两种解决方案增量更新和原始快照增量更新要破坏的是第一个条件当黑色对象插入新的指向白色对象的引用关系时就将这个新插入的引用记录下来等并发扫描结束之后再将这些记录过的引用关系中的黑色对象为根重新扫描一次这可以简化理解为黑色对象一旦新插入了指向白色对象的引用之后它就变回灰色对象了原始快照要破坏的是第二个条件当灰色对象要删除指向白色对象的引用关系时就将这个要删除的引用记录下来在并发扫描结束之后再将这些记录过的引用关系中的灰色对象为根重新扫描一次这也可以简化理解为无论引用关系删除与否都会按照刚刚开始扫描那一刻的对象图快照来进行搜索面试官说说垃圾回收器高频候选人源自深入理解虚拟机第三版节收集器是一种以获取最短回收停顿时间为目标的收集器从名字包含上就可以看出收集器是基于标记清除算法现的它的运作过程相对于前面几种收集器来说要更复杂一些整个过程分为四个步骤包括初始标记并发标记重新标记并发清除其中初始标记重新标记这两个步骤仍然需要停顿初始标记仅仅只是标记一下能直接关联到的对象速度很快并发标记阶段就是从的直接关联对象开始遍历整个对象图的过程这个过程耗时较长但是不需要停顿用户线程可以与垃圾收集线程一起并发运行而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录这个阶段通过写屏障记录在并发标记期间所有修改对象引用的操作基于增量更新来做并发标记最后是并发清除阶段清理删除掉标记阶段判断的已经死亡的对象由于不需要移动存活对象所以这个阶段也是可以与用户线程同时并发的是一款优秀的收集器它最主要的优点在名字上已经体现出来并发收集低停顿一些官方公开文档里面也称之为并发低停顿收集器但至少也有以下三个明显的缺点收集器无法处理浮动垃圾在的并发标记和并发清理阶段用户线程是还在继续运行的程序在运行自然就还会伴随有新的垃圾对象不断产生但这一部分垃圾对象是出现在标记过程结束以后无法在当次收集中处理掉它们只好留待下一次垃圾收集时再清理掉这一部分垃圾就称为浮动垃圾退化问题要是运行期间预留的内存无法满足程序分配新对象的需要就会出现一次并发失败这时候虚拟机将不得不启动后备预案冻结用户线程的执行临时启用收集器来重新进行老年代的垃圾收集但这样停顿时间就很长了是一款基于标记清除算法实现的收集器这意味着收集结束时会有大量空间碎片产生空间碎片过多时将会给大对象分配带来很大麻烦往往会出现老年代还有很多剩余空间但就是无法找到足够大的连续空间来分配当前对象而不得不提前触发一次的情况面试官说说垃圾回收器高频候选人源自深入理解虚拟机第三版节是一款主要面向服务端应用的垃圾收集器发布之日宣告取代组合成为服务端模式下的默认垃圾收集器而则沦落至被声明为不推荐使用的收集器在收集器出现之前的所有其他收集器包括在内垃圾收集的目标范围要么是整个新生代要么就是整个老年代再要么就是整个堆而跳出了这个樊笼它可以面向堆内存任何部分来组成回收集一般简称进行回收衡量标准不再是它属于哪个分代而是哪块内存中存放的垃圾数量最多回收收益最大这就是收集器的模式作为收集器的替代者和继承人设计者们希望做出一款能够建立起停顿预测模型的收集器停顿预测模型的意思是能够支持指定在一个长度为毫秒的时间片段内消耗在垃圾收集上的时间大概率不超过毫秒这样的目标这几乎已经是实时的中软实时垃圾收集器特征了收集器之所以能建立可预测的停顿时间模型是因为收集器通过将堆分成多个大小相等的独立区域让收集器去跟踪各个里面的垃圾堆积的价值大小然后后台维护一个优先级列表并根据用户设定的最大停顿时间优先回收最有价值的从而实现可控的停顿时间和高效垃圾回收收集器的运作过程大致可划分为以下四个步骤初始标记仅仅只是标记一下能直接关联到的对象并且修改指针的值让下一阶段用户线程并发运行时能正确地在可用的中分配新对象这个阶段需要停顿线程但耗时很短为每一个设计了两个名为的指针把中的一部分空间划分出来用于并发回收过程中的新对象分配并发回收时新分配的对象地址都必须要在这两个指针位置以上收集器默认在这个地址以上的对象是被隐式标记过的即默认它们是存活的不纳入回收范围并发标记从开始对堆中对象进行可达性分析递归扫描整个堆里的对象图找出要回收的对象这阶段耗时较长但可与用户程序并发执行当对象图扫描完成以后还要重新处理记录下的在并发时有引用变动的对象这里并不是全堆作为扫描而是使用记忆集用于记录哪些可能包含指向其他的对象这样在并发标记阶段只需要扫描这些可能包含跨引用的即可而不需要扫描整个堆最终标记对用户线程做另一个短暂的暂停用于处理并发阶段结束后仍遗留下来的最后那少量的记录这个阶段通过写屏障记录在并发标记期间所有修改对象引用的操作基于记录来做并发标记筛选回收负责更新的统计数据对各个的回收价值和成本进行排序根据用户所期望的停顿时间来制定回收计划可以自由选择任意多个构成回收集然后把决定回收的那一部的存活对象制到空的中再清理掉整个旧的全部空间这里的操作涉及存活对象的移动是必须暂停用户线程由多条收集器线程并行完成的从上述阶段的描述可以看出收集器除了并发标记外其余阶段也是要完全暂停用户线程的换言之它并非纯粹地追求低延迟官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量优点允许用户指定最大停顿时间目标使用减少垃圾回收过程中应用程序的暂停时间支持并发并行可以预测垃圾收集的停顿时间通过将堆划分为多个大小固定的并且可以灵活地选择哪些进行回收从而提高了内存利用率缺点相对于其他垃圾收集器的设计更加复杂这使得其理解和调优变得更加困难为了支持划分及相应的管理信息可能会消耗额外的内存资源来存储这些元数据收集器关键细节问题解决将堆分成多个独立后里面存在的跨引用对象如何解决解决思路使用记忆集避免全堆作为扫描但在收集器上记忆集的应用其实要复杂很多它的每个都维护有自己的记忆集这些记忆集会记录下别的指向自己的指针并标记这些指针分别在哪些卡页的范围之内的记忆集在存储结构的本质上是种哈希表是别的的起始地址是一个集合里面存储的元素是卡表的索引号这种双向的卡表结构卡表是我指向谁这种结构还记录了谁指向我比原来的卡表实现起来更复杂同时由于数量比传统收集器的分代数量明显要多得多因此收集器要比其他的传统垃圾收集器有着更高的内存占用负担在并发标记阶段如何保证收集线程与用户线程互不干扰地运行解决办法收集器采用增量更新算法实现而收集器则是通过原始快照算法来实现的面试官说说和垃圾回收器的区别记忆集卡表写屏障候选人源自深入理解虚拟机第三版节相比的优点有很多暂且不论可以指定最大停顿时间分的内存布局按收益动态确定回收集这些创新性设计带来的红利单从最传统的算法理论上看也更有发展潜力与的标记清除算法不同从整体来看是基于标记整理算法实现的收集器但从局部两个之间上看又是基于标记复制算法实现无论如何这两种算法都意味着运作期间不会产生内存空间碎片垃圾收集完成之后能提供规整的可用内存当然比起的弱项也可以列举出不少如在用户程序运行过程中无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比要高就内存占用来说虽然和都使用卡表来处理跨代指针但的卡表实现更为复杂而且堆中每个无论扮演的是新生代还是老年代角色都必须有一份卡表这导致的记忆集和其他内存消耗可能会占更多的内存空间相比起来的卡表就相当简单只有唯一一份而且只需要处理老年代到新生代的引用反过来则不需要由于新生代的对象具有朝生夕灭的不稳定性引用变化频繁能省下这个区域的维护开销是很划算的在执行负载的角度上它们都使用到写屏障用写后屏障来更新维护卡表而除了使用写后屏障来进行同样的由于的卡表结构复杂其实是更烦琐的卡表维护操作外为了实现原始快照搜索算法还需要使用写前屏障来跟踪并发时的指针变化情况拓展记忆集与卡表写屏障记忆集记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构卡表卡表就是记忆集的一种具体体现它定义了记忆集的记录精度与堆内存的映射关系等写屏障在虚拟机里是通过写屏障技术维护卡表状态的写屏障可以看作是在虚拟机层面对引用类型字段赋值这个动作的切面在引用对象赋值时会产生一个环形通知在赋值前的部分的写屏障叫做写前屏障在赋值后的则叫作写后屏障引用字段赋值操作写后屏障在这里完成卡表状态更新面试官说说你对收集器的理解可选高频候选人源自深入理解虚拟机第三版节收集器是一款基于内存布局的暂时不设分代的使用了读屏障染色指针和内存多重映射等技术来实现可并发的标记整理算法的以低延迟为首要目标的一款垃圾收集器染色指针是一种直接将少量额外的信息存储在指针上的技术的染色指针是最直接的最纯粹的他直接把标记信息记在引用对象的指针上染色指针可以使得一旦某个的存活对象被移走之后这个立即就能够被释放和重用掉而不必等待整个堆中所有指向该的引用都被修正后才能清理染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量设置内存屏障尤其是写屏障的目的通常是为了记录对象引用的变动情况如果将这些信息直接维护在指针中显然就可以省去一些专门的记录操作染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记重定位过程相关的数据以便日后进一步提高性能的运作过程大致可划分为以下四个大的阶段全部四个阶段都是可以并发执行的仅是两个阶段中间会存在短暂的停顿小阶段几乎在所有地方都并发执行的除了初始标记是的并发标记与一样并发标记是遍历对象图做可达性分析的阶段前后也要经过类似于的初始标记最终标记尽管中的名字不叫这些的短暂停顿而且这些停顿阶段所做的事情在目标上也是相类似的与不同的是的标记是在指针上而不是在对象上进行的标记阶段会更新染色指针中的标志位并发预备重分配这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些将这些组成重分配集统计需要清理的并组成重分配集重分配集与收集器的回收集还是有区别的划分的目的并非为了像那样做收益优先的增量回收相反每次回收都会扫描所有的用范围更大的扫描成本换取省去中记忆集的维护成本并发重分配重分配是执行过程中的核心阶段这个过程要把重分配集中的存活对象复制到新的上并为重分配集中的每个维护一个转发表记录从旧对象到新对象的转向关系得益于染色指针的支持收集器能仅从引用上就明确得知一个对象是否处于重分配集之中一旦重分配集中某个的存活对象都复制完毕后这个就可以立即释放用于新对象的分配但是转发表还得留着不能释放掉对象复制到新的上并维护一个转发表复制完毕后旧立即释放假设有两个和它们属于重分配集需要被清理每个包含若干对象我们需要将存活的对象复制到新的位置并更新指向这些对象的所有引用确定和为重分配集其他对象的引用和是存活对象复制到新的是存活对象复制到新的和不再存活将被丢弃创建转发表记录旧对象到新对象的映射关系旧的和可以被标记为可用但转发表暂时保留已标记为可用已标记为可用并发重映射重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用使它们指向新位置的对象很巧妙地把并发重映射阶段要做的工作合并到了下一次垃圾收集循环中的并发标记阶段里去完成反正它们都是要遍历所有对象的这样合并就节省了一次遍历对象图的开销一旦所有指针都被修正之后原来记录新旧对象关系的转发表就可以释放掉了修正旧对象引用与并发标记阶段合并释放转发表更新所有指向旧对象的引用一旦所有引用被修正转发表可以被释放更新前更新前完全没有使用记忆集每次垃圾回收都会扫描整个堆它甚至连分代都没有连像中那样只记录新生代和老年代间引用的卡表也不需要因而完全没有用到写屏障通过染色指针替代所以给用户线程带来的运行负担也要小得多可是必定要有优有劣才会称作权衡的这种选择也限制了它能承受的对象分配速率不会太高当应用程序频繁地创建和销毁大量短期生存的对象时需要频繁地进行对象的复制和引用更新操作这会导致更高的负载因为需要不断更新染色指针并且在重分配阶段进行大量的对象复制操作虽然的目标是降低暂停时间但如果对象分配速率非常高那么即使是短暂的暂停也会变得频繁从而影响整体性能拓展恐怖的测试结果在的弱项吞吐量方面以低延迟为首要目标的已经达到了以高吞吐量为目标的的直接超越了见图源自深入理解虚拟机第三版而在的强项停顿时间测试上它毫不留情地与拉开了两个数量级的差距见图源自深入理解虚拟机第三版面试官是什么候选人源自深入理解虚拟机第三版节部分收集指目标不是完整收集整个堆的垃圾收集其中又分为新生代收集指目标只是新生代的垃圾收集老年代收集指目标只是老年代的垃圾收集目前只有收集器会有单独收集老年代的行为混合收集指目标是收集整个新生代以及部分老年代的垃圾收集目前只有收集器会有这种行为整堆收集收集整个堆和方法区的垃圾收集尽量避免实践调优面试官调优的参数可以在哪里设置参数值候选人我们当时的项目是项目可以在项目启动的时候中加入参数就行了这里的和分别设置了初始堆大小和最大堆大小设置了使用的垃圾收集器为设置了使用的垃圾收集器为面试官用的调优的参数都有哪些候选人对于调优主要就是调整年轻代老年代元空间的内存空间大小及使用的垃圾回收器类型堆内存管理参数初始堆内存大小示例表示初始堆内存为最大堆内存大小示例表示最大堆内存为一旦堆区中的内存大小超过所指定的最大内存时将会抛出通常会将和两个参数配置相同的值其目的是为了能够在垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小从而提高性能年轻代管理参数年轻代大小示例表示年轻代大小为区与区的比例示例表示区与两个区的比例为垃圾收集器选择参数使用串行垃圾收集器使用并行垃圾收集器使用垃圾收集器使用垃圾收集器垃圾收集器优化参数最大暂停时间并行垃圾收集线程数并发标记线程数日志和调试参数开启日志详细信息时间戳在内存溢出时导出堆转储堆转储文件路径以下是一个包含常用参数的示例命令也可以直接在中设置参数面试官平时调试都用了哪些工具呢候选人嗯我们一般都是使用自带的一些工具比如输出中运行的进程状态信息查看进程内线程的堆栈信息用于生成堆转存快照文件用于统计监测工具实时查看和修改参数有时我们可以查看默认参数设置代码案例首先我们创建一个简单的应用程序用于演示如何使用这些工具这个简单的应用程序启动了一个无限循环的任务每隔一秒输出一条消息先启动程序然后使用查看正在运行中的进程输出可能类似于这里是进程用来查看进程中各个线程的堆栈信息输出可能类似于用于生成堆转存快照可以用来分析内存使用情况我们一般直接在参数中配置好了用来监控的运行时统计数据如垃圾收集情况内存使用情况等输出可能类似于还有一些可视化工具像和等面试官假如项目中产生了内存泄露你说一下你的排查思路候选人详情见结合模拟场景案例进行分析面试官你的调优经验候选人站直达尚硅谷精讲与调优教程直达大师级调优剖析高并发系统的垃圾回收优化实战调优案例一调整堆大小提升服务的吞吐量调优案例二逃逸分析之栈上分配标量替换锁清除调优案例二合理配置堆内存调优案例三占用很高的排查方案调优案例四并发线程数对性能的影响调优案例五调整垃圾回收器对吞吐量的影响调优案例六日均百万订单如何设置参数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-05 00:29:12',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 19
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/miahemu" title="GitHub"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="力扣"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="力扣"/><span class="back-menu-item-text">力扣</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="CSDN"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" href="https://miahemu.github.io/about/" title="个人简介"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="个人简介"/><span class="back-menu-item-text">个人简介</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">和睦的拾光物语</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9460279562&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 小挂件</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/weather/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 天气</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">JAVA面经<sup>12</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">数据结构与算法<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AF%95/" style="font-size: 1.05rem;">笔试<sup>8</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA%E9%9D%A2%E7%BB%8F/" itemprop="url">JAVA面经</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JAVA面经</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JVM相关面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-04-04T16:29:12.958Z" title="更新于 2025-04-05 00:29:12">2025-04-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">18.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="JVM相关面试题"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为鸡毛换糖城"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>鸡毛换糖城</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://w.wallhaven.cc/full/d6/wallhaven-d6225m.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://miahemu.github.io/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><header><a class="post-meta-categories" href="/categories/JAVA%E9%9D%A2%E7%BB%8F/" itemprop="url">JAVA面经</a><a href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" tabindex="-1" itemprop="url">JAVA面经</a><h1 id="CrawlerTitle" itemprop="name headline">JVM相关面试题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">玦尘</span><time itemprop="dateCreated datePublished" datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time><time itemprop="dateCreated datePublished" datetime="2025-04-04T16:29:12.958Z" title="更新于 2025-04-05 00:29:12">2025-04-05</time></header><div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p>
</div>

<div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p>
</div>

<hr>
<h2 id="1-JVM组成"><a href="#1-JVM组成" class="headerlink" title="1 JVM组成"></a>1 JVM组成</h2><h3 id="面试官：JVM由那些部分组成，运行流程是什么？"><a href="#面试官：JVM由那些部分组成，运行流程是什么？" class="headerlink" title="面试官：JVM由那些部分组成，运行流程是什么？"></a><strong>面试官</strong>：JVM由那些部分组成，运行流程是什么？</h3><p><strong>候选人:</strong></p>
<p>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）</p>
<p>它们的运行流程是：</p>
<p>第一，类加载器（ClassLoader）把Java代码转换为字节码。</p>
<p>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p>
<p>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p>
<p><strong>JDK1.6：（图为《深入理解Java虚拟机》第三版）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e93a4b0ba3d5a1d7e6c8ac.png" alt="image-20250225095840125"></p>
<p><strong>JDK1.8：（图为JavaGuide面试笔记）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e93a740ba3d5a1d7e6c8bb.png" alt="image-20250225095853712"></p>
<hr>
<h3 id="面试官：能简单说一下-JVM-运行时数据区吗？（高频）"><a href="#面试官：能简单说一下-JVM-运行时数据区吗？（高频）" class="headerlink" title="面试官：能简单说一下 JVM 运行时数据区吗？（高频）"></a><strong>面试官</strong>：能简单说一下 JVM 运行时数据区吗？<code>（高频）</code></h3><p><strong>候选人:</strong></p>
<p>运行时数据区包含了堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。</p>
<ul>
<li>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</li>
<li>方法区可以认为是线程共享区域，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</li>
<li>虚拟机栈为虚拟机执行Java方法（也就是字节码服务），不需要执行GC。</li>
<li>本地方法栈执行的是本地方法，不需要执行GC。</li>
<li>程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</li>
</ul>
<hr>
<h3 id="面试官：详细介绍一下程序计数器的作用？"><a href="#面试官：详细介绍一下程序计数器的作用？" class="headerlink" title="面试官：详细介绍一下程序计数器的作用？"></a><strong>面试官</strong>：详细介绍一下程序计数器的作用？</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 2.2.1节）</p>
<p>1）程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器⼯作时通过改变这个计数器的值来选取下⼀条需要执⾏的字节码指令</strong>，分⽀、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<p>2）另外，<strong>为了线程切换后能恢复到正确的执⾏位置，每条线程都需要有⼀个独⽴的程序计数器</strong>，各线程之间计数器互不影响，独⽴存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>3）如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的<strong>虚拟机字节码指令的地址</strong>；如果正在执行的是本地(Native)方法，这个计数器值则<strong>应为空(Undefined)</strong>。</p>
<p>4）此内存区域是唯一一个在《 Java 虚拟机规范》中没有规定任何 <strong>OutOfMemoryError</strong> 情况的区域。</p>
<blockquote>
<p>通过一个简单的例子来说明**程序计数器(Program Counter Register)**的行为。</p>
<p>假设我们有以下Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">     nativeMethod();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先打印了一条消息到控制台，然后调用了一个本地方法<code>nativeMethod()</code>。</p>
<p>在这个过程中，程序计数器的行为如下：</p>
<ol>
<li><strong>执行Java方法时</strong>：<ul>
<li>当<code>main</code>方法开始执行时，程序计数器会指向<code>Example</code>类的<code>main</code>方法的第一条字节码指令。</li>
<li>随着<code>System.out.println(&quot;Hello, World!&quot;);</code>语句的执行，程序计数器会依次指向该语句对应的字节码指令。</li>
<li>比如，可能有一条字节码指令用于创建<code>String</code>对象，另一条用于调用<code>println</code>方法等。</li>
</ul>
</li>
<li><strong>执行本地方法时</strong>：<ul>
<li>当<code>main</code>方法调用<code>nativeMethod()</code>时，程序计数器的值会变成<code>Undefined</code>，因为一旦进入本地方法的执行，控制权就从JVM转移到了本地代码上，而本地代码的执行不是通过字节码指令来进行的，因此程序计数器无法记录这些指令的位置。</li>
</ul>
</li>
</ol>
<p>当<code>nativeMethod()</code>返回后，程序计数器会恢复到调用<code>nativeMethod()</code>之后的下一条字节码指令处，继续执行剩下的<code>main</code>方法中的代码。</p>
</blockquote>
<hr>
<h3 id="面试官：什么是虚拟机栈"><a href="#面试官：什么是虚拟机栈" class="headerlink" title="面试官：什么是虚拟机栈"></a><strong>面试官</strong>：什么是虚拟机栈</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 2.2.2节）</p>
<p>1）与程序计数器⼀样，Java 虚拟机栈也是<strong>线程私有</strong>的，它的**⽣命周期和线程相同**。虚拟机栈描述的是 Java⽅法执⾏的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个<strong>栈帧(Stack Frame)<strong>用于存储</strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<blockquote>
<p>经常有人把 Java 内存区域笼统地划分为<code>堆内存(Heap)</code>和<code>栈内存(Stack)</code>，这种划分方式直接继承自传统的 C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中,“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的<code>虚拟机栈</code>，或者更多的情况下<strong>只是指虚拟机栈中局部变量表部分</strong>。</p>
</blockquote>
<p>2）局部变量表主要存放了编译期可知的<strong>各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引⽤</strong>（reference 类型，它不同于对象本身，可能是⼀个指向对象起始地址的引⽤指针，也可能是指向⼀个代表对象的句柄或其他与此对象相关的位置）和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）。</p>
<p>3）在《 Java 虚拟机规范》中，对这个内存区域规定了两类异常状况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常;</li>
<li>如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 <strong>OutOfMemoryError</strong> 异常。</li>
</ul>
<blockquote>
<p><strong>栈内存溢出的两种可能：</strong></p>
<ul>
<li>栈帧过多导致栈内存溢出（递归调用）</li>
<li>栈帧过大导致栈内存溢出</li>
</ul>
</blockquote>
<blockquote>
<p><strong>栈内存分配越大越好吗？</strong></p>
<p>未必，默认栈内存通常1024K，栈帧过大会导致线程数变少。</p>
</blockquote>
<hr>
<h3 id="面试官：能不能解释一下本地方法栈？"><a href="#面试官：能不能解释一下本地方法栈？" class="headerlink" title="面试官：能不能解释一下本地方法栈？"></a><strong>面试官</strong>：能不能解释一下本地方法栈？</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 2.2.3节）</p>
<p>和虚拟机栈所发挥的作⽤⾮常相似，区别是： <strong>虚拟机栈为虚拟机执⾏</strong> <strong>Java</strong> <strong>⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的</strong> <strong>Native</strong> <strong>⽅法服务。</strong> 在 HotSpot 虚拟机中， Java虚拟机栈和本地方法栈合⼆为⼀。</p>
<p>与虚拟机栈一样，本地方法栈也会在<strong>栈深度溢出</strong>或者<strong>栈扩展失败</strong>时分别抛出 <strong>StackOverflowError</strong> 和 <strong>OutOfMemoryError</strong> 异常。</p>
<hr>
<h3 id="面试官：你能给我详细的介绍Java堆吗"><a href="#面试官：你能给我详细的介绍Java堆吗" class="headerlink" title="面试官：你能给我详细的介绍Java堆吗?"></a><strong>面试官</strong>：你能给我详细的介绍Java堆吗?</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 2.2.4节）</p>
<p>1）Java 虚拟机所管理的内存中最⼤的⼀块，Java 堆是所有线程共享的⼀块内存区域，在虚拟机启动时创建。此内存区域的唯⼀⽬的就是存放对象实例，⼏乎所有的<strong>对象实例</strong>以及<strong>数组</strong>都在这⾥分配内存。</p>
<blockquote>
<p>Java世界中“⼏乎”所有的对象都在堆中分配，但是，随着<strong>JIT编译器（即时编译技术）<strong>的发展与</strong>逃逸分析技术</strong>逐渐成熟，栈上分配、标量替换优化技术将会导致⼀些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从<strong>JDK 1.7开始已经默认开启逃逸分析</strong>，如果某些⽅法中的对象引⽤没有被返回或者未被外⾯使⽤（也就是未逃逸出去），那么对象可以直接在<strong>栈上</strong>分配内存。</p>
</blockquote>
<p>2）Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆</strong>（Garbage Collected Heap）。从垃圾回收的⻆度，由于现在收集器基本都采⽤<strong>分代垃圾收集算法</strong>，所以 Java 堆还可以细分为：新⽣代和⽼年代；再细致⼀点有：Eden 空间、From Survivor、To Survivor 空间等。进⼀步划分的⽬的是<strong>更好地回收内存，或者更快地分配内存</strong>。</p>
<p>3）如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出 <strong>OutOfMemoryError</strong> 异常。</p>
<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下⾯三部分：</p>
<ol>
<li>新⽣代内存(Young Generation)</li>
<li>⽼⽣代(Old Generation)</li>
<li>永⽣代(Permanent Generation)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e93abd0ba3d5a1d7e6c8ce.png" alt="image-20250225095939542"></p>
<p>JDK 8 版本之后**⽅法区（HotSpot 的永久代）<strong>被彻底移除了（JDK1.7 就已经开始了），取⽽代之是</strong>元空间**，元空间使⽤的是<strong>直接内存</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e93ac50ba3d5a1d7e6c8cf.png" alt="image-20250225095950616"></p>
<hr>
<h3 id="面试官：你听过方法区吗？"><a href="#面试官：你听过方法区吗？" class="headerlink" title="面试官：你听过方法区吗？"></a><strong>面试官</strong>：你听过方法区吗？</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 2.2.5节）</p>
<p>1）⽅法区（也叫堆外内存）与 Java 堆⼀样，是各个<strong>线程共享的内存区域</strong>，它⽤于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>2）根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 <strong>OutOfMemoryError</strong> 异常。</p>
<blockquote>
<p><strong>⽅法区和永久代的关系</strong></p>
<p>《Java 虚拟机规范》只是规定了有⽅法区这么个概念和它的作⽤，并没有规定如何去实现它。那么，在不同的 JVM 上⽅法区的实现肯定是不同的了。 <strong>⽅法区和永久代的关系很像Java 中接⼝和类的关系，类实现了接⼝，⽽永久代就是 HotSpot 虚拟机对虚拟机规范中⽅法区的⼀种实现⽅式。</strong> 也就是说，永久代是 HotSpot 的概念，⽅法区是 Java 虚拟机规范中的定义，是⼀种规范，⽽永久代是⼀种实现，⼀个是标准⼀个是实现，其他的虚拟机实现并没有永久代这⼀说法。</p>
</blockquote>
<blockquote>
<p><strong>为什么要将永久代</strong> <strong>(PermGen)</strong> <strong>替换为元空间</strong> <strong>(MetaSpace)</strong> <strong>呢?</strong></p>
<p>整个永久代有⼀个 JVM 本身设置固定⼤⼩上限，⽆法进⾏调整，很容易造成OOM，⽽元空间使⽤的是<strong>直接内存</strong>，受本机可⽤内存的限制，不会进行GC，也因此提升了性能。</p>
</blockquote>
<hr>
<h3 id="面试官：-说下直接内存？"><a href="#面试官：-说下直接内存？" class="headerlink" title="面试官： 说下直接内存？"></a><strong>面试官：</strong> 说下直接内存？</h3><p><strong>候选人：</strong>（源自《深入理解Java虚拟机》第三版 2.2.7节）</p>
<p>1）直接内存并不是虚拟机运⾏时数据区的⼀部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使⽤。⽽且也可能导致 <strong>OutOfMemoryError</strong> 错误出现。</p>
<p>2）JDK1.4 中新加⼊的 <strong>NIO(New Input&#x2F;Output)</strong> 类，引⼊了⼀种<strong>基于通道（Channel） 与缓存区（Buffer） 的 I&#x2F;O ⽅式</strong>，它可以直接使⽤ <strong>Native 函数库</strong>直接分配堆外内存，然后通过⼀个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引⽤进⾏操作。这样就能在⼀些场景中显著提⾼性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</p>
<p>3）本机直接内存的分配<strong>不会受到 Java 堆的限制</strong>，但是，既然是内存就会受到<strong>本机总内存⼤⼩<strong>以及</strong>处理器寻址空间的限制</strong>。</p>
<hr>
<h3 id="面试官：能说一下堆栈的区别是什么吗？"><a href="#面试官：能说一下堆栈的区别是什么吗？" class="headerlink" title="面试官：能说一下堆栈的区别是什么吗？"></a><strong>面试官</strong>：能说一下堆栈的区别是什么吗？</h3><p><strong>候选人:</strong></p>
<ol>
<li><p>栈内存一般会用来存储<strong>局部变量和方法调用</strong>，但堆内存是用来存储<strong>Java对象和数组</strong>的。</p>
</li>
<li><p>堆会GC垃圾回收，而栈不会。</p>
</li>
<li><p>栈内存是线程私有的，而堆内存是线程共有的。</p>
</li>
<li><p>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p>
<p>栈空间不足：java.lang.StackOverFlowError。</p>
<p>堆空间不足：java.lang.OutOfMemoryError。</p>
</li>
</ol>
<hr>
<h3 id="面试官：方法中定义的局部变量是否是线程安全的？"><a href="#面试官：方法中定义的局部变量是否是线程安全的？" class="headerlink" title="面试官：方法中定义的局部变量是否是线程安全的？"></a><strong>面试官</strong>：方法中定义的局部变量是否是线程安全的？</h3><p><strong>候选人:</strong></p>
<p>这个得分情况讨论：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariableThreadSafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的，因为线程私有，不会被其他线程调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全，因为stringBuilder是外面传进来的，有可能被多个线程调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder stringBuilder)</span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全，因为返回了一个StringBuilder对象，有可能被其他线程共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        builder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        builder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全，返回的是stringBuilder.toString()相当于new了一个String对象（可以去看源码）</span></span><br><span class="line">    <span class="comment">// 没有被其他线程共享的可能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h2><h3 id="面试官：什么是类加载器，类加载器有哪些"><a href="#面试官：什么是类加载器，类加载器有哪些" class="headerlink" title="面试官：什么是类加载器，类加载器有哪些?"></a><strong>面试官</strong>：什么是类加载器，类加载器有哪些?</h3><p><strong>候选人:</strong></p>
<p>Java 虚拟机设计团队有意把类加载阶段中的“<strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”(Class Loader)。</p>
<p>常见的类加载器有4个：</p>
<ol>
<li><p>启动类加载器(BootStrap Class Loader)：由C++编写实现。用于加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的类库。加载Java中最核心的类。</p>
</li>
<li><p>扩展类加载器(Extension Class Loader)：主要加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类库。允许扩展Java中比较通用的类。在JDK9之后变成<strong>平台类加载器</strong>。</p>
</li>
<li><p>应用类加载器(Application Class Loader)：主要用于加载用户类路径（ClassPath）上所有的类库，也就是加载开发者自己编写的类。</p>
</li>
<li><p>自定义类加载器：开发者自定义类继承ClassLoader类，实现自定义类加载规则。</p>
</li>
</ol>
<hr>
<h3 id="面试官：-什么是TLAB？与Eden区的关系？"><a href="#面试官：-什么是TLAB？与Eden区的关系？" class="headerlink" title="面试官： 什么是TLAB？与Eden区的关系？"></a><strong>面试官：</strong> 什么是TLAB？与Eden区的关系？</h3><p><strong>候选人：</strong> TLAB（Thread Local Allocation Buffer）是 <strong>Eden 区的一部分</strong>，它的目的是减少多线程分配对象时的锁竞争，提高分配效率。</p>
<p>可以简单理解为：</p>
<ul>
<li><strong>Eden 区是所有线程共享的</strong>，用于存放新创建的对象。</li>
<li><strong>TLAB 是 Eden 区在每个线程中的“私有缓存”</strong>，每个线程在 Eden 区预分配一小块区域，用于减少并发竞争。</li>
<li>当线程需要分配对象时，<strong>优先在自己的 TLAB 中分配</strong>，避免 Eden 区的全局锁竞争。</li>
<li>只有当 <strong>TLAB 用完后，才会尝试直接在 Eden 区分配</strong>（如果 Eden 空间足够），或者触发 GC。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67f008c00ba3d5a1d7ed6d77.png" alt="12763182"></p>
<hr>
<h3 id="面试官：对象创建的过程了解吗？（高频）"><a href="#面试官：对象创建的过程了解吗？（高频）" class="headerlink" title="面试官：对象创建的过程了解吗？（高频）"></a><strong>面试官</strong>：对象创建的过程了解吗？<code>（高频）</code></h3><p><strong>候选人:</strong></p>
<p>第一步是进行<strong>类加载检查</strong>，当程序执行到 new 指令时，JVM 会先检查对应的类是否已经被加载、解析和初始化过。如果类尚未加载，JVM 会按照类加载机制（加载、验证、准备、解析、初始化…）完成类的加载过程。</p>
<p>第二步是进行<strong>内存的分配</strong>，JVM 会为新对象分配内存空间。对象所需的内存大小在类加载完成后就可以确定，因此分配内存的过程就是从堆中划分一块连续的空间，主要有两种方式：</p>
<ul>
<li>一种是通过<strong>指针碰撞</strong>，如果堆中的内存是规整的（已使用和空闲区域之间有明确分界），JVM 可以通过移动指针来分配内存。另一种是通过<strong>空闲列表</strong>，如果堆中的内存是碎片化的，JVM 会维护一个空闲列表，记录可用的内存块，并从中分配合适的区域。</li>
</ul>
<blockquote>
<p><strong>分配内存在并发环境下如果存在锁的竞争，JVM如何解决这个问题？</strong></p>
<p><strong>线程本地缓存（Thread Local Allocation Buffer，TLAB）</strong></p>
<ul>
<li>JVM 为每个线程分配一块 <strong>私有的小内存区域</strong>（TLAB），线程在 TLAB 内部分配对象时不会加锁，避免了竞争。</li>
<li>只有当 TLAB 不够用时，才会触发全局堆分配，可能涉及锁的竞争。</li>
</ul>
<p><strong>CAS + 重试 (TLAB内存不足时)</strong></p>
<ul>
<li>如果对象需要在全局堆内存中分配，JVM 采用 <strong>CAS + 重试</strong> 机制更新内存分配指针，避免传统的锁开销，提高并发性能。</li>
<li>如果 CAS 失败，说明有多个线程竞争，JVM 会自动重试，直到成功。</li>
</ul>
</blockquote>
<p>第三步是将<strong>零值初始化</strong>，JVM 会对分配的内存空间进行初始化，将其所有字段设置为零值（如 int 为 0，boolean 为 false，引用类型为 null）。这一步确保了对象的实例字段在未显式赋值前有一个默认值，从而避免未初始化的变量被访问。</p>
<p>第四步是<strong>设置对象头</strong>，其中包含Mark Word、Klass Pointer和数组长度。Mark Word 用于存储对象的哈希码、GC 分代年龄、锁状态标志等信息。Klass Pointer 指向对象所属类的元数据（即 Person.class 的地址）。</p>
<p>第五步是<strong>执行构造方法</strong>，用 <init> 方法完成对象的初始化。构造方法会根据代码逻辑对对象的字段进行赋值，并调用父类的构造方法完成继承链的初始化。这一步完成后，对象才真正可用。</p>
<hr>
<h3 id="面试官：说一下类装载的执行过程？（高频）"><a href="#面试官：说一下类装载的执行过程？（高频）" class="headerlink" title="面试官：说一下类装载的执行过程？（高频）"></a><strong>面试官</strong>：说一下类装载的执行过程？<code>（高频）</code></h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 7.2节）</p>
<p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)<strong>七个阶段，其中</strong>验证、准备、解析</strong>三个部分统称为连接(Linking)。这七个阶段的发生顺序如图 7-1 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e946af0ba3d5a1d7e6cc71.png" alt="image-20250225100038241"></p>
<p><strong>1.加载</strong>：通过一个类的全限定名来获取定义此类的二进制字节流，加载完类之后，JVM将字节码信息保存到方法区中，生成一个<code>InstanceClass对象</code>，保存类的所有信息，最后在堆区生成一个代表这个类的<code>java.lang.Class</code>对象。</p>
<blockquote>
<p>Tips:<strong>为什么要在堆区生成一个java.lang.Class对象，不直接使用方法区呢？</strong></p>
<p>虽然类的信息主要保存在方法区，但是为了提供一个可访问的接口、支持反射操作、便于垃圾回收以及增强安全性，Java设计者选择在<strong>堆区</strong>生成一个<code>java.lang.Class</code>对象。这种方法使得类的信息更加易于管理和访问，同时也保持了方法区的纯粹性，使其专注于存储类的元数据。</p>
</blockquote>
<p><strong>2.验证</strong>：保证加载类的准确性。如验证字节流是否以魔数<code>0xCAFEBABE</code>开头；主、次版本号是否在当前Java虚拟机接受范围之内等。</p>
<p><strong>3.准备</strong>：为静态变量分配内存并设置类变量初始值。</p>
<blockquote>
<p>关于准备阶段，还有两个容易产生混淆的概念需要着重强调，首先是这时候进内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象起分配在 Java 堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设个类变量的定义为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>那变量 value在准备阶段过后的初始值为0而不是123，因为这时，尚未开始执行任何Java方法，而把 value 赋值为 123 的 <code>putstatic</code> 指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code> 方法之中，所以把 value 赋值为 123 的动作要到类的<strong>初始化阶段</strong>才会被执行。</p>
</blockquote>
<blockquote>
<p>Tips：<strong>为什么要赋初始值？</strong></p>
<p>如果不赋初始值，当类初始化时得到的就是系统残留的随机值，不友好。</p>
</blockquote>
<p><strong>4.解析</strong>：把类中的符号引用转换为直接引用。</p>
<blockquote>
<p>补充：<strong>符号引用和直接引用</strong></p>
<ul>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
</ul>
<p>解析的目的在于让JVM能够正确地调用类的方法、访问类的字段等。只有当符号引用被解析成了直接引用，JVM才能知道在内存中定位到具体的地址，并执行相应的操作。</p>
</blockquote>
<p><strong>5.初始化</strong>：执行静态代码块，为静态变量赋值。（初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程）</p>
<p><strong>6.使用</strong>：JVM 开始从入口方法开始执行用户的程序代码。</p>
<p><strong>7.卸载</strong>：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。</p>
<hr>
<h3 id="面试官：什么是双亲委派模型？（高频）"><a href="#面试官：什么是双亲委派模型？（高频）" class="headerlink" title="面试官：什么是双亲委派模型？（高频）"></a><strong>面试官</strong>：什么是双亲委派模型？<code>（高频）</code></h3><p><strong>候选人:</strong></p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的<strong>启动类加载器</strong>中，只有当父类加载器返回自己<strong>无法完成</strong>这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载。</p>
<p><strong>双亲委派模型的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑清晰易懂：先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出 <strong>ClassNotFoundException</strong> 异常的话，才调用自己的 findClass()方法尝试进行加载。</p>
<h3 id="面试官：JVM为什么采用双亲委派机制"><a href="#面试官：JVM为什么采用双亲委派机制" class="headerlink" title="面试官：JVM为什么采用双亲委派机制"></a><strong>面试官</strong>：JVM为什么采用双亲委派机制</h3><p><strong>候选人:</strong></p>
<p>主要有两个原因。</p>
<p>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后子类无需重复加载，保证<strong>唯一性</strong>。</p>
<p>第二、为了安全，保证类库API不会被修改，保证<strong>安全性</strong>。</p>
<blockquote>
<p>在工程中新建java.lang包，接着在该包下新建String类，并定义main函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时无法执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法。出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库。</p>
</blockquote>
<hr>
<h3 id="面试官：怎样破坏双亲委派机制？"><a href="#面试官：怎样破坏双亲委派机制？" class="headerlink" title="面试官：怎样破坏双亲委派机制？"></a><strong>面试官</strong>：怎样破坏双亲委派机制？</h3><p><strong>候选人:</strong></p>
<ol>
<li>自定义类加载器并且重写loadClass方法，就可将双亲委派机制破坏。</li>
<li>JNDI服务使用<strong>线程上下文类加载器</strong>去加载所需的<strong>SPI服务代码</strong>。这是一种父类加载器去请求子类加载器完成类加载的行为。</li>
<li>Osgi框架的类加载器。</li>
</ol>
<hr>
<h2 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3 垃圾回收"></a>3 垃圾回收</h2><h3 id="前提知识："><a href="#前提知识：" class="headerlink" title="前提知识："></a>前提知识：</h3><h4 id="并行与并发："><a href="#并行与并发：" class="headerlink" title="并行与并发："></a>并行与并发：</h4><ul>
<li>并行(Parallel)：并行说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</li>
<li>并发(Concurrent)：并发说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求。<strong>（有可能对象引用被修改）</strong></li>
</ul>
<h4 id="内存溢出与内存泄漏："><a href="#内存溢出与内存泄漏：" class="headerlink" title="内存溢出与内存泄漏："></a>内存溢出与内存泄漏：</h4><ul>
<li>内存泄漏(memory leak)：在Java中如果不再使用一个对象，但是该对象依然在<strong>GC ROOT的引用链上</strong>这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏。大多数都是由<strong>堆内存</strong>泄漏引起的。</li>
<li>少量的内存泄漏可以容忍，但是如果发生持续的内存泄漏，就像滚雪球雪球越滚越大，不管有多大的内存迟早会被消耗完，最终导致的结果就是<strong>内存溢出</strong>。但是产生内存溢出并不是只有内存泄漏这一种原因。</li>
</ul>
<h3 id="面试官：简述Java垃圾回收机制？（GC是什么？为什么要GC）"><a href="#面试官：简述Java垃圾回收机制？（GC是什么？为什么要GC）" class="headerlink" title="面试官：简述Java垃圾回收机制？（GC是什么？为什么要GC）"></a><strong>面试官</strong>：简述Java垃圾回收机制？（GC是什么？为什么要GC）</h3><p><strong>候选人:</strong></p>
<p>为了让程序员<strong>更专注于代码的实现</strong>，而<strong>不用过多的考虑内存释放的问题</strong>，所以，在<strong>Java</strong>语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p>
<p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p>
<p>引入垃圾回收机制的主要目的是为了<strong>减轻程序员的负担，提高程序的健壮性和效率，同时减少内存泄漏等问题</strong>。</p>
<h3 id="面试官：强引用、软引用、弱引用、虚引用的区别？"><a href="#面试官：强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="面试官：强引用、软引用、弱引用、虚引用的区别？"></a><strong>面试官</strong>：强引用、软引用、弱引用、虚引用的区别？</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.2.3节）</p>
<p><strong>在JDK1.2版之前</strong>，Java 里面的引用是很传统的定义：一个对象在这种定义下只有 <strong>“被引用”</strong> 或者 <strong>“未被引用”</strong> 两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的<strong>缓存功能</strong>都符合这样的应用场景。</p>
<p><strong>在 JDK 1.2版之后</strong>，Java对引用的概念进行了扩充，将引用分为强引用(Strongly Re-ference)、软引用(Soft Reference)、弱引用(WeakReference)和虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。</p>
<p>1）强引用是最传统的“引用”的定义，是指在程序代码之中<strong>普遍存在的引用赋值</strong>，即类似<code>Object obj=new Object()</code>这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就<strong>永远不会回收</strong>掉被引用的对象。</p>
<p>2）软引用是用来描述一些<strong>还有用，但非必须</strong>的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2 版之后提供了<code>SoftReference类</code>来实现软引用。下面举个例子说明：</p>
<p>首先限制其最大堆内存：<code>-Xmx2M -Xms1M</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e946d40ba3d5a1d7e6cc86.png" alt="image-20250225100111770"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VeryLargeObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VeryLargeObject</span>();</span><br><span class="line">        SoftReference&lt;VeryLargeObject&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(object);</span><br><span class="line">        object = <span class="literal">null</span>; <span class="comment">// 移除强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个大对象来模拟内存压力</span></span><br><span class="line">        createMemoryPressure();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试让垃圾收集器工作</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查软引用是否仍然有效</span></span><br><span class="line">        <span class="keyword">if</span> (softRef.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Soft reference was cleared.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Soft reference is still valid.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VeryLargeObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] largeByteArray = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 占用1MB内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createMemoryPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123; <span class="comment">// 创建更多大对象</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">VeryLargeObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果： Soft reference was cleared.</span></span><br><span class="line"><span class="comment">// 如果把堆大小设置很大时，就会输出：Soft reference is still valid.</span></span><br></pre></td></tr></table></figure>

<p>3）弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，<strong>无论当前内存是否足够</strong> ，都只会回收掉被弱引用关联的对象。在JDK 1.2版之后提供了<code>WeakReference类</code>来实现弱引用。下面举个例子说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VeryLargeObject</span>();</span><br><span class="line">        WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(object);</span><br><span class="line">        object = <span class="literal">null</span>; <span class="comment">// 移除强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要执行了 System.gc(); 那么都会输出 Weak reference was cleared.</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (weakRef.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Weak reference was cleared.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Weak reference is still valid.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VeryLargeObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] largeByteArray = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 占用10MB内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。**为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。**虚引⽤必须和引⽤队列（ReferenceQueue）联合使⽤。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(object, queue);</span><br><span class="line">        object = <span class="literal">null</span>; <span class="comment">// 移除强引用</span></span><br><span class="line"></span><br><span class="line">	   <span class="comment">// 触发垃圾回收后，等待虚引用被加入队列，表明对象已被回收。</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查队列是否有新的引用对象</span></span><br><span class="line">        <span class="keyword">while</span> (queue.poll() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待直到垃圾收集完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Phantom reference was enqueued in the queue.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="面试官：如何判断对象是否存活？"><a href="#面试官：如何判断对象是否存活？" class="headerlink" title="面试官：如何判断对象是否存活？"></a><strong>面试官</strong>：如何判断对象是否存活？</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.2.1  3.2.2节）</p>
<p>一共可以有两种方法判定：</p>
<ul>
<li><p><code>引用计数法</code>：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<blockquote>
<p>客观地说，引用计数算法(Reference Counting)虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。JVM却没有选用引用计数法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互<strong>循环引用</strong>的问题。</p>
<p>举个简单的例子，对象 objA 和 objB 都有字段instance，赋值令 objA.instance &#x3D;objB 及 objB.instance &#x3D;objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</p>
</blockquote>
</li>
<li><p><code>可达性分析算法</code>：这个算法的基本思路就是通过一系列称为 <strong>“GCRoots”</strong> 的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走过的路径称为 <strong>“引用链”(Reference Chain)</strong> ，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的，它们将会被判定为可回收的对象。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e947350ba3d5a1d7e6cc9e.png" alt="image-20250225100131522"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e947500ba3d5a1d7e6ccad.png" alt="image-20250225100145308"></p>
</li>
</ul>
<hr>
<h3 id="面试官：如何判断对象是否真正死亡？fnalize-与System-gc"><a href="#面试官：如何判断对象是否真正死亡？fnalize-与System-gc" class="headerlink" title="面试官：如何判断对象是否真正死亡？fnalize()与System.gc()"></a><strong>面试官</strong>：如何判断对象是否真正死亡？fnalize()与System.gc()</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.2.4节）</p>
<p>要真正宣告一个对象死亡，最多会经历<strong>两次标记</strong>过程：</p>
<ol>
<li>如果对象在进行达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 <code>fnalize()</code>方法。假如对象没有覆盖<code>finalize()</code>方法，或者 <code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</li>
<li>如果这个对象被判定为确有必要执行<code>finalize()</code>方法，那么该对象将会被放置在一个名为 <code>F-Queue</code> 的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 <code>Finalizer</code>线程去执行它们的<code>finalize()</code>方法。<strong><code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会</strong>，稍后收集器将对 <code>F-Queue</code> 中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；<strong>如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</strong></li>
</ol>
<blockquote>
<p>一次对象自我拯救的演示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;I am still alive&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">     <span class="built_in">super</span>.finalize();</span><br><span class="line">     System.out.println(<span class="string">&quot;finalize method executed&quot;</span>);</span><br><span class="line">     FinalizeEscapeGC.SAVE_INSTANCE = <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     SAVE_INSTANCE = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">     SAVE_INSTANCE = <span class="literal">null</span>;</span><br><span class="line">     System.gc();</span><br><span class="line">     <span class="comment">// 因为Finalizer方法优先级很低，暂停1秒，以等待它</span></span><br><span class="line">     Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">     <span class="keyword">if</span>(SAVE_INSTANCE != <span class="literal">null</span>)&#123;</span><br><span class="line">         SAVE_INSTANCE.isAlive();</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 下面这段代码与上面完全相同，但是这次自救却失败了</span></span><br><span class="line">     SAVE_INSTANCE = <span class="literal">null</span>;</span><br><span class="line">     System.gc();</span><br><span class="line">     <span class="comment">// 因为Finalizer方法优先级很低，暂停1秒，以等待它</span></span><br><span class="line">     Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">     <span class="keyword">if</span>(SAVE_INSTANCE != <span class="literal">null</span>)&#123;</span><br><span class="line">         SAVE_INSTANCE.isAlive();</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize method executed</span><br><span class="line">I am still alive</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure>

<p>值得一提的是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为任何一个对象的 finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
</blockquote>
<hr>
<h3 id="面试官：-（回收方法区）如何判断⼀个常量是废弃常量-如何判断⼀个类是⽆⽤的类"><a href="#面试官：-（回收方法区）如何判断⼀个常量是废弃常量-如何判断⼀个类是⽆⽤的类" class="headerlink" title="面试官： （回收方法区）如何判断⼀个常量是废弃常量?如何判断⼀个类是⽆⽤的类?"></a><strong>面试官</strong>： （回收方法区）如何判断⼀个常量是废弃常量?如何判断⼀个类是⽆⽤的类?</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.2.4节）</p>
<p>1）方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量</strong>和<strong>不再使用的类</strong>。</p>
<p>2）回收废弃常量与回收 Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。<br>3）<strong>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了</strong>。需要同时满足下面三个条件：</p>
<ul>
<li><p>该类所有的<strong>实例</strong>都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p>
</li>
<li><p>加载该类的<strong>类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</p>
</li>
<li><p>该类对应的<strong>java.lang.Class对象</strong>没有在任何地方被引用，<strong>无法在任何地方通过反射访问该类的方法</strong>。</p>
</li>
</ul>
<p>Java 虚拟机<strong>被允许</strong>对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了一些参数进行控制。</p>
<hr>
<h3 id="面试官：-JVM-垃圾回收算法有哪些？（高频）"><a href="#面试官：-JVM-垃圾回收算法有哪些？（高频）" class="headerlink" title="面试官： JVM 垃圾回收算法有哪些？（高频）"></a><strong>面试官</strong>： JVM 垃圾回收算法有哪些？<code>（高频）</code></h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.3节）</p>
<p>我记得一共有四种，分别是标记—清除算法（最早出现）、标记—复制算法（第二代）、标记—整理算法（第三代）、分代回收（最新出现）。</p>
<ul>
<li><p>标记—清除算法（最早出现）</p>
<p>1）如它的名字一样，算法分为 <strong>“标记”和“清除”</strong> 两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收掉所有未被标记的对象。</p>
<p>2）它的主要缺点有两个：第一个是<strong>执行效率不稳定</strong>，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长面降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时，<strong>无法找到足够的连续内存</strong>而不得不<strong>提前触发另一次垃圾收集动作</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e948960ba3d5a1d7e6cd3b.png" alt="JVM之GC算法、垃圾收集算法——标记-清除算法、复制算法、标记-整理算法、分代收集算法- 劈天造陆- 博客园"></p>
</li>
<li><p>标记—复制算法（第二代）</p>
<p>1）为了解决<strong>标记—清除算法</strong>面对大量可回收对象时执行效率低的问题。1969年Fenichel提出了一种称为“半区复制”的垃圾收集算法，<strong>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块</strong>。<strong>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</strong>。</p>
<p>2）这样实现简单，运行高效，不会发生碎片化，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内在缩小为了原来的一半，空问浪费未免太多了一点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e9489f0ba3d5a1d7e6cd3c.png" alt="img"></p>
</li>
<li><p>标记—整理算法（第三代）</p>
<p>1）1974年 Edward Lueders 提出了另外一种有针对性的**“标记-整理”(Mark-Compact)<strong>算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。标记-清除算法与标记-整理算法的本质差异在于</strong>前者是一种非移动式的回收算法，而后者是移动式的**。</p>
<p>2）优点：内存使用效率高，不会发生碎片化。缺点：整体阶段的效率不高。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e948a80ba3d5a1d7e6cd43.png" alt="JVM中GC算法总结| I&#39;m Owen"></p>
</li>
</ul>
<h3 id="面试官：-你能详细聊一下分代回收吗？"><a href="#面试官：-你能详细聊一下分代回收吗？" class="headerlink" title="面试官： 你能详细聊一下分代回收吗？"></a><strong>面试官</strong>： 你能详细聊一下分代回收吗？</h3><p><strong>候选人:</strong></p>
<p>关于分代回收是这样的：</p>
<p>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2</p>
<p>对于新生代，内部又被分为了三个区域。Eden区，From Survivor区，To Survivor区。默认空间占用比例是8:1:1</p>
<p>具体的工作机制：</p>
<p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p>
<p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到From区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p>
<p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和From区中的对象，移动到To区中，这些对象的年龄会加1，清空Eden区和From区。</p>
<p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和To中的对象，移动到From区中，这些对象的年龄会加1，清空Eden区和To区。</p>
<p>5）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong>），那么这个对象就会进入到老年代中。</p>
<blockquote>
<p>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代。</p>
<p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。</p>
</blockquote>
<blockquote>
<p>补充：<strong>那些比例为什么要这么划分呢？</strong></p>
<ol>
<li>大部分对象都是短暂存在的，而少数长期存活的对象则需要更多的空间。通过合理分配空间给新生代和老年代，可以最大化垃圾回收的效率并最小化对应用程序性能的影响。（1:2）</li>
<li>这种比例设计是为了优化新生代内的对象管理和垃圾回收，使系统能够在处理大量短寿命对象的同时，也能有效地管理那些存活时间较长的对象。通过这种方式，可以提高整体的内存使用效率和垃圾回收效率。（8:1:1)</li>
</ol>
</blockquote>
<hr>
<h3 id="面试官：讲一下新生代、老年代、永久代的区别？"><a href="#面试官：讲一下新生代、老年代、永久代的区别？" class="headerlink" title="面试官：讲一下新生代、老年代、永久代的区别？"></a><strong>面试官</strong>：讲一下新生代、老年代、永久代的区别？</h3><p><strong>候选人:</strong></p>
<p><strong>新生代</strong>主要用来存放新生的对象。</p>
<p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。</p>
<p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
<hr>
<h3 id="面试官：说一下-JVM-有哪些垃圾回收器？（高频）"><a href="#面试官：说一下-JVM-有哪些垃圾回收器？（高频）" class="headerlink" title="面试官：说一下 JVM 有哪些垃圾回收器？（高频）"></a><strong>面试官</strong>：说一下 JVM 有哪些垃圾回收器？<code>（高频）</code></h3><p><strong>候选人:</strong></p>
<p>在JVM中，实现了多种垃圾收集器，包括：串行垃圾收集器（Serial）、并行垃圾收集器（Parallel，JDK8默认）、CMS垃圾收集器、G1垃圾收集器（JDK9默认）、ZGC。衡量垃圾收集器的三项最重要的指标是：<strong>内存占用、吞吐量和延迟</strong>，三者共同构成了一个“不可能三角”。一款优秀的收集器通常最多可以同时达成其中的两项。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94b220ba3d5a1d7e6ceec.png" alt="image-20250225100213224"></p>
<table>
<thead>
<tr>
<th align="center">垃圾收集器</th>
<th align="center">分类</th>
<th align="center">作用位置</th>
<th align="center">使用算法</th>
<th align="center">特点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">串行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于单CPU环境下的client模式</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">并行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多CPU环境Server模式下与CMS配合使</td>
</tr>
<tr>
<td align="center">Parallel</td>
<td align="center">并行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">适用于后台运算而不需太多交互的场</td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">串行运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-整理算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">并行运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-整理算法</td>
<td align="center">吞吐量优先</td>
<td align="center">适用于后台运算而不需太多交互的场</td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">并发运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-清除算法</td>
<td align="center">低延迟</td>
<td align="center">适用于互联网或B&#x2F;S业务</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">并发、并行</td>
<td align="center">作用于新生代、老年代</td>
<td align="center">标记-整理算法、复制</td>
<td align="center">吞吐量优先</td>
<td align="center">面向服务端应用</td>
</tr>
<tr>
<td align="center">ZGC</td>
<td align="center">并发、并行</td>
<td align="center">全堆</td>
<td align="center">标记-整理算法</td>
<td align="center">极低延迟、高吞吐量</td>
<td align="center">适用于需要极高吞吐量和低延迟的</td>
</tr>
</tbody></table>
<p>GC发展阶段： <strong>Serial &#x3D;&gt; Parallel（并行）&#x3D;&gt; CMS（并发）&#x3D;&gt; G1 &#x3D;&gt; ZGC</strong></p>
<hr>
<h3 id="面试官：-你能解释一下三色标记、增量更新算法和原始快照（STAB）算法吗？"><a href="#面试官：-你能解释一下三色标记、增量更新算法和原始快照（STAB）算法吗？" class="headerlink" title="面试官： 你能解释一下三色标记、增量更新算法和原始快照（STAB）算法吗？"></a><strong>面试官：</strong> 你能解释一下三色标记、增量更新算法和原始快照（STAB）算法吗？</h3><p><strong>候选人:</strong></p>
<p>三色标记是一种用于垃圾收集过程中对象标记的技术。它将对象分为三种颜色：白色表示尚未被访问的对象，灰色表示部分访问的对象，黑色表示完全访问的对象。通过这种标记方法，垃圾收集器可以从根节点开始逐步标记对象，并最终清除白色对象。</p>
<p>如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器是并发工作的，收集器在对象图上标记颜色，同时用户线程在修改引用关系，这样就会可能出现两种后果：一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。另一种是把<strong>原本存活的对象错误标记为已消亡</strong>，这就是非常致命的后果了。当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本是黑色的对象被误标为白色：</p>
<ul>
<li>赋值器<strong>插入</strong>了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器<strong>删除</strong>了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：<strong>增量更新（Incremental Update）和原始快照（STAB）</strong>。</p>
<p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的<strong>黑色对象为根，重新扫描一次</strong>。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
<p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的<strong>灰色对象为根，重新扫描一次</strong>。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<hr>
<h3 id="面试官：说说-CMS-垃圾回收器？（高频）"><a href="#面试官：说说-CMS-垃圾回收器？（高频）" class="headerlink" title="面试官：说说 CMS 垃圾回收器？（高频）"></a><strong>面试官</strong>：说说 CMS 垃圾回收器？<code>（高频）</code></h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.5.6节）</p>
<p>1）CMS(Concurent Mark sweep)收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。从名字(包含“Mark sweep”)上就可以看出 CMS 收集器是基于<strong>标记-清除</strong>算法。现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括:</p>
<ol>
<li>初始标记(CMS initial mark)</li>
<li>并发标记(CMS concurrent mark)</li>
<li>重新标记(CMS remark)</li>
<li>并发清除(CMS concurrent sweep)</li>
</ol>
<p>2）其中<strong>初始标记、重新标记</strong>这两个步骤仍然需要“Stop The World”（STW，停顿）。<code>初始标记</code>仅仅只是标记一下 <strong>GC Roots</strong> 能直接关联到的对象，速度很快；<code>并发标记</code>阶段就是从 <strong>GC Roots</strong> 的直接关联对象开始<strong>遍历整个对象图</strong>的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而<code>重新标记</code>阶段则是为了修正并发标记期间，<strong>因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段通过写屏障记录在并发标记期间所有<strong>修改对象引用的操作</strong>，CMS基于增量更新来做并发标记；最后是<code>并发清除</code>阶段，清理删除掉标记阶段判断的已经死亡的对象，由于<strong>不需要移动存活对象</strong>，所以这个阶段也是可以与用户线程同时并发的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94b450ba3d5a1d7e6cf14.png" alt="image-20250225100237783"></p>
<p>3）CMS是一款优秀的收集器，它最主要的优点在名字上已经体现出来：<strong>并发收集、低停顿</strong>，一些官方公开文档里面也称之为“并发低停顿收集器”(Concurrent Low Pause Collector)。但至少也有以下三个明显的缺点：</p>
<ol>
<li><strong>CMS 收集器无法处理“浮动垃圾”(Floating Garbage)</strong>。在 CMS 的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</li>
<li><strong>退化问题</strong>：要是CMS 运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”，这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用 SerialOld收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。</li>
<li>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有<strong>大量空间碎片产生</strong>。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 <strong>Full GC</strong> 的情况。</li>
</ol>
<hr>
<h3 id="面试官：说说-G1（Garbage-First）-垃圾回收器？（高频）"><a href="#面试官：说说-G1（Garbage-First）-垃圾回收器？（高频）" class="headerlink" title="面试官：说说 G1（Garbage First） 垃圾回收器？（高频）"></a><strong>面试官</strong>：说说 G1（Garbage First） 垃圾回收器？<code>（高频）</code></h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.5.7节）</p>
<p>1）G1是一款主要<strong>面向服务端应用</strong>的垃圾收集器。JDK9 发布之日，G1宣告取代 Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用的收集器。</p>
<p>2）在 G1 收集器出现之前的所有其他收集器，包括 CMS在内，垃圾收集的目标范围要么是整个新生代(MinorGC)，要么就是整个老年代(Major GC)，再要么就是整个 Java 堆(Full GC)。而 G1 跳出了这个樊笼，它可以<strong>面向堆内存任何部分</strong>来组成回收集(Collection Set，一般简称 CSet)进行回收，衡量标准不再是它属于哪个分代，而是<strong>哪块内存中存放的垃圾数量最多，回收收益最大</strong>，这就是 G1收集器的 <strong>Mixed GC</strong> 模式。</p>
<p>3）作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起 <strong>“停顿预测模型”</strong> 的收集器。</p>
<blockquote>
<p>停顿预测模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时 Java(RTSJ)的中软实时垃圾收集器特征了。</p>
</blockquote>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为G1收集器通过将Java堆分成<strong>多个大小相等的独立区域(Region)</strong>，让 G1 收集器去跟踪各个 Region里面的垃圾堆积的“价值”大小，然后后台维护一个优先级列表，并根据用户设定的最大停顿时间，优先回收最有价值的Region，从而实现可控的停顿时间和高效垃圾回收。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94b4f0ba3d5a1d7e6cf1e.png" alt="image-20250225100259587"></p>
<p>4）G1 收集器的运作过程大致可划分为以下四个步骤：</p>
<ol>
<li><p><strong>初始标记(Initial Marking)</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象,并且修改 <code>TAMS指针</code>的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短。</p>
<blockquote>
<p>G1为每一个 Region 设计了两个名为 <code>TAMS(Top at Mark Start)的指针</code>，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是<strong>存活</strong>的，不纳入回收范围。</p>
</blockquote>
</li>
<li><p><strong>并发标记(Concurrent Marking)</strong>：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序<code>并发</code>执行。当对象图扫描完成以后，还要重新处理<code>SATB记录</code>下的在并发时有引用变动的对象。（这里并不是全堆作为GC Roots扫描，而是使用记忆集用于记录哪些Region可能包含指向其他Region的对象。这样，在并发标记阶段，只需要扫描这些可能包含跨Region引用的Region即可，而不需要扫描整个堆。）</p>
</li>
<li><p><strong>最终标记(Final Marking)</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 <code>SATB 记录</code>。这个阶段通过写屏障记录在并发标记期间所有<strong>修改对象引用的操作</strong>，G1 基于STAB记录来做并发标记。</p>
</li>
<li><p><strong>筛选回收(Live Data Counting and Evacuation)</strong>：负责更新 Region 的统计数据，<strong>对各个Region 的回收价值和成本进行排序</strong>，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部Region 的存活对象制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活<strong>对象的移动</strong>，是必须暂停用户线程，由多条收集器线程<code>并行</code>完成的。</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94b560ba3d5a1d7e6cf1f.png" alt="image-20250225100319480"></p>
<p>从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它<strong>并非纯粹地追求低延迟</strong>，官方给它设定的目标是在延迟可控的情况下获得<strong>尽可能高的吞吐量</strong>。</p>
<p>5）优点：允许用户指定最大停顿时间目标（使用-XX:MaxGCPauseMillis），减少垃圾回收过程中应用程序的暂停时间；支持并发并行；可以预测垃圾收集的停顿时间；G1通过将堆划分为多个大小固定的Region，并且可以灵活地选择哪些Region进行回收，从而提高了内存利用率。</p>
<p>缺点：相对于其他垃圾收集器，G1的设计更加复杂，这使得其理解和调优变得更加困难。为了支持Region划分及相应的管理信息，G1可能会消耗额外的内存资源来存储这些元数据。</p>
<blockquote>
<p>G1 收集器关键细节问题解决：</p>
<p><strong>1）将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决?</strong></p>
<p>解决思路：使用记忆集避免全堆作为 GC Roots 扫描，但在 G1 收集器上记忆集的应用其实要复杂很多，它的每个Region 都维护有自己的记忆集，这些记忆集会记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是种<strong>哈希表</strong>，Key是别的 Region的起始地址，Value是一个集合，里面存储的元素是<strong>卡表的索引号</strong>。这种“双向”的卡表结构**(卡表是“我指向谁”、这种结构还记录了“谁指向我”)**比原来的卡表实现起来更复杂，同时由于 Region数量比传统收集器的分代数量明显要多得多，因此 G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。</p>
<p><strong>2）在并发标记阶段如何保证收集线程与用户线程互不干扰地运行?</strong></p>
<p>解决办法：CMS 收集器采用增量更新算法实现，而 G1收集器则是通过原始快照(SATB)算法来实现的。</p>
</blockquote>
<hr>
<h3 id="面试官：说说-G1-和-CMS-垃圾回收器的区别？-记忆集、卡表、写屏障"><a href="#面试官：说说-G1-和-CMS-垃圾回收器的区别？-记忆集、卡表、写屏障" class="headerlink" title="面试官：说说 G1 和 CMS 垃圾回收器的区别？(记忆集、卡表、写屏障)"></a><strong>面试官</strong>：说说 G1 和 CMS 垃圾回收器的区别？(记忆集、卡表、写屏障)</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.5.7节）</p>
<ol>
<li>相比 CMS，G1的优点有很多，暂且不论<strong>可以指定最大停顿时间</strong>、<strong>分 Region 的内存布局</strong>、<strong>按收益动态确定回收集</strong>这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。<strong>与CMS 的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部(两个 Region 之间)上看又是基于“标记-复制”算法实现</strong>，无论如何，这两种算法都意味着 G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。当然比起CMS，G1的弱项也可以列举出不少，如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比 CMS 要高。</li>
<li>就内存占用来说，虽然 G1 和 CMS 都使用<strong>卡表来处理跨代指针</strong>，但 G1 的卡表实现更为复杂，而且堆中每个 Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致 G1 的记忆集(和其他内存消耗)可能会占更多的内存空间；相比起来 CMS 的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有<strong>朝生夕灭</strong>的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的。</li>
<li>在执行负载的角度上，它们都使用到写屏障。CMS用<strong>写后屏障</strong>来更新维护卡表；而 G1 除了使用<strong>写后屏障</strong>来进行同样的(由于 G1的卡表结构复杂，其实是更烦琐的)卡表维护操作外，为了实现原始快照搜索(SATB)算法，还需要使用<strong>写前屏障</strong>来跟踪并发时的<strong>指针变化</strong>情况。</li>
</ol>
<blockquote>
<p>拓展：记忆集与卡表、写屏障</p>
<p>记忆集：记忆集是一种用于记录从<strong>非收集区域指向收集区域</strong>的指针集合的抽象数据结构。</p>
<p>卡表：卡表就是记忆集的一种具体体现，它定义了记忆集的记录精度、与堆内存的映射关系等。</p>
<p>写屏障：在HotSpot虚拟机里是通过写屏障技术维护卡表状态的。写屏障可以看作是在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形通知。在赋值前的部分的写屏障叫做写前屏障，在赋值后的则叫作写后屏障。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">oop_field_store</span><span class="params">(oop* field, oop new_val)</span> &#123;</span><br><span class="line"> <span class="comment">// 引用字段赋值操作</span></span><br><span class="line"> *field = new_val;</span><br><span class="line"> <span class="comment">// 写后屏障，在这里完成卡表状态更新</span></span><br><span class="line"> post_write_barrier(field, new_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3 id="面试官：说说你对ZGC（Z-Garbage-Collector）-收集器的理解？（可选高频）"><a href="#面试官：说说你对ZGC（Z-Garbage-Collector）-收集器的理解？（可选高频）" class="headerlink" title="面试官：说说你对ZGC（Z Garbage Collector） 收集器的理解？（可选高频）"></a><strong>面试官</strong>：说说你对ZGC（Z Garbage Collector） 收集器的理解？<code>（可选高频）</code></h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.6.2节）</p>
<p>1）ZGC收集器是一款基于 Region 内存布局的，(暂时)不设分代的，使用了<strong>读屏障、染色指针和内存多重映射</strong>等技术来实现可并发的<strong>标记-整理</strong>算法的，以<strong>低延迟</strong>为首要目标的一款垃圾收集器。</p>
<blockquote>
<p>染色指针是一种直接将少量额外的信息存储在指针上的技术，ZGC的染色指针是最直接的、最纯粹的，他直接把标记信息记在引用对象的指针上。</p>
<p>染色指针可以使得一旦某个 Region 的存活对象被移走之后，这个 Region <strong>立即就能够被释放和重用掉</strong>，而不必等待整个堆中所有指向该 Region 的引用都被修正后才能清理。</p>
<p>染色指针可以大幅减少在垃圾收集过程中<strong>内存屏障</strong>的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</p>
<p>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94b5f0ba3d5a1d7e6cf26.png" alt="image-20250225100352416"></p>
<p>2）ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段。<strong>ZGC几乎在所有地方都并发执行的，除了初始标记是STW的。</strong></p>
<ol>
<li><p><strong>并发标记(Concurrent Mark)</strong>：与G1 一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于 G1的初始标记、最终标记(尽管 ZGC 中的名字不叫这些)的短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与 G1不同的是，<strong>ZGC的标记是在指针上而不是在对象上</strong>进行的，标记阶段会<strong>更新染色指针中的标志位</strong>。</p>
</li>
<li><p><strong>并发预备重分配(Concurrent Prepare for Relocate)</strong>：这个阶段需要根据<strong>特定的查询条件</strong>统计得出本次收集过程要清理哪些Region，将这些Region组成<strong>重分配集(Relocation Set)</strong>。（统计需要清理的Region，并组成重分配集）</p>
<blockquote>
<p>重分配集与 G1 收集器的回收集(Collection Set)还是有区别的。ZGC 划分 Region的目的并非为了像 G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的 Region，用范围更大的扫描成本换取省去 G1中记忆集的维护成本。</p>
</blockquote>
</li>
<li><p><strong>并发重分配(Concurrent Relocate)</strong>：重分配是 ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region上，并为重分配集中的每个 Region维护一个转发表(Forward Table)，记录从旧对象到新对象的转向关系。<strong>得益于染色指针的支持，ZGC 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中</strong>，一旦重分配集中某个 Region 的存活对象都复制完毕后，这个 Region就可以立即释放用于新对象的分配(但是转发表还得留着不能释放掉）。（对象复制到新的Region上，并维护一个转发表，复制完毕后，旧Region立即释放）</p>
<blockquote>
<p>假设有两个Region（A 和 B），它们属于重分配集，需要被清理。每个Region包含若干对象，我们需要将存活的对象复制到新的位置，并更新指向这些对象的所有引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定 Region A 和 Region B 为重分配集。</span></span><br><span class="line">Region A: [Obj1, Obj2, Obj3]</span><br><span class="line">Region B: [Obj4, Obj5]</span><br><span class="line"><span class="comment">// 其他对象的引用</span></span><br><span class="line">Obj6 -&gt; Obj1</span><br><span class="line">Obj7 -&gt; Obj4</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obj1 和 Obj2 是存活对象，复制到新的 Region。</span></span><br><span class="line"><span class="comment">// Obj4 是存活对象，复制到新的 Region。</span></span><br><span class="line"><span class="comment">// Obj3 和 Obj5 不再存活，将被丢弃。</span></span><br><span class="line">Region <span class="title function_">A</span> <span class="params">(New)</span>: [Obj1<span class="string">&#x27;, Obj2&#x27;</span>]</span><br><span class="line">Region <span class="title function_">B</span> <span class="params">(New)</span>: [Obj4<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>创建转发表记录旧对象到新对象的映射关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Forward Table:</span><br><span class="line">Obj1 -&gt; Obj1<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Obj2 -&gt; Obj2&#x27;</span></span><br><span class="line">Obj4 -&gt; Obj4<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>旧的 Region A 和 Region B 可以被标记为可用，但转发表暂时保留。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Region <span class="title function_">A</span> <span class="params">(Old)</span>: [Obj1, Obj2, Obj3] （已标记为可用）</span><br><span class="line">Region <span class="title function_">B</span> <span class="params">(Old)</span>: [Obj4, Obj5] （已标记为可用）</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>并发重映射(Concurrent Remap)</strong>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，使它们指向新位置的对象。ZGC很巧妙地把<strong>并发重映射阶段</strong>要做的工作，合并到了下一次垃圾收集循环中的<strong>并发标记阶段</strong>里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。（修正旧对象引用，与并发标记阶段合并，释放转发表）</p>
<blockquote>
<p>更新所有指向旧对象的引用。一旦所有引用被修正，转发表可以被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Obj6 -&gt; Obj1<span class="string">&#x27; （更新前：Obj6 -&gt; Obj1）</span></span><br><span class="line"><span class="string">Obj7 -&gt; Obj4&#x27;</span> （更新前：Obj7 -&gt; Obj4）</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94b690ba3d5a1d7e6cf2d.png" alt="image-20250225100405698"></p>
<p>3）ZGC完全没有使用记忆集（ZGC每次垃圾回收都会扫描整个堆），它甚至连分代都没有，连像 CMS 中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障 <strong>（通过染色指针替代）</strong> ，所以给用户线程带来的运行负担也要小得多。可是，必定要有优有劣才会称作权衡，ZGC的这种选择也限制了 <strong>它能承受的对象分配速率不会太高</strong>。当应用程序频繁地创建和销毁大量短期生存的对象时，ZGC需要频繁地进行对象的复制和引用更新操作。这会导致更高的CPU负载，因为需要不断更新染色指针，并且在重分配阶段进行大量的对象复制操作。虽然ZGC的目标是降低暂停时间，但如果对象分配速率非常高，那么即使是短暂的暂停也会变得频繁，从而影响整体性能。</p>
<blockquote>
<p>拓展：<strong>恐怖的测试结果</strong></p>
<ol>
<li>在ZGC的“弱项”吞吐量方面，以低延迟为首要目标的ZGC已经达到了以高吞吐量为目标的Parallel Scavenge的99%，直接超越了G1。（见图1，源自《深入理解Java虚拟机》第三版 P120）</li>
<li>而在ZGC的“强项”停顿时间测试上，它毫不留情地与Parallel Scavenge、G1拉开了两个数量级的差距。（见图2，源自《深入理解Java虚拟机》第三版 P120）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94b720ba3d5a1d7e6cf32.png" alt="image-20250225100417302"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94c050ba3d5a1d7e6cfa5.png" alt="image-20250225100428378"></p>
</blockquote>
<hr>
<h3 id="面试官：Minor-GC、Major-GC、Mixed-GC、Full-GC是什么？"><a href="#面试官：Minor-GC、Major-GC、Mixed-GC、Full-GC是什么？" class="headerlink" title="面试官：Minor GC、Major GC、Mixed GC、Full GC是什么？"></a><strong>面试官</strong>：Minor GC、Major GC、Mixed GC、Full GC是什么？</h3><p><strong>候选人:</strong>（源自《深入理解Java虚拟机》第三版 3.3.1节）</p>
<ul>
<li>部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集(Minor GC&#x2F;Young GC)：指目标只是新生代的垃圾收集。</li>
<li>老年代收集(Major GC&#x2F;Old GC)：指目标只是老年代的垃圾收集。目前只有<strong>CMS 收集器</strong>会有单独收集老年代的行为。</li>
<li>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集(Full GC)：收集整个 Java 堆和方法区的垃圾收集（尽量避免）。</li>
</ul>
<hr>
<h2 id="4-JVM实践（调优）"><a href="#4-JVM实践（调优）" class="headerlink" title="4 JVM实践（调优）"></a>4 JVM实践（调优）</h2><h3 id="面试官：JVM-调优的参数可以在哪里设置参数值？"><a href="#面试官：JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="面试官：JVM 调优的参数可以在哪里设置参数值？"></a><strong>面试官</strong>：JVM 调优的参数可以在哪里设置参数值？</h3><p><strong>候选人:</strong></p>
<p>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Xms256m -Xmx512m -XX:+UseConcMarkSweepGC your-app.jar</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Xms256m -Xmx512m -XX:+UseG1GC your-app.jar</span><br></pre></td></tr></table></figure>

<p>这里的 <code>-Xms256m</code> 和 <code>-Xmx512m</code> 分别设置了初始堆大小和最大堆大小，<code>-XX:+UseConcMarkSweepGC</code> 设置了使用的垃圾收集器为CMS。<code>-XX:+UseG1GC</code> 设置了使用的垃圾收集器为G1。</p>
<hr>
<h3 id="面试官：用的-JVM-调优的参数都有哪些？"><a href="#面试官：用的-JVM-调优的参数都有哪些？" class="headerlink" title="面试官：用的 JVM 调优的参数都有哪些？"></a><strong>面试官</strong>：用的 JVM 调优的参数都有哪些？</h3><p><strong>候选人:</strong></p>
<p>对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型。</p>
<h4 id="堆内存管理参数"><a href="#堆内存管理参数" class="headerlink" title="堆内存管理参数"></a>堆内存管理参数</h4><ol>
<li><strong>初始堆内存大小 (<code>-Xms&lt;size&gt;</code>)</strong>。示例：<code>-Xms256m</code> 表示初始堆内存为256MB。</li>
<li><strong>最大堆内存大小 (<code>-Xmx&lt;size&gt;</code>)</strong>。示例：<code>-Xmx512m</code> 表示最大堆内存为512MB</li>
</ol>
<blockquote>
<p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError。通常会将 -Xms 和 -Xmx两个参数配置相同的值，其<strong>目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>
</blockquote>
<h4 id="年轻代管理参数"><a href="#年轻代管理参数" class="headerlink" title="年轻代管理参数"></a>年轻代管理参数</h4><ol>
<li><strong>年轻代大小 (<code>-Xmn&lt;size&gt;</code>)</strong>。示例：<code>-Xmn128m</code> 表示年轻代大小为128MB。</li>
<li><strong>Eden区与Survivor区的比例 (<code>-XX:SurvivorRatio=&lt;value&gt;</code>)</strong>。示例：<code>-XX:SurvivorRatio=8</code> 表示Eden区与两个Survivor区的比例为8:1:1。</li>
</ol>
<h4 id="垃圾收集器选择参数"><a href="#垃圾收集器选择参数" class="headerlink" title="垃圾收集器选择参数"></a>垃圾收集器选择参数</h4><ol>
<li><strong>使用串行垃圾收集器 (<code>-XX:+UseSerialGC</code>)</strong></li>
<li><strong>使用并行垃圾收集器 (<code>-XX:+UseParallelGC</code>)</strong></li>
<li><strong>使用CMS垃圾收集器 (<code>-XX:+UseConcMarkSweepGC</code>)</strong></li>
<li><strong>使用G1垃圾收集器 (<code>-XX:+UseG1GC</code>)</strong></li>
</ol>
<h4 id="垃圾收集器优化参数"><a href="#垃圾收集器优化参数" class="headerlink" title="垃圾收集器优化参数"></a>垃圾收集器优化参数</h4><ol>
<li><strong>最大暂停时间 (<code>-XX:MaxGCPauseMillis=&lt;value&gt;</code>)</strong></li>
<li><strong>并行垃圾收集线程数 (<code>-XX:ParallelGCThreads=&lt;value&gt;</code>)</strong></li>
<li><strong>并发标记线程数 (<code>-XX:ConcGCThreads=&lt;value&gt;</code>)</strong></li>
</ol>
<h4 id="日志和调试参数"><a href="#日志和调试参数" class="headerlink" title="日志和调试参数"></a>日志和调试参数</h4><ol>
<li><strong>开启GC日志 (<code>-Xloggc:./path/gc.log</code>)</strong></li>
<li><strong>详细GC信息 (<code>-XX:+PrintGCDetails</code>)</strong></li>
<li><strong>GC时间戳 (<code>-XX:+PrintGCTimeStamps</code>)</strong></li>
<li><strong>在内存溢出时导出堆转储 (<code>-XX:+HeapDumpOnOutOfMemoryError</code>)</strong></li>
<li><strong>堆转储文件路径 (<code>-XX:HeapDumpPath=&lt;path&gt;</code>)</strong></li>
</ol>
<p>以下是一个包含常用参数的示例命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms256m -Xmx512m -Xmn128m -XX:SurvivorRatio=8 -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=4 -XX:ConcGCThreads=2 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -jar your-app.jar</span><br></pre></td></tr></table></figure>

<p>也可以直接在IDEA中设置VM参数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94c1d0ba3d5a1d7e6cfb3.png" alt="image-20250225100447041"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94c260ba3d5a1d7e6cfbc.png" alt="image-20250225100502921"></p>
<hr>
<h3 id="面试官：平时调试-JVM都用了哪些工具呢？"><a href="#面试官：平时调试-JVM都用了哪些工具呢？" class="headerlink" title="面试官：平时调试 JVM都用了哪些工具呢？"></a><strong>面试官</strong>：平时调试 JVM都用了哪些工具呢？</h3><p><strong>候选人:</strong></p>
<p>嗯，我们一般都是使用jdk自带的一些工具，比如：</p>
<ul>
<li><p>jps 输出JVM中运行的<strong>进程状态</strong>信息。</p>
</li>
<li><p>jstack 查看java进程内<strong>线程的堆栈</strong>信息。</p>
</li>
<li><p>jmap 用于生成堆转存快照（<strong>dump文件</strong>）。</p>
</li>
<li><p>jstat 用于JVM统计监测工具。</p>
</li>
<li><p>jinfo 实时查看和修改JVM参数（有时我们可以查看默认JVM参数设置）。</p>
</li>
</ul>
<blockquote>
<p><strong>代码案例：</strong> 首先，我们创建一个简单的Java应用程序，用于演示如何使用这些工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个简单的应用程序启动了一个无限循环的任务，每隔一秒输出一条消息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleApp</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;SimpleApp started.&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                 System.out.println(<span class="string">&quot;Running task...&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">     thread.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先启动程序，然后使用 <code>jps</code> 查看正在运行中的Java进程:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>

<p>输出可能类似于：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16304 </span><br><span class="line">691 Bootstrap</span><br><span class="line">36648 Launcher</span><br><span class="line">36649 SimpleApp</span><br><span class="line">36654 Jps</span><br></pre></td></tr></table></figure>

<p>这里 <code>36649</code> 是进程ID。</p>
<p><code>jstack</code> 用来查看Java进程中各个线程的堆栈信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack &lt;36649&gt; thread_dump.txt</span><br></pre></td></tr></table></figure>

<p>输出可能类似于：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f8d5c000800 nid=0x1b00 waiting on condition [0x00007f8d5c200000]</span></span><br><span class="line">java.lang.Thread.State: WAITING (parking)</span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x0000000725b45508&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:607)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p><code>jmap</code> 用于生成堆转存快照（heap dump），可以用来分析内存使用情况（我们一般直接在参数中配置好了）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dump.bin 36649</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e94c310ba3d5a1d7e6cfc5.png" alt="image-20250225100529395"></p>
<p><code>jstat</code> 用来监控JVM的运行时统计数据，如垃圾收集情况、内存使用情况等。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 36649</span><br></pre></td></tr></table></figure>

<p>输出可能类似于：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C     S1C     S0U     S1U       EC       EU        OC      OU     MC     MU     CCS Count   CCS Time</span><br><span class="line">0.00    0.00    0.00    0.00   3072.00   534.00  104448.00 33920.00   0.00    0.00         16      0.00</span><br></pre></td></tr></table></figure></blockquote>
<p>还有一些可视化工具，像<strong>Jconsole</strong>、<strong>VisualVM</strong>和<strong>JProfiler</strong>等。</p>
<hr>
<h3 id="面试官：假如项目中产生了Java内存泄露（OOM），你说一下你的排查思路？"><a href="#面试官：假如项目中产生了Java内存泄露（OOM），你说一下你的排查思路？" class="headerlink" title="面试官：假如项目中产生了Java内存泄露（OOM），你说一下你的排查思路？"></a><strong>面试官</strong>：假如项目中产生了Java内存泄露（OOM），你说一下你的排查思路？</h3><p><strong>候选人:</strong></p>
<p>详情见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_74199893/article/details/142657909?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_74199893/article/details/142657909?spm=1001.2014.3001.5501</a></p>
<p>结合模拟场景案例进行分析……</p>
<hr>
<h3 id="面试官：你的GC调优经验？"><a href="#面试官：你的GC调优经验？" class="headerlink" title="面试官：你的GC调优经验？"></a><strong>面试官</strong>：你的GC调优经验？</h3><p><strong>候选人:</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=60&vd_source=a53b98ddaa188ae2fbb57c3209ffa2be">B站直达</a>：<strong>尚硅谷JVM精讲与GC调优教程 P60-P72</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_74199893/article/details/142679633?sharetype=blogdetail&sharerId=142679633&sharerefer=PC&sharesource=weixin_74199893&spm=1011.2480.3001.8118">CSDN直达</a>：<strong>大师级GC调优：剖析高并发系统的垃圾回收优化实战</strong></p>
<p>调优案例一：调整堆大小提升服务的吞吐量</p>
<p>调优案例二：逃逸分析之栈上分配、标量替换、锁清除</p>
<p>调优案例二：合理配置堆内存</p>
<p>调优案例三：CPU占用很高的排查方案</p>
<p>调优案例四：G1并发GC线程数对性能的影响</p>
<p>调优案例五：调整垃圾回收器对吞吐量的影响</p>
<p>调优案例六：日均百万订单如何设置JVM参数</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">玦尘</div><div class="post-copyright__author_desc">Aslamu alaykum🥥</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://miahemu.github.io/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://miahemu.github.io/2025/03/30/JVM相关面试题/')">JVM相关面试题</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://miahemu.github.io/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://miahemu.github.io" target="_blank">和睦的拾光物语</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JAVA%E9%9D%A2%E7%BB%8F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JAVA面经<span class="tagsPageCount">12</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/yx/wallhaven-yxlwq7.jpg" data-sites="facebook,twitter,wechat,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/30/%E5%B8%B8%E8%A7%81%E7%9A%84HR%E9%9D%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/01/wallhaven-01qpg4.jpg" onerror="onerror=null;src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常见的HR面问题汇总</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/j3/wallhaven-j3rgqw.jpg" onerror="onerror=null;src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC相关面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/j3/wallhaven-j3rgqw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-30</div><div class="title">JUC相关面试题</div></div></a></div><div><a href="/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JavaSE相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/l8/wallhaven-l8ejkp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-22</div><div class="title">JavaSE相关面试题</div></div></a></div><div><a href="/2025/03/29/Linux%E3%80%81Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux、Git常用命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/rd/wallhaven-rdl9lj.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-29</div><div class="title">Linux、Git常用命令</div></div></a></div><div><a href="/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/qz/wallhaven-qzwme5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-23</div><div class="title">Java集合相关面试题</div></div></a></div><div><a href="/2025/03/23/SSM%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="SSM框架相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/zy/wallhaven-zywwky.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-23</div><div class="title">SSM框架相关面试题</div></div></a></div><div><a href="/2025/03/25/Redis%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Redis相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/xl/wallhaven-xl8p9d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-25</div><div class="title">Redis相关面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">🌙惟信道而且行善，并以真理相劝，以坚忍相勉的人则不然。<br>----时光章[103:3]</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">玦尘</h1><div class="author-info__desc">Aslamu alaykum🥥</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/miahemu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1046498117" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">1.屏幕太大功能显示不全的话，可以手动"ctrl + -"来缩放页面。  2.网页右上角换至深色主题效果更佳✨   3.网页左下角可以播放音乐哦☀️</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM%E7%BB%84%E6%88%90"><span class="toc-number">1.</span> <span class="toc-text">1 JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AJVM%E7%94%B1%E9%82%A3%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">面试官：JVM由那些部分组成，运行流程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%90%97%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">面试官：能简单说一下 JVM 运行时数据区吗？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">面试官：详细介绍一下程序计数器的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.4.</span> <span class="toc-text">面试官：什么是虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">面试官：能不能解释一下本地方法栈？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E8%83%BD%E7%BB%99%E6%88%91%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8DJava%E5%A0%86%E5%90%97"><span class="toc-number">1.6.</span> <span class="toc-text">面试官：你能给我详细的介绍Java堆吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E5%90%AC%E8%BF%87%E6%96%B9%E6%B3%95%E5%8C%BA%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">面试官：你听过方法区吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E8%AF%B4%E4%B8%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">面试官： 说下直接内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">面试官：能说一下堆栈的区别是什么吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">面试官：方法中定义的局部变量是否是线程安全的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">2 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.1.</span> <span class="toc-text">面试官：什么是类加载器，类加载器有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E4%BB%80%E4%B9%88%E6%98%AFTLAB%EF%BC%9F%E4%B8%8EEden%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">面试官： 什么是TLAB？与Eden区的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">面试官：对象创建的过程了解吗？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">面试官：说一下类装载的执行过程？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">面试官：什么是双亲委派模型？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AJVM%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">面试官：JVM为什么采用双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E6%80%8E%E6%A0%B7%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">面试官：怎样破坏双亲委派机制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">3 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">前提知识：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">并行与并发：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">内存溢出与内存泄漏：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%AE%80%E8%BF%B0Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%EF%BC%88GC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81GC%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">面试官：简述Java垃圾回收机制？（GC是什么？为什么要GC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">面试官：强引用、软引用、弱引用、虚引用的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">面试官：如何判断对象是否存活？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9C%9F%E6%AD%A3%E6%AD%BB%E4%BA%A1%EF%BC%9Ffnalize-%E4%B8%8ESystem-gc"><span class="toc-number">3.5.</span> <span class="toc-text">面试官：如何判断对象是否真正死亡？fnalize()与System.gc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%EF%BC%88%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E2%BC%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E2%BC%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E2%BD%86%E2%BD%A4%E7%9A%84%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">面试官： （回收方法区）如何判断⼀个常量是废弃常量?如何判断⼀个类是⽆⽤的类?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">面试官： JVM 垃圾回收算法有哪些？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E4%BD%A0%E8%83%BD%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8B%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">面试官： 你能详细聊一下分代回收吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">面试官：讲一下新生代、老年代、永久代的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.10.</span> <span class="toc-text">面试官：说一下 JVM 有哪些垃圾回收器？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E3%80%81%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%E7%AE%97%E6%B3%95%E5%92%8C%E5%8E%9F%E5%A7%8B%E5%BF%AB%E7%85%A7%EF%BC%88STAB%EF%BC%89%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">面试官： 你能解释一下三色标记、增量更新算法和原始快照（STAB）算法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.12.</span> <span class="toc-text">面试官：说说 CMS 垃圾回收器？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4-G1%EF%BC%88Garbage-First%EF%BC%89-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.13.</span> <span class="toc-text">面试官：说说 G1（Garbage First） 垃圾回收器？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4-G1-%E5%92%8C-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E8%AE%B0%E5%BF%86%E9%9B%86%E3%80%81%E5%8D%A1%E8%A1%A8%E3%80%81%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">3.14.</span> <span class="toc-text">面试官：说说 G1 和 CMS 垃圾回收器的区别？(记忆集、卡表、写屏障)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9ZGC%EF%BC%88Z-Garbage-Collector%EF%BC%89-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E5%8F%AF%E9%80%89%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.15.</span> <span class="toc-text">面试官：说说你对ZGC（Z Garbage Collector） 收集器的理解？（可选高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AMinor-GC%E3%80%81Major-GC%E3%80%81Mixed-GC%E3%80%81Full-GC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.16.</span> <span class="toc-text">面试官：Minor GC、Major GC、Mixed GC、Full GC是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JVM%E5%AE%9E%E8%B7%B5%EF%BC%88%E8%B0%83%E4%BC%98%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4 JVM实践（调优）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AJVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E5%80%BC%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">面试官：JVM 调优的参数可以在哪里设置参数值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%94%A8%E7%9A%84-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">面试官：用的 JVM 调优的参数都有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">堆内存管理参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E7%AE%A1%E7%90%86%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">年轻代管理参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%89%E6%8B%A9%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">垃圾收集器选择参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.4.</span> <span class="toc-text">垃圾收集器优化参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%92%8C%E8%B0%83%E8%AF%95%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.5.</span> <span class="toc-text">日志和调试参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%B9%B3%E6%97%B6%E8%B0%83%E8%AF%95-JVM%E9%83%BD%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7%E5%91%A2%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">面试官：平时调试 JVM都用了哪些工具呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%81%87%E5%A6%82%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BA%A7%E7%94%9F%E4%BA%86Java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%88OOM%EF%BC%89%EF%BC%8C%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">面试官：假如项目中产生了Java内存泄露（OOM），你说一下你的排查思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E7%9A%84GC%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">面试官：你的GC调优经验？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/05/2024%E6%90%BA%E7%A8%8B%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024携程春季笔试真题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/yx/wallhaven-yxlwq7.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="2024携程春季笔试真题"/></a><div class="content"><a class="title" href="/2025/04/05/2024%E6%90%BA%E7%A8%8B%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024携程春季笔试真题">2024携程春季笔试真题</a><time datetime="2025-04-04T16:00:00.000Z" title="发表于 2025-04-05 00:00:00">2025-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/04/2024oppo%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024oppo春季笔试真题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/pk/wallhaven-pk7q3p.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="2024oppo春季笔试真题"/></a><div class="content"><a class="title" href="/2025/04/04/2024oppo%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024oppo春季笔试真题">2024oppo春季笔试真题</a><time datetime="2025-04-03T16:00:00.000Z" title="发表于 2025-04-04 00:00:00">2025-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/04/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="消息中间件相关面试题（MQ、Kafka）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/6o/wallhaven-6o7qpx.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="消息中间件相关面试题（MQ、Kafka）"/></a><div class="content"><a class="title" href="/2025/04/04/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="消息中间件相关面试题（MQ、Kafka）">消息中间件相关面试题（MQ、Kafka）</a><time datetime="2025-04-03T16:00:00.000Z" title="发表于 2025-04-04 00:00:00">2025-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/2024vivo%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024vivo春季笔试真题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/p9/wallhaven-p9r8qe.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="2024vivo春季笔试真题"/></a><div class="content"><a class="title" href="/2025/04/03/2024vivo%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024vivo春季笔试真题">2024vivo春季笔试真题</a><time datetime="2025-04-02T16:00:00.000Z" title="发表于 2025-04-03 00:00:00">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/02/2024%E4%BA%AC%E4%B8%9C%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024京东春季笔试真题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/m3/wallhaven-m38dxk.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="2024京东春季笔试真题"/></a><div class="content"><a class="title" href="/2025/04/02/2024%E4%BA%AC%E4%B8%9C%E6%98%A5%E5%AD%A3%E7%AC%94%E8%AF%95/" title="2024京东春季笔试真题">2024京东春季笔试真题</a><time datetime="2025-04-01T16:00:00.000Z" title="发表于 2025-04-02 00:00:00">2025-04-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://mail.qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" size="50px"/><a class="deal_link" href="https://miahemu.github.io" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="玦尘" target="_blank">玦尘</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["心怀信仰&#44; 步步生光&#44; 主恩常在&#44; 万物蒙福."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="https://miahemu.github.io" title="Allah will bless you☘️">Allah will bless you☘️</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/miahemu" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="力扣"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="力扣"/><span class="back-menu-item-text">力扣</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" href="https://miahemu.github.io/about/" title="个人简介"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人简介"/><span class="back-menu-item-text">个人简介</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9460279562&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 小挂件</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/weather/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 天气</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">JAVA面经<sup>12</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">数据结构与算法<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AF%95/" style="font-size: 0.88rem;">笔试<sup>8</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="9461259355" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("2025/3/22 07:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 玦尘 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("2025/3/22 07:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><div class="aplayer no-destroy" data-id="565851830" data-server="netease" data-type="song" data-mini="true" data-autoplay="true" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>