<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JUC相关面试题 | 和睦的拾光物语</title><meta name="keywords" content="JAVA面经"><meta name="author" content="miahemu"><meta name="copyright" content="miahemu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JUC相关面试题"><meta name="application-name" content="JUC相关面试题"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="JUC相关面试题"><meta property="og:url" content="http://example.com/2025/03/30/JUC相关面试题/index.html"><meta property="og:site_name" content="和睦的拾光物语"><meta property="og:description" content="基于技术书籍对Java面试过程中所遇到的重点问题进行深度解读，整合了来自JavaGuide等著名博主的面经分享，并回归课本进行了重写与补充。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://w.wallhaven.cc/full/j3/wallhaven-j3rgqw.jpg"><meta property="article:author" content="miahemu"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/j3/wallhaven-j3rgqw.jpg"><meta name="description" content="基于技术书籍对Java面试过程中所遇到的重点问题进行深度解读，整合了来自JavaGuide等著名博主的面经分享，并回归课本进行了重写与补充。"><link rel="shortcut icon" href="https://pic1.imgdb.cn/item/67dfd64f88c538a9b5c51349.png"><link rel="canonical" href="http://example.com/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"此去经年，别忘了归途","backTitle":"还知道回来？"},
  LA51: {"enable":true,"ck":"3LdBYNynGFmvRJ0D","LingQueMonitorID":null},
  greetingBox: {"enable":true,"default":"晚上好👋 愿你拥有美好的时光！","list":[{"greeting":"夜深了，早点休息，晚安😴","startTime":0,"endTime":5},{"greeting":"早上好☀️ 愿你的一天从愉快开始！","startTime":6,"endTime":9},{"greeting":"上午好👋 状态满满，加油迎接新的一天！","startTime":10,"endTime":10},{"greeting":"11点多啦，午餐时间快到了，继续加油！","startTime":11,"endTime":11},{"greeting":"午安！🌿 休息一下，享受美好的午后时光。","startTime":12,"endTime":14},{"greeting":"下午好！☕ 工作辛苦了，别忘了适当放松一下~","startTime":14,"endTime":18},{"greeting":"晚餐时间到啦！🍽️ 奖励自己一顿美食吧！","startTime":19,"endTime":19},{"greeting":"晚上好👋 愿你在属于自己的时间里放松身心~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":2},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🚀 数码科技探索者","🌿 乐于分享，热心助人","🏡 智能家居智造者","🛠 全栈式设计与开发","🎯 专注交互体验优化","🏃 执行力满分的实干家","⚙️ 团队协作的驱动力","💪 低调务实的实力派"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: miahemu","link":"链接: ","source":"来源: 和睦的拾光物语","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '和睦的拾光物语',
  title: 'JUC相关面试题',
  postAI: '',
  pageFillDescription: '1 线程的基础知识, 面试官：聊一下并行和并发有什么区别？（高频）, 面试官：说一下线程和进程的区别？, 面试官：什么是线程上下⽂切换?（高频）, 面试官：如何减少上下⽂切换?, 面试官： 同步和异步的区别？（高频）, 面试官：如果在java中创建线程有哪些方式？（高频）, 面试官：好的刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？, 面试官：线程的生命周期和状态？（高频）, 面试官：说说sleep()⽅法和wait()⽅法区别和共同点?, 面试官：好的我现在举一个场景你来分析一下怎么做新建 T1、T2、T3 三个线程如何保证它们按顺序执行？, 面试官：在我们使用线程的过程中有两个方法。线程的 run()和 start()有什么区别？, 面试官：那如何停止一个正在运行的线程呢？, 2 线程中并发锁, 面试官：说一下公平锁与非公平锁的区别？, 面试官：说一下悲观锁与乐观锁的区别？（高频）, 面试官：讲一下synchronized关键字的底层原理？（高频）, 面试官：你能具体说下Monitor 吗？（高频）, 面试官：说说⾃⼰是怎么使⽤ synchronized 关键字的？, 面试官：单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！, 面试官：关于synchronized 的锁升级的情况了解吗？, 面试官：好的刚才你说了synchronized它在高并发量的情况下性能不高在项目该如何控制使用锁呢？, 面试官：说下ReentrantLock的使用方式和底层原理？, 面试官：刚才你说了CAS和AQS你能介绍一下吗？, 面试官：AQS对资源的共享方式（Semaphore、CountDownLatch、CyclicBarrier）, 面试官：CyclicBarrier和CountDownLatch的区别, 面试官：synchronized和Lock有什么区别 ?, 面试官：说说Synchronized和ReentrantLock的区别（高频）, 面试官：请谈谈你对 volatile 的理解, 3 线程池, 面试官： 为什么要⽤线程池？, 面试官：线程池四种创建方式, 面试官：ThreadPoolExecutor的核心参数有哪些？（高频）, 面试官：线程池的执行原理知道吗？, 面试官：为什么不建议使用Executors创建线程池呢？, 面试官： 执⾏execute()⽅法和submit()⽅法的区别是什么呢？, 面试官：Java 里的阻塞队列都有哪些？能简单说说吗？, 4 线程使用场景问题, 面试官：如果控制某一个方法允许并发访问线程的数量？, 面试官：好的那该如何保证Java程序在多线程的情况下执行安全呢？, 5 其他, 面试官：介绍下Forkx2FJoin框架（工作窃取算法）, 面试官：讲一下JMM(Java内存模型), 面试官：JMM 可能会导致数据不一致？怎么理解？, 面试官：聊聊happens-before与JMM的关系？, 面试官：你知道happens-before有哪些应用场景吗？, 面试官：谈谈你对ThreadLocal的理解, 面试官：好的那你知道ThreadLocal的底层原理实现吗？, 面试官：好的那关于ThreadLocal会导致内存溢出这个事情了解吗？, 面试官：跨线程传递ThreadLocal的问题本文为原创内容转载请注明出处并附带原文链接感谢您的尊重与支持你必须非常努力才能看起来毫不费劲线程的基础知识面试官聊一下并行和并发有什么区别高频候选人并发是指在同一时间段内系统有能力处理多个事件多个线程轮流使用一个或多个换句话说并发并不一定要求任务同时进行而是通过快速切换任务来实现看起来同时运行的效果并行是指在同一时刻多个任务可以在多个处理器核心上同时执行核同时执行个线程宏观并行微观并发面试官说一下线程和进程的区别候选人进程是正在运行程序的实例进程中包含了线程每个线程执行不同的任务不同的进程使用不同的内存空间在当前进程下的所有线程可以共享进程的堆和法区资源但每个线程有的程序计数器虚拟机栈和本地法栈线程更轻量线程上下文切换成本一般上要比进程上下文切换低上下文切换指的是从一个线程切换到另一个线程下来思考这样个问题为什么程序计数器虚拟机栈和本地法栈是线程私有的呢在多线程的情况下程序计数器于记录当前线程执的位置从当线程被切换回来的时候能够知道该线程上次运到哪了如果执的是法那么程序计数器记录的是地址只有执的是代码时程序计数器记录的才是下条指令的地址所以程序计数器私有主要是为了线程切换后能恢复到正确的执位置虚拟机栈为虚拟机执法也就是字节码服务本地法栈则为虚拟机使到的法服务所以为了保证线程中的局部变量不被别的线程访问到虚拟机栈和本地法栈是线程私有的面试官什么是线程上下切换高频候选人源自并发编程艺术节通过时间片分配算法来循环执行任务当前任务执行一个时间后片后会切换到下一个任务但是在切换前会保存上一个任务的状态以便下次切换回这个任务时可以再加载这个任务的状态所以任务从保存到再加载的过程就是次上下切换这就像我们同时读两本书当我们在读一本英文的技术书时发现某个单词不认识于是便打开中英文字典但是在放下英文技术书之前大脑必须先记住这本书读到了多少页的第多少行等查完单词之后能够继续读这本书这样的切换是会影响读书效率的同样上下文切换也会影响多线程的执行速度面试官如何减少上下切换候选人源自并发编程艺术节减少上下文切换的方法有无锁并发编程算法使用最少线程和使用协程无锁并发编程多线程竞争锁时会引起上下文切换所以多线程处理数据时可以用一些办法来避免使用锁如将数据的按照算法取模分段不同的线程处理不同段的数据算法的包使用算法来更新数据而不需要加锁使用最少线程避免创建不需要的线程比如任务很少但是创建了很多线程来处理这样会造成大量线程都处于等待状态协程在单线程里实现多任务的调度并在单线程里维持多个任务间的切换面试官同步和异步的区别高频候选人首先说一下什么是同步同步指的是任务按照顺序依次执行的方式在这种模式下调用者会阻塞等待任务完成并返回结果后才会继续执行后续的操作然后再说一下什么是异步异步指的是任务无需等待立即返回调用方可以继续执行其他操作而任务的结果会在稍后通过如回调函数事件通知或对象等机制传递给调用方最后说一下同步和异步的区别第一是执行方式不同同步是阻塞式的调用方需要等待任务完成才能继续而异步是非阻塞式的调用方无需等待任务完成即可继续执行第二是响应机制不同同步直接返回任务的结果调用方可以直接使用而异步通常通过回调函数事件通知或对象等方式传递结果第三是适用场景不同同步适合简单短时间的任务或者需要立即获取结果的场景而异步适合需要提高系统吞吐量的场景或者用于耗时较长的任务如网络请求文件读写等面试官如果在中创建线程有哪些方式高频候选人在中一共有四种常见的创建方式分别是继承类实现接口实现接口线程池创建线程通常情况下我们项目中都会采用线程池的方式创建线程面试官好的刚才你说的和两个接口创建线程有什么不同呢候选人接口方法无返回值接口方法有返回值是个泛型和配合可以用来获取异步执行的结果还有一个就是他们异常处理也不一样接口方法只能抛出运行时异常也无法捕获处理接口方法允许抛出异常可以获取异常信息在实际开发中如果需要拿到执行的结果需要使用接口创建线程调用得到可以得到返回值此方法会阻塞主进程的继续往下执行如果不调用不会阻塞面试官线程的生命周期和状态高频候选人在中的类中的枚举里面定义了中线程的状态分别是初始运行终止阻塞等待和超时等待六种图源并发编程艺术节当一个线程对象被创建但还未调用方法时处于初始状态调用了方法就会由初始进入运行状态如果线程内代码已经执行完毕由运行进入终止状态当然这些是一个线程正常执行情况如果线程获取锁失败后由运行进入的阻塞队列阻塞只有当持锁线程释放锁时会按照一定规则唤醒阻塞队列中的阻塞线程唤醒后的线程进入运行状态如果线程获取锁成功后但由于条件不满足调用了方法此时从运行状态释放锁等待状态当其它持锁线程调用或方法会恢复为运行状态还有一种情况是调用方法也会从运行状态进入超时等待状态不需要主动唤醒超时时间到自然恢复为运行状态图源并发编程艺术节面试官说说法和法区别和共同点候选人它们两个的相同点是都可以让当前线程暂时放弃的使用权进入阻塞状态不同点主要有三个方面第一方法归属不同是的静态方法而是的成员方法每个对象都有第二线程醒来时机不同线程执行会在等待相应毫秒后醒来而需要被唤醒如果不唤醒就一直等下去第三锁特性不同程序员面试笔试宝典第二版节由于方法的主要作用是让线程休眠指定的一段时间在时间到时自动恢复不涉及线程间的通信因此调用方法并不会释放锁相当于我放弃你们也用不了而方法则不同当调用方法后线程会释放掉它所占用的锁从而使线程所在对象中的其他数据可被别的线程使用相当于我放弃但你们还可以用程序员面试笔试宝典第二版节引申方法与方法的区别是什么方法与方法的区别主要表现在以下几个方面方法给其他线程运行机会时不考虑线程的优先级因此会给低优先级的线程以运行的机会而方法只会给相同优先级或更高优先级的线程以运行的机会线程执行方法后会转入超时等待状态所以执行方法的线程在指定的时间内肯定不会被执行而方法只是使当前线程重新回到可执行状态所以执行方法的线程有可能在进入到可执行状态后马上又被执行方法声明抛出而方法没有声明任何异常方法比方法跟操作系统相关具有更好的可移植性面试官好的我现在举一个场景你来分析一下怎么做新建三个线程如何保证它们按顺序执行候选人这道题不难部分都是或者实现话不多说上代码创建三个线程完成后释放等待完成模拟工作完成后释放等待完成模拟工作启动所有线程创建三个线程模拟工作模拟工作启动并等待其完成完成后启动并等待其完成完成后启动并等待其完成面试官在我们使用线程的过程中有两个方法线程的和有什么区别候选人方法用来启动线程通过该线程调用方法执行方法中所定义的逻辑代码方法只能被调用一次方法封装了要被线程执行的代码可以被调用多次总结调法可启动线程并使线程进就绪状态直接执法的话不会以多线程的式执面试官那如何停止一个正在运行的线程呢候选人有三种方式可以停止线程第一可以使用退出标志使线程正常退出也就是当方法完成后线程终止一般我们加一个标记第二可以使用线程的和方法强行终止不过一般不推荐这个方法已作废第三可以使用线程的方法中断线程内部其实也是使用中断标志来中断线程我们项目中使用的话建议使用第一种或第三种方式中断线程并发编程的艺术节不建议使用和方法的原因主要有以方法为例在调用后线程不会释放已经占有的资源比如锁而是占有着资源进入睡眠状态这样容易引发死锁问题同样方法在终结一个线程时不会保证线程的资源正常释放通常是没有给予线程完成资源释放工作的机会因此会导致程序可能工作在不确定状态下线程中并发锁面试官说一下公平锁与非公平锁的区别候选人公平锁按照线程在队列中的排队顺序先到者先拿到锁非公平锁当线程要获取锁时无视队列顺序直接去抢锁谁抢到就是谁的并发编程的艺术节这里提到一个锁获取的公平性问题如果在绝对时间上先对锁进行获取的请求一定先被满足那么这个锁是公平的反之是不公平的公平的获取锁也就是等待时间最长的线程最优先获取锁也可以说锁获取是顺序的事实上公平的锁机制往往没有非公平的效率高但是并不是任何场景都是以作为唯一的指标公平锁能够减少饥饿发生的概率等待越久的请求越是能够得到优先满足在测试中公平性锁与非公平性锁相比总耗时是其倍总切换次数是其倍可以看出公平性锁保证了锁的获取按照原则而代价是进行大量的线程切换非公平性锁虽然可能造成线程饥饿但极少的线程切换保证了其更大的吞吐量面试官说一下悲观锁与乐观锁的区别高频候选人悲观锁和乐观锁是数据库管理系统中用于处理并发事务的不同方式悲观锁假设数据会被并发修改所以访问数据时会加锁其他线程必须等待锁释放适用于高并发写操作较多的场景以确保数据的一致性数据库级别的悲观锁常用于会在查询行上加排他锁阻止其他事务修改代码实现基于或加锁执行业务逻辑释放锁乐观锁假设数据不会被冲突修改先尝试更新如果发现冲突版本号不匹配则重试或失败适用于读多写少的场景比如商品库存扣减用户账户余额更新等乐观锁通常通过版本号或时间戳来检测数据是否已被修改数据库级别的乐观锁基于版本号代码实现使用或机制业务逻辑更新失败版本号冲突重试递归重试采用操作确保版本号未被其他线程修改否则失败并重试简单来说悲观锁适合于数据冲突频繁的场景它通过加锁来防止冲突而乐观锁更适合于读多写少的场景通过在提交时检查冲突来减少锁的竞争面试官讲一下关键字的底层原理高频候选人关键字解决的是多个线程之间访问资源的同步性关键字可以保证被它修饰的法或者代码块在任意时刻只能有个线程执底层使用的级别中的监视器锁来决定当前线程是否获得了锁如果某一个线程获得了锁在没有释放锁之前其他线程是不能或得到锁的属于悲观锁在早期版本中属于重量级锁效率低下并发编程的艺术节从规范中可以看到在里的实现原理基于进入和退出对象来实现方法同步和代码块同步但两者的实现细节不一样代码块同步是使用和指令实现的指令是在编译后插入到同步代码块的开始位置而是插入到方法结束处和异常处要保证每个必须有对应的与之配对方法同步是使用另外一种方式实现的通过该访问标志来辨别个法是否声明为同步法从执相应的同步调不过两者的本质都是对对象监视器的获取面试官你能具体说下吗高频候选人对象存在于每个对象的对象头中锁便是通过这种方式获取锁的也是为什么中任意对象可以作为锁的原因内部维护了三个变量保存处于状态的线程保存处于状态的线程持有锁的线程只有一个线程获取到的标志就是在中设置成功了一个中只能有一个在上锁的过程中如果有其他线程也来抢锁则进入进行阻塞当获得锁的线程执行完了释放了锁就会唤醒中等待的线程竞争锁竞争的时候是非公平的面试官说说是怎么使关键字的候选人修饰实例法作于当前对象实例加锁进同步代码前要获得当前对象实例的锁业务代码修饰静态法也就是给当前类加锁会作于类的所有对象实例进同步代码前要获得当前的锁因为静态成员不属于任何个实例对象是类成员表明这是该类的个静态资源不管了多少个对象只有份所以如果个线程调个实例对象的静态法线程需要调这个实例对象所属类的静态法是允许的不会发互斥现象因为访问静态法占的锁是当前类的锁访问静态法占的锁是当前实例对象锁业务代码修饰代码块指定加锁对象对给定对象类加锁表示进同步代码库前要获得给定对象的锁表示进同步代码前要获得当前的锁业务代码总结关键字加到静态法和代码块上都是是给类上锁关键字加到实例法上是给对象实例上锁尽量不要使因为中字符串常量池具有缓存功能面试官单例模式了解吗来给我写下给我解释下双重检验锁式实现单例模式的原理呗候选人双重校验锁实现对象单例线程安全这个必须要会先判断对象是否已经实例过没有实例化过才进加锁代码类对象加锁另外采关键字修饰也是很有必要的这段代码其实是分为三步执为分配内存空间初始化将指向分配的内存地址如果没有由于具有重排序的特性执顺序有可能变成指令重排在单线程环境下不会出现问题但是在多线程环境下会导致个线程获得还没有初始化的实例例如线程执了和此时调后发现不为空因此返回但此时还未被初始化所以这是一种错误的用法但是如果使就可以禁的指令重排实现线程安全的延迟初始化保证在多线程环境下也能正常运面试官关于的锁升级的情况了解吗候选人中的有偏向锁轻量级锁重量级锁三种形式分别对应了锁只被一个线程持有不同线程交替持有锁多线程竞争锁三种情况重量级锁底层使用的实现里面涉及到了用户态和内核态的切换进程的上下文切换成本较高性能比较低轻量级锁线程加锁的时间是错开的也就是没有竞争可以使用轻量级锁来优化轻量级锁修改对象头的锁标志相对重量级锁性能提升很多每次修改都是操作保证原子性偏向锁一段很长的时间内都只被一个线程使用锁可以使用了偏向锁在第一次获得锁时会有一个操作之后该线程再获取锁只需要判断中是否是自己的线程即可而不是开销相对较大的命令图源并发编程的艺术节并发编程的艺术节在中锁一共有种状态级别从低到高依次是无锁状态偏向锁状态轻量级锁状态和重量级锁状态这几个状态会随着竞争情况逐渐升级锁可以升级但不能降级意味着偏向锁升级成轻量级锁后不能降级成偏向锁这种锁升级却不能降级的策略目的是为了提高获得锁和释放锁的效率面试官好的刚才你说了它在高并发量的情况下性能不高在项目该如何控制使用锁呢候选人在高并发下我们可以采用来加锁面试官说下的使用方式和底层原理候选人是一个可重入锁调用方法获取了锁之后再次调用是不会再阻塞内部直接增加重入次数标识这个线程已经重复获取一把锁而不需要等待锁的释放是属于包是平台提供的一个用于支持高并发程序设计的工具包下的类属于层面的锁跟一样都是悲观锁通过用来获取锁释放锁它的底层实现原理主要利用队列来实现它支持公平锁和非公平锁构造方法接受一个可选的公平参数默认非公平锁当设置为时表示公平锁否则为非公平锁面试官刚才你说了和你能介绍一下吗候选人的全称是比较再交换它体现的一种乐观锁的思想在无锁状态下保证线程操作数据的原子性并发编程的艺术节对操作的解释操作需要输入两个数值一个旧值期望操作前的值和一个新值在操作期间先比较旧值有没有发生变化如果没有发生变化才交换成新值发生了变化则不交换使用到的地方很多框架类在操作共享变量的时候使用的自旋锁效率上更高一些的底层是调用的类中的方法都是操作系统提供的其他语言实现的全称是是阻塞式锁和相关的同步器工具的框架使能简单且效地构造出应泛的量的同步器如其他的诸如等等皆是基于的当然我们也能利常轻松容易地构造出符合我们需求的同步器内部有一个属性属性来表示资源的状态默认等于表示没有获取锁等于的时候才标明获取到了锁通过机制设置状态在它的内部还提供了基于的等待队列队列是一个双向列表其中指向队列最后一个元素指向队列中最久的一个元素面试官对资源的共享方式候选人独占只有个线程能执如可分为公平锁和公平锁共享多个线程可同时执如倒计时器信号量回环栅栏可以看成是组合式因为也就是读写锁允许多个线程同时对某资源进读不同的定义同步器争共享资源的式也不同定义同步器在实现时只需要实现共享资源的获取与释放式即可于具体线程等待队列的维护如获取资源失败队唤醒出队等已经在顶层实现好了并发编程的艺术节信号量是用来控制同时访问特定资源的线程数量大白话可以指定多个线程同时访问某个资源它通过协调各线程以保证合理的使用公共资源可以用于做流量控制特别是公用资源有限的应用场景比如数据库连接的用法也很简单首先线程使用的方法获取一个许可证使用完之后调用方法归还许可证还可以用方法尝试获取许可证倒计时器允许一个或多个线程等待其他线程完成操作大白话它可以让某一个线程等待直到倒计时结束再开始执行的构造函数接收一个类型的参数作为计数器如果你想等待个点完成这里就传入当我们调用的方法时就会减的方法会阻塞当前线程直到变成零的字意思是可循环使的屏障它要做的事情是让组线程到达个屏障也可以叫同步点时被阻塞直到最后个线程到达屏障时屏障才会开所有被屏障拦截的线程才会继续运行默认的构造法是其参数表示屏障拦截的线程数量每个线程调法告诉我已经到达了屏障然后当前线程被阻塞的用法的用法因为主线程和子线程的调度是由决定的两个线程都有可能先执行所以会出现两种输出第一种第二种如果把修改成则主线程和子线程会永远等待因为没有第三个线程执行方法即没有第三个线程到达屏障所以之前到达屏障的两个线程都不会继续执行面试官和的区别候选人源自并发编程的艺术节的计数器只能使用一次而的计数器可以使用方法重置所以能处理更为复杂的业务场景例如如果计算发生错误可以重置计数器并让线程重新执行一次还提供其他有用的方法比如方法可以获得阻塞的线程数量方法用来了解阻塞的线程是否被中断面试官和有什么区别候选人第一语法层面是关键字源码在中用语言实现退出同步代码块锁会自动释放是接口源码由提供用语言实现需要手动调用方法释放锁第二功能层面二者均属于悲观锁都具备基本的互斥同步锁重入功能提供了许多不具备的功能例如获取等待状态公平锁可打断可超时多条件变量同时可以实现不同的场景如第三性能层面在没有竞争时做了很多优化如偏向锁轻量级锁性能不赖在竞争激烈时的实现通常会提供更好的性能统合来看需要根据不同的场景来选择不同的锁的使用面试官说说和的区别高频候选人可以用来修饰普通方法静态方法和代码块只能用在代码块上会自动加锁和释放锁需手动加锁和释放锁属于非公平锁既可以是公平锁也可以是非公平锁是通过实现的是通过队列实现的面试官请谈谈你对的理解候选人是一个关键字可以修饰类的成员变量类的静态成员变量主要有两个功能第一保证了不同线程对这个变量进行操作时的可见性即一个线程修改了某个变量的值这新值对其他线程来说是立即可见的关键字会强制将修改的值立即写入主存第二禁止进行指令重排序可以保证代码执行有序性底层实现原理是添加了一个内存屏障通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化并发编程的艺术节重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段线程池面试官为什么要线程池候选人源自并发编程的艺术节在开发过程中合理地使用线程池能够带来个好处降低资源消耗通过重复利已创建的线程降低线程创建和销毁造成的消耗提响应速度当任务到达时任务可以不需要的等到线程创建就能即执提线程的可管理性线程是稀缺资源如果限制的创建不仅会消耗系统资源还会降低系统的稳定性使线程池可以进统的分配调优和监控面试官线程池四种创建方式候选人在中默认提供了种方式创建线程池第一个是创建可以缓存的线程池有任务提交到线程池时如果有空闲的线程可用则立即使用空闲线程执行任务如果没有空闲的线程可用就会创建一个新的线程执行任务当空闲线程闲置一段时间默认是秒之后还未被使用那么就会进行销毁操作创建可缓存的线程池提交任务给线程池学生正在报名兴趣小组模拟报名过程的时间消耗学生报名成功关闭线程池输出结果第二个是创建一个定长线程池该线程池中的线程数量始终不变当有个新的任务提交时线程池中若有空闲线程则即执若没有则新的任务会被暂存在个任务队列中待有线程空闲时便处理在任务队列中的任务创建一个固定大小的线程池大小为提交个任务给线程池所有任务执行完毕关闭线程池执行中暂停执行完毕输出结果第三个是创建一个定长线程池支持定时及周期性任务执行创建具有固定核心线程数的线程池延迟任务延迟秒后仅执行一次延迟任务开始执行周期性任务每隔秒执行一次周期性任务开始执行等待一段时间后关闭线程池主线程执行完毕输出结果第四个是创建一个单线程的线程池它只会使用一个线程执行任务可以保证任务的执行顺序开始执行创建单线程的线程池提交任务给线程池执行中执行完毕关闭线程池主线程执行完毕等待线程池任务执行输出结果面试官的核心参数有哪些高频候选人类中提供的四个构造法我们来看最的那个其余三个都是在这个构造法的基础上产其他个构造法说点都是给定某些默认参数的构造法如默认制定拒绝策略是什么给定的初始参数创建个新的在线程池中一共有个核心参数线程池的基本大小核线程数定义了最可以同时运的线程数量线程池最大数量线程池允许创建的最大线程数最大线程数目核心线程救急线程的最大数目线程活动保持时间线程池的工作线程空闲后保持存活的时间线程活动保持时间的单位如秒毫秒等任务队列用于保存等待执行的任务的阻塞队列在多线程环境下两个线程是有可能拿到同一个任务的如果任务是存储在线程安全的队列如中并且线程通过或方式消费任务那么同一个任务不会被多个线程同时拿到因为或操作是原子的示例使用保证同一个任务不会被两个线程拿到并发编程的艺术节详情见本模块最后一个可以选择以下几个阻塞队列一个基于数组结构的有界阻塞队列此队列按先进先出原则对元素进行排序一个基于链表结构的无界阻塞队列此队列按排序元素吞吐量通常要高于线程工厂可以定制线程对象的创建例如设置线程名字是否是守护线程等拒绝策略当队列和线程池都满时会触发拒绝策略默认策略是表明无法处理新任务时抛出异常并发编程的艺术节在中线程池框架提供了以下种拒绝策略高频当线程池无法接受新任务时直接抛出异常它会将被拒绝的任务回退给提交任务的线程执行它会直接丢弃无法处理的任务并且不会抛出任何异常它会丢弃任务队列中最旧的任务即等待时间最长的任务然后尝试重新提交当前任务面试官线程池的执行原理知道吗候选人当提交一个新任务到线程池时线程池的处理流程如下线程池判断核心线程池里的线程是否都在执行任务如果不是则创建一个新的工作线程核心线程来执行任务如果核心线程池里的线程都在执行任务则进入下个流程线程池判断工作队列是否已经满如果工作队列没有满则将新提交的任务存储在这个任务队列里如果任务队列满了则进入下个流程线程池判断线程池的线程是否都处于工作状态如果没有则创建一个新的救急线程来执行任务如果已经满了则交给饱和策略来处理这个任务如果核心线程或救急线程完成任务会检查任务队列中是否有需要执行的任务如果有就核心线程或救急线程会执行任务追问线程池的是是队列大小是现在已经有个任务在运行这时第个任务来了之后会怎么做那如果是第个任务来了后发生什么当第个任务到来时由于核心线程已满且队列未满任务会被放入队列等待执行当第个任务到来时核心线程已满队列也已满由于最大线程数为线程池会创建额外的线程来执行任务直到线程数达到当第个任务到来时任务会根据拒绝策略处理默认情况下会抛出面试官为什么不建议使用创建线程池呢候选人好的其实这个事情在阿里提供的最新开发手册开发手册嵩山版中也提到了主要原因是如果使用创建线程池的话它允许的请求队列默认长度是这样的话有可能导致堆积大量的请求从而导致内存溢出所以我们一般推荐使用来创建线程池这样可以明确规定线程池的参数避免资源的耗尽面试官执法和法的区别是什么呢候选人法于提交不需要返回值的任务所以法判断任务是否被线程池执成功与否法于提交需要返回值的任务线程池会返回个类型的对象通过这个对象可以判断任务是否执成功并且可以通过的法来获取返回值法会阻塞当前线程直到任务完成使法则会阻塞当前线程段时间后即返回这时候有可能任务没有执完处理中断异常处理无法执行任务异常面试官里的阻塞队列都有哪些能简单说说吗候选人源自并发编程的艺术节提供了个阻塞队列如下一个由数组结构组成的有界阻塞队列一个由链表结构组成的无界阻塞队列一个支持优先级排序的无界阻塞队列一个使用优先级队列实现的无界阻塞队列一个不存储元素的阻塞队列一个由链表结构组成的无界阻塞队列一个由链表结构组成的双向阻塞队列下面重点介绍类阻塞队列其他的队列还请大家自行查阅书籍网站没有先后次序之分是一个用数组实现的有界阻塞队列此队列按照先进先出的原则对元素进行排序是一个用链表实现的无界阻塞队列此队列的默认和最大长度为此队列按照先进先出的原则对元素进行排序是一个由链表结构组成的双向阻塞队列所谓双向队列指的是可以从队列的两端插入和移出元素双向队列因为多了一个操作队列的入口在多线程同时入队时也就减少了一半的竞争线程使用场景问题面试官如果控制某一个方法允许并发访问线程的数量候选人在中提供了一个类信号量它提供了两个方法请求信号量可以限制线程的个数是一个正数如果信号量是就代表已经用完了信号量其他线程需要阻塞了第二个方法是代表是释放一个信号量此时信号量的个数面试官好的那该如何保证程序在多线程的情况下执行安全呢候选人嗯刚才讲过了导致线程安全的原因要解决多线程环境下的执行安全问题提供了多种工具和机制来帮助我们原子性问题可以通过使用包下的原子类如等来解决此外关键字和也可以用来确保代码块的原子性执行可见性问题关键字和关键字都可以用来确保一个线程对共享变量的修改能够被其他线程看到使用显式锁如时配合对象也可以保证可见性有序性问题通过遵循规则可以保证多线程环境下操作的有序性关键字和关键字同样可以用来保证有序性其他面试官介绍下框架工作窃取算法候选人源自并发编程艺术节框架是提供的一个用于并行执行任务的框架是一个把大任务分割成若干个小任务最终汇总每个小任务结果后得到大任务结果的框架我们再通过和这两个单词来理解一下框架就是把一个大任务切分为若干子任务并行的执行就是合并这些子任务的执行结果最后得到这个大任务的结果比如计算可以分割成个子任务每个子任务分别对个数进行求和最终汇总这个子任务的结果的运行流程图如图所示图源程序员面试笔试宝典第二版节这种模型内部使用了线程池来执行各个子任务它的工作原理为线程池中的每个线程都有自己的工作队列当自己队列中的任务都完成以后会从其他线程的工作队列中偷一个任务执行这样可以充分利用资源这种思想被称为工作窃取算法执行流程如图所示本段文字图片皆源自程序员面试笔试宝典第二版节为了减少窃取任务线程和被窃取任务线程之间的竞争通常会使用双端队列被窃取任务线程永远从双端队列的头部拿任务执行而窃取任务的线程永远从双端队列的尾部拿任务执行扩展工作窃取算法的优缺点工作窃取算法的优点充分利用线程进行并行计算减少了线程间的竞争工作窃取算法的缺点在某些情况下还是存在竞争比如双端队列里只有一个任务时并且该算法会消耗了更多的系统资源比如创建多个线程和多个双端队列面试官讲一下内存模型候选人线程间的通信由控制定义了共享内存中多线程程序读写操作的行为规范通过这些规则来规范对内存的读写操作从而保证指令的准确性内存可见性并发编程的艺术节属于语言级的内在模型它确保在不同的编译器和不同的处理器平台之上通过禁止特定类型的编译器重排序和处理器重排序为程序员提供一致的内存可见性保证把内存分成两块一块是本地内存一块是主内存线程跟线程之间相互隔离线程跟线程交互需要通过主内存面试官可能会导致数据不一致怎么理解候选人在之前的内存模型实现总是从主存即共享内存读取变量是不需要进特别的注意的在当前的内存模型下线程可以把变量保存本地内存如机器的寄存器中不是直接在主存中进读写这就可能造成个线程在主存中修改了个变量的值另外个线程还继续使它在寄存器中的变量值的拷造成数据的不致要解决这个问题可以把变量声明为这就指示这个变量是共享且不稳定的每次使它都到主存中进读取保证变量的可性面试官聊聊与的关系候选人是最核心的概念对应程序员来说理解是理解的关键使用的概念来指定两个操作之间的执行顺序由于这两个操作可以在一个线程之内也可以是在不同线程之间因此可以通过关系向程序员提供跨线程的内存可见性保证如果线程的写操作与线程的读操作之间存在关系尽管操作和操作在不同的线程中执行但向程序员保证操作将对操作可见对关系的定义如下如果一个操作另一个操作那么第一个操作的执行结果将对第二个操作可见而且第一个操作的执行顺序排在第二个操作之前两个操作之间存在关系并不意味着平台的具体实现必须要按照关系指定的顺序来执行如果重排序之后的执行结果与按关系来执行的结果一致那么这种重排序并不非法也就是说允许这种重排序面试官你知道有哪些应用场景吗候选人的应用场景主要是在多线程编程中用于确保线程之间的操作顺序和可见性以下是一些常见的应用场景线程同步可以用于保证线程之间的同步操作的正确性例如在使用或机制进行线程同步时规则可以确保一个线程的解锁操作后续线程的加锁操作从而保证线程之间的同步性变量可以用于保证对变量的写操作对后续线程的读操作可见因为变量具有可见性所以对一个变量的写操作后续线程对该变量的读操作确保了变量的可见性线程间通信可以用于确保线程间通信的正确性例如使用或机制进行线程间的等待和唤醒操作时可以确保等待线程在接收通知之前必须看到发送通知的线程对共享数据的修改线程安全性可以用于保证线程安全性例如在使用或机制保护共享资源时可以确保一个线程的写操作后续线程的读操作从而保证线程安全线程的启动和终止可以用于确保线程的启动操作后续线程的操作以及线程的终止操作其他线程对该线程的操作面试官谈谈你对的理解候选人通常情况下我们创建的变量是可以被任何个线程访问并修改的如果想实现每个线程都有的专属本地变量该如何解决呢中提供的类正是为了解决这样的问题类主要解决的就是让每个线程绑定的值可以将类形象的喻成存放数据的盒盒中可以存储每个线程的私有数据从而避免了线程间竞争的安全问题并发编程的艺术节即线程变量是一个以对象为键任意对象为值的存储结构这个结构被附带在线程上也就是说一个线程可以根据一个对象查询到绑定在这个线程上的一个值可以通过方法来设置一个值在当前线程下再通过方法获取到原先设置的值面试官好的那你知道的底层原理实现吗候选人在内部维护了一个类型的成员变量用来存储资源对象当调用方法就是以自己作为资源对象作为放入当前线程的集合中当调用方法就是以自己作为到当前线程中查找关联的资源值当调用方法就是以自己作为移除当前线程关联的资源值面试官好的那关于会导致内存溢出这个事情了解吗候选人因为中的被设计为弱引用使用弱引用的目的在于节约资源而是一个强引用所以在垃圾回收的时候会被清理掉不会被清理掉这样来中就会出现为的假如我们不做任何措施的话永远法被回收这个时候就可能会产内存泄露实现中已经考虑了这种情况在调法的时候会清理掉为的记录使完法后最好动调释放拓展强引用与弱引用深入理解虚拟机高级特性与最佳实践强引用是最传统的引用的定义是指在程序代码之中普遍存在的引用赋值即类似这种引用关系无论任何情况下只要强引用关系还存在垃圾收集器就永远不会回收掉被引用的对象弱引用也是用来描述那些非必须对象但是它的强度比软引用更弱一些被弱引用关联的对象只能生存到下一次垃圾收集发生为止当垃圾收集器开始工作无论当前内存是否足够都会回收掉只被弱引用关联的对象面试官跨线程传递的问题候选人在中提供了线程本地变量通常用于存储线程独有的数据避免线程间的资源竞争然而的数据只能在当前线程中访问跨线程时数据无法直接传递解决方案使用允许父线程的数据传递到子线程它在创建子线程时会复制父线程的值适用于简单的父子线程场景注意数据是引用传递如果子线程修改了数据父线程的数据会受到影响使用针对线程池等复杂场景可以使用阿里巴巴的组件在任务提交到线程池前会备份当前线程的数据并在任务执行时恢复常用于分布式追踪日志上下文等场景',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-30 15:35:24',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 19
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/miahemu" title="GitHub"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="力扣"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="力扣"/><span class="back-menu-item-text">力扣</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="CSDN"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://miahemu.github.io/about/" title="个人简介"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="个人简介"/><span class="back-menu-item-text">个人简介</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">和睦的拾光物语</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9460279562&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 小挂件</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/weather/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 天气</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">JAVA面经<sup>11</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">数据结构与算法<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AF%95/" style="font-size: 1.05rem;">笔试<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA%E9%9D%A2%E7%BB%8F/" itemprop="url">JAVA面经</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JAVA面经</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JUC相关面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-30T07:35:24.502Z" title="更新于 2025-03-30 15:35:24">2025-03-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">14.4k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="JUC相关面试题"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为鸡毛换糖城"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>鸡毛换糖城</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://w.wallhaven.cc/full/j3/wallhaven-j3rgqw.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><header><a class="post-meta-categories" href="/categories/JAVA%E9%9D%A2%E7%BB%8F/" itemprop="url">JAVA面经</a><a href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" tabindex="-1" itemprop="url">JAVA面经</a><h1 id="CrawlerTitle" itemprop="name headline">JUC相关面试题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">miahemu</span><time itemprop="dateCreated datePublished" datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time><time itemprop="dateCreated datePublished" datetime="2025-03-30T07:35:24.502Z" title="更新于 2025-03-30 15:35:24">2025-03-30</time></header><div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>本文为原创内容，转载请注明出处并附带原文链接。感谢您的尊重与支持！</p>
</div>

<div class="tip sync"><p>你必须非常努力，才能看起来毫不费劲。</p>
</div>

<hr>
<h2 id="1-线程的基础知识"><a href="#1-线程的基础知识" class="headerlink" title="1 线程的基础知识"></a>1 线程的基础知识</h2><h3 id="面试官：聊一下并行和并发有什么区别？（高频）"><a href="#面试官：聊一下并行和并发有什么区别？（高频）" class="headerlink" title="面试官：聊一下并行和并发有什么区别？（高频）"></a><strong>面试官</strong>：聊一下并行和并发有什么区别？<code>（高频）</code></h3><p><strong>候选人：</strong></p>
<p>并发是指在同一时间段内，系统有能力处理多个事件，多个线程轮流使用一个或多个CPU。换句话说，并发并不一定要求任务同时进行，而是通过快速切换任务来实现“看起来同时运行”的效果。</p>
<p>并行是指在同一时刻，多个任务可以在多个处理器核心上同时执行，4核CPU同时执行4个线程。（宏观并行，微观并发）</p>
<hr>
<h3 id="面试官：说一下线程和进程的区别？"><a href="#面试官：说一下线程和进程的区别？" class="headerlink" title="面试官：说一下线程和进程的区别？"></a><strong>面试官</strong>：说一下线程和进程的区别？</h3><p><strong>候选人：</strong></p>
<ul>
<li><p>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</p>
</li>
<li><p>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享进程的<strong>堆</strong>和 <strong>⽅法区</strong> 资源，但每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地⽅法栈</strong></p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</p>
</li>
</ul>
<blockquote>
<p>下⾯来思考这样⼀个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地⽅法栈</strong>是线程私有的呢？</p>
<ol>
<li>在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能够知道该线程上次运⾏到哪⼉了。如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的是 Java 代码时程序计数器记录的才是下⼀条指令的地址。所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执⾏位置</strong>。</li>
<li><strong>虚拟机栈为虚拟机执⾏</strong> <strong>Java⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的</strong> <strong>Native</strong> <strong>⽅法服务。<strong>所以，为了</strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地⽅法栈是线程私有的。</li>
</ol>
</blockquote>
<hr>
<h3 id="面试官：什么是线程上下⽂切换-（高频）"><a href="#面试官：什么是线程上下⽂切换-（高频）" class="headerlink" title="面试官：什么是线程上下⽂切换?（高频）"></a><strong>面试官</strong>：什么是线程上下⽂切换?<code>（高频）</code></h3><p><strong>候选人：</strong>（源自《Java并发编程艺术》1.1节）</p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间后片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。</p>
<p>这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是便打开中英文字典，但是在放下英文技术书之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文切换也会影响多线程的执行速度。</p>
<hr>
<h3 id="面试官：如何减少上下⽂切换"><a href="#面试官：如何减少上下⽂切换" class="headerlink" title="面试官：如何减少上下⽂切换?"></a><strong>面试官</strong>：如何减少上下⽂切换?</h3><p><strong>候选人：</strong>（源自《Java并发编程艺术》1.1.3节）</p>
<p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p>
<ul>
<li><p><strong>无锁并发编程。</strong> 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。</p>
</li>
<li><p><strong>CAS 算法。</strong> Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。</p>
</li>
<li><p><strong>使用最少线程。</strong> 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</p>
</li>
<li><p><strong>协程:</strong> 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
</li>
</ul>
<hr>
<h3 id="面试官：-同步和异步的区别？（高频）"><a href="#面试官：-同步和异步的区别？（高频）" class="headerlink" title="面试官： 同步和异步的区别？（高频）"></a><strong>面试官：</strong> 同步和异步的区别？<code>（高频）</code></h3><p><strong>候选人：</strong></p>
<p>首先说一下<strong>什么是同步</strong>，同步指的是任务按照顺序依次执行的方式。在这种模式下，调用者会阻塞等待任务完成并返回结果后，才会继续执行后续的操作。</p>
<p>然后再<strong>说一下什么是异步</strong>，异步指的是任务无需等待立即返回，调用方可以继续执行其他操作，而任务的结果会在稍后通过如回调函数、事件通知或 Future 对象等机制传递给调用方。</p>
<p>最后说一下<strong>同步和异步的区别</strong>：</p>
<p>第一是执行方式不同，同步是阻塞式的，调用方需要等待任务完成才能继续；而异步是非阻塞式的，调用方无需等待任务完成即可继续执行。</p>
<p>第二是响应机制不同，同步直接返回任务的结果，调用方可以直接使用；而异步通常通过回调函数、事件通知或 Future 对象等方式传递结果。</p>
<p>第三是适用场景不同，同步适合简单、短时间的任务，或者需要立即获取结果的场景；而异步适合需要提高系统吞吐量的场景，或者用于耗时较长的任务，如：网络请求、文件读写等。</p>
<hr>
<h3 id="面试官：如果在java中创建线程有哪些方式？（高频）"><a href="#面试官：如果在java中创建线程有哪些方式？（高频）" class="headerlink" title="面试官：如果在java中创建线程有哪些方式？（高频）"></a><strong>面试官</strong>：如果在java中创建线程有哪些方式？<code>（高频）</code></h3><p><strong>候选人：<strong>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用</strong>线程池</strong>的方式创建线程。</p>
<hr>
<h3 id="面试官：好的，刚才你说的runnable-和-callable-两个接口创建线程有什么不同呢？"><a href="#面试官：好的，刚才你说的runnable-和-callable-两个接口创建线程有什么不同呢？" class="headerlink" title="面试官：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？"></a><strong>面试官</strong>：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</h3><p><strong>候选人：</strong></p>
<ul>
<li><p>Runnable 接口run方法无返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>
</li>
<li><p>还有一个就是，他们异常处理也不一样。Runnable接口run方法只能抛出运行时异常，也无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息</p>
</li>
</ul>
<p>在实际开发中，如果需要拿到执行的结果，需要使用Callalbe接口创建线程，调用**FutureTask.get()**得到可以得到返回值，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>
<hr>
<h3 id="面试官：线程的生命周期和状态？（高频）"><a href="#面试官：线程的生命周期和状态？（高频）" class="headerlink" title="面试官：线程的生命周期和状态？（高频）"></a><strong>面试官</strong>：线程的生命周期和状态？<code>（高频）</code></h3><p><strong>候选人：</strong> 在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：初始、运行、终止、阻塞、等待和超时等待六种。（图源《Java 并发编程艺术》4.1.4 节）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8d4f00ba3d5a1d7e6a74e.png" alt="image-20250225100642892"></p>
<p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>初始</strong>状态，调用了 start 方法，就会由<strong>初始</strong>进入<strong>运行</strong>状态。如果线程内代码已经执行完毕，由<strong>运行</strong>进入<strong>终止</strong>状态。当然这些是一个线程正常执行情况。</p>
<p>如果线程获取锁失败后，由<strong>运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>运行</strong>状态。</p>
<p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>运行</strong>状态。</p>
<p>还有一种情况是调用 sleep(long) 方法也会从<strong>运行</strong>状态进入<strong>超时等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>运行</strong>状态。</p>
<p>（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8d3b70ba3d5a1d7e6a6f6.png" alt="image-20250225100655004"></p>
<hr>
<h3 id="面试官：说说sleep-⽅法和wait-⽅法区别和共同点"><a href="#面试官：说说sleep-⽅法和wait-⽅法区别和共同点" class="headerlink" title="面试官：说说sleep()⽅法和wait()⽅法区别和共同点?"></a><strong>面试官</strong>：说说sleep()⽅法和wait()⽅法区别和共同点?</h3><p><strong>候选人：</strong> 它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</p>
<p>不同点主要有三个方面：</p>
<p><strong>第一：方法归属不同</strong></p>
<p>sleep(long) 是 Thread 的静态方法。而 wait() 是 Object 的成员方法，每个对象都有。</p>
<p><strong>第二：线程醒来时机不同</strong></p>
<p>线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去。</p>
<p><strong>第三：锁特性不同</strong>（《Java程序员面试笔试宝典》第二版 4.8节）</p>
<ul>
<li><p>由于 sleep 方法的主要作用是让线程休眠指定的一段时间，在时间到时自动恢复，不涉及线程间的通信，因此，调用 sleep 方法并不会释放锁。（相当于我放弃 cpu，你们也用不了）</p>
</li>
<li><p>而 wait 方法则不同，当调用 wait 方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他 synchronized 数据可被别的线程使用。（相当于我放弃 cpu，但你们还可以用）</p>
</li>
</ul>
<blockquote>
<p>《Java程序员面试笔试宝典》第二版 4.8节 </p>
<p><strong>引申：sleep()方法与yield()方法的区别是什么？</strong></p>
<p>sleep()方法与yield()方法的区别主要表现在以下几个方面:</p>
<p>1)sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会，而 yield()方法只会给相同优先级或更高优先级的线程以运行的机会。</p>
<p>2)线程执行sleep()方法后会转入超时等待状态，所以，执行sleep()方法的线程在指定的时间内肯定不会被执行，而 yield()方法只是使当前线程重新回到可执行状态，所以执行yield()方法的线程有可能在进入到可执行状态后马上又被执行。</p>
<p>3)sleep()方法声明抛出 <code>InterruptedException</code>，而 yield()方法没有声明任何异常。</p>
<p>4)sleep()方法比 yield()方法(跟操作系统相关)具有更好的可移植性。</p>
</blockquote>
<hr>
<h3 id="面试官：好的，我现在举一个场景，你来分析一下怎么做，新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#面试官：好的，我现在举一个场景，你来分析一下怎么做，新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="面试官：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a><strong>面试官</strong>：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h3><p><strong>候选人：</strong> 这道题不难，⼤部分⼈都是⽤ join() 或者 CountDownLatch 实现。话不多说上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// join();</span></span><br><span class="line">        countDownLatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countDownLatch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch1.countDown(); <span class="comment">// T1 完成后释放 latch1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 T1 完成</span></span><br><span class="line">                latch1.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;T2 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch2.countDown(); <span class="comment">// T2 完成后释放 latch2</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 T2 完成</span></span><br><span class="line">                latch2.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;T3 is running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3 finished&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T2 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T2 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T3 is running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T3 finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动 T1 并等待其完成</span></span><br><span class="line">            t1.start();</span><br><span class="line">            t1.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// T1 完成后启动 T2 并等待其完成</span></span><br><span class="line">            t2.start();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// T2 完成后启动 T3 并等待其完成</span></span><br><span class="line">            t3.start();</span><br><span class="line">            t3.join();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="面试官：在我们使用线程的过程中，有两个方法。线程的-run-和-start-有什么区别？"><a href="#面试官：在我们使用线程的过程中，有两个方法。线程的-run-和-start-有什么区别？" class="headerlink" title="面试官：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？"></a><strong>面试官</strong>：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</h3><p><strong>候选人：</strong> start方法用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。run方法封装了要被线程执行的代码，可以被调用多次。</p>
<p>总结：<strong>调⽤start() ⽅法⽅可启动线程并使线程进⼊就绪状态，直接执⾏run()⽅法的话不会以多线程的⽅式执⾏。</strong></p>
<hr>
<h3 id="面试官：那如何停止一个正在运行的线程呢？"><a href="#面试官：那如何停止一个正在运行的线程呢？" class="headerlink" title="面试官：那如何停止一个正在运行的线程呢？"></a><strong>面试官</strong>：那如何停止一个正在运行的线程呢？</h3><p><strong>候选人</strong>：有三种方式可以停止线程：</p>
<p>第一：可以使用<strong>退出标志</strong>，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记</p>
<p>第二：可以使用线程的suspend()、resume()和stop()方法强行终止，不过一般不推荐，这个方法已作废</p>
<p>第三：可以使用线程的<strong>interrupt</strong>方法中断线程，内部其实也是使用中断标志来中断线程</p>
<p>我们项目中使用的话，建议使用第一种或第三种方式中断线程</p>
<blockquote>
<p>《Java并发编程的艺术》4.2.4节:</p>
<p>不建议使用suspend()、resume()和stop()方法的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源(比如锁)，而是<strong>占有着资源进入睡眠状态</strong>，这样<strong>容易引发死锁</strong>问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
</blockquote>
<hr>
<h2 id="2-线程中并发锁"><a href="#2-线程中并发锁" class="headerlink" title="2 线程中并发锁"></a>2 线程中并发锁</h2><h3 id="面试官：说一下公平锁与非公平锁的区别？"><a href="#面试官：说一下公平锁与非公平锁的区别？" class="headerlink" title="面试官：说一下公平锁与非公平锁的区别？"></a><strong>面试官</strong>：说一下公平锁与非公平锁的区别？</h3><p><strong>候选人：</strong></p>
<p><strong>公平锁（Fair Lock）</strong></p>
<p>按照线程在队列中的排队顺序，先到者先拿到锁。</p>
<p><strong>非公平锁（Unfair Lock）</strong></p>
<p>当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。</p>
<blockquote>
<p>《Java并发编程的艺术》5.3节：</p>
<ul>
<li><p>这里提到一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。</p>
</li>
<li><p>事实上，<strong>公平的锁机制往往没有非公平的效率高</strong>，但是，并不是任何场景都是以 TPS 作为唯一的指标，公平锁能够减少**“饥饿”**发生的概率，等待越久的请求越是能够得到优先满足。</p>
</li>
<li><p>在测试中公平性锁与非公平性锁相比，总耗时是其 94.3倍，总切换次数是其 133 倍。可以看出，公平性锁保证了锁的获取按照 <strong>FIFO</strong> 原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
</li>
</ul>
</blockquote>
<hr>
<h3 id="面试官：说一下悲观锁与乐观锁的区别？（高频）"><a href="#面试官：说一下悲观锁与乐观锁的区别？（高频）" class="headerlink" title="面试官：说一下悲观锁与乐观锁的区别？（高频）"></a><strong>面试官</strong>：说一下悲观锁与乐观锁的区别？<code>（高频）</code></h3><p><strong>候选人：</strong> 悲观锁和乐观锁是数据库管理系统中用于处理并发事务的不同方式。</p>
<p><code>悲观锁</code> ：假设数据会被并发修改，所以访问数据时会<strong>加锁</strong>，其他线程必须等待锁释放。适用于高并发写操作较多的场景，以确保数据的一致性。</p>
<ul>
<li><p><strong>数据库级别的悲观锁</strong>（常用于 MySQL）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># `<span class="keyword">FOR</span> <span class="keyword">UPDATE</span>` 会在查询行上加排他锁，阻止其他事务修改。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 代码实现（基于 <code>synchronized</code> 或 <code>ReentrantLock</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PessimisticLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();  <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>乐观锁</code> : 假设数据不会被冲突修改，先尝试更新，如果发现冲突（版本号不匹配），则重试或失败。适用于<strong>读多写少</strong>的场景，比如商品库存扣减、用户账户余额更新等。<strong>乐观锁通常通过版本号或时间戳来检测数据是否已被修改。</strong></p>
<ul>
<li><p><strong>数据库级别的乐观锁（基于版本号）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name </span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">value</span> <span class="operator">=</span> ?, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> version <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 代码实现（使用 <code>AtomicInteger</code> 或 <code>CAS</code> 机制）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OptimisticLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">version</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldVersion</span> <span class="operator">=</span> version.get();</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (!version.compareAndSet(oldVersion, oldVersion + <span class="number">1</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;更新失败，版本号冲突，重试...&quot;</span>);</span><br><span class="line">            update();  <span class="comment">// 递归重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>compareAndSet(oldValue, newValue)</code> 采用 CAS（Compare-And-Swap）操作，确保版本号未被其他线程修改，否则失败并重试。</p>
</li>
</ul>
<p>简单来说，悲观锁适合于<strong>数据冲突频繁</strong>的场景，它通过加锁来防止冲突；而乐观锁更适合于<strong>读多写少</strong>的场景，通过在提交时检查冲突来减少锁的竞争。</p>
<hr>
<h3 id="面试官：讲一下synchronized关键字的底层原理？（高频）"><a href="#面试官：讲一下synchronized关键字的底层原理？（高频）" class="headerlink" title="面试官：讲一下synchronized关键字的底层原理？（高频）"></a><strong>面试官</strong>：讲一下synchronized关键字的底层原理？<code>（高频）</code></h3><p><strong>候选人</strong>：synchronized关键字解决的是<strong>多个线程之间访问资源的同步性</strong>，synchronized 关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</p>
<p>synchronized 底层使用的<strong>JVM级别中的Monitor（监视器锁）</strong> 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。<strong>synchronized 属于悲观锁。</strong></p>
<p>在 Java 早期版本中， synchronized 属于 <strong>重量级锁</strong>，效率低下。</p>
<blockquote>
<p>《Java并发编程的艺术》2.2节:</p>
<p>从JVM 规范中可以看到 Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现<strong>方法同步</strong>和<strong>代码块同步</strong>，但两者的实现细节不一样。</p>
<ul>
<li>代码块同步是使用 <strong>monitorenter 和 monitorexit 指令</strong>实现的，monitorenter 指令是在编译后插入到同步代码块的<strong>开始位置</strong>，而 monitorexit 是插入到<strong>方法结束处和异常处</strong>，JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。</li>
<li>方法同步是使用另外一种方式实现的，JVM 通过该<strong>ACC_SYNCHRONIZED</strong> 访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。</li>
</ul>
<p><strong>不过两者的本质都是对 对象监视器</strong> <strong>monitor</strong> <strong>的获取。</strong></p>
</blockquote>
<hr>
<h3 id="面试官：你能具体说下Monitor-吗？（高频）"><a href="#面试官：你能具体说下Monitor-吗？（高频）" class="headerlink" title="面试官：你能具体说下Monitor 吗？（高频）"></a><strong>面试官</strong>：你能具体说下Monitor 吗？<code>（高频）</code></h3><p><strong>候选人</strong>：monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。</p>
<p>monitor内部维护了三个变量:</p>
<ul>
<li><p><strong>WaitSet</strong>：保存处于Waiting状态的线程</p>
</li>
<li><p><strong>EntryList</strong>：保存处于Blocked状态的线程</p>
</li>
<li><p><strong>Owner</strong>：持有锁的线程</p>
</li>
</ul>
<p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，<strong>一个monitor中只能有一个Owner</strong>。</p>
<p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p>
<hr>
<h3 id="面试官：说说⾃⼰是怎么使⽤-synchronized-关键字的？"><a href="#面试官：说说⾃⼰是怎么使⽤-synchronized-关键字的？" class="headerlink" title="面试官：说说⾃⼰是怎么使⽤ synchronized 关键字的？"></a><strong>面试官</strong>：说说⾃⼰是怎么使⽤ synchronized 关键字的？</h3><p><strong>候选人</strong>：</p>
<p><strong>1.修饰实例⽅法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.修饰静态⽅法: ** 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得 <strong>当前class的锁</strong>。因为静态成员不属于任何⼀个实例对象，是类成员（ <em>static</em> 表明这是该类的⼀个静态资源，不管 <em>new</em> 了多少个对象，只有⼀份）。所以，如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，<strong>因为访问静态</strong> <strong>synchronized</strong> <strong>⽅法占⽤的锁是当前类的锁，⽽访问⾮静态</strong> <strong>synchronized</strong> <strong>⽅法占⽤的锁是当前实例对象锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象&#x2F;类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得<strong>给定对象的锁</strong>。 synchronized( .class) 表示进⼊同步代码前要获得 <strong>当前</strong> <strong>class</strong> <strong>的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"> <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><p><code>synchronized</code> 关键字加到 <code>static</code> 静态⽅法和 <code>synchronized(class)</code> 代码块上都是是给 <code>Class</code>类上锁。</p>
</li>
<li><p><code>synchronized</code> 关键字加到实例⽅法上是给对象实例上锁。</p>
</li>
<li><p>尽量不要使⽤ <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</p>
</li>
</ul>
<hr>
<h3 id="面试官：单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！"><a href="#面试官：单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！" class="headerlink" title="面试官：单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！"></a><strong>面试官</strong>：单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！</h3><p><strong>候选人</strong>：<strong>双重校验锁实现对象单例（线程安全）</strong> 这个必须要会！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//类对象加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>另外，<code>uniqueInstance</code> 采⽤ <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton(); </code>这段代码其实是分为三步执⾏：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>如果没有<code>volatile</code>，由于 JVM 具有<strong>重排序</strong>的特性，执⾏顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ <code>getUniqueInstance ()</code> 后发现 uniqueInstance 不为空，因此返回<code>uniqueInstance</code> ，但此时 <code>uniqueInstance</code> 还未被初始化。所以这是一种错误的用法！</p>
<p>但是如果使⽤ <code>volatile</code> 就可以禁⽌ JVM 的指令重排，实现线程安全的延迟初始化，保证在多线程环境下也能正常运⾏。</p>
<hr>
<h3 id="面试官：关于synchronized-的锁升级的情况了解吗？"><a href="#面试官：关于synchronized-的锁升级的情况了解吗？" class="headerlink" title="面试官：关于synchronized 的锁升级的情况了解吗？"></a><strong>面试官</strong>：关于synchronized 的锁升级的情况了解吗？</h3><p><strong>候选人</strong>：Java中的synchronized有<strong>偏向锁、轻量级锁、重量级锁</strong>三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<p>**重量级锁：**底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
<p>**轻量级锁：**线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级锁修改对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性。</p>
<p>**偏向锁：**一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令。（图源《Java并发编程的艺术》2.2.1节）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8e9ac0ba3d5a1d7e6b05c.png" alt="image-20250225100802773"></p>
<blockquote>
<p>《Java并发编程的艺术》2.2.1节：</p>
<p>在 Java SE 1.6中，锁一共有4种状态，级别从低到高依次是:无锁状态、偏向锁状态轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8e9c80ba3d5a1d7e6b05f.png" alt="image-20250225100812596"></p>
</blockquote>
<hr>
<h3 id="面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？"><a href="#面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？" class="headerlink" title="面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？"></a><strong>面试官</strong>：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</h3><p><strong>候选人</strong>：在高并发下，我们可以采用<strong>ReentrantLock</strong>来加锁。</p>
<h3 id="面试官：说下ReentrantLock的使用方式和底层原理？"><a href="#面试官：说下ReentrantLock的使用方式和底层原理？" class="headerlink" title="面试官：说下ReentrantLock的使用方式和底层原理？"></a><strong>面试官</strong>：说下ReentrantLock的使用方式和底层原理？</h3><p><strong>候选人</strong>：</p>
<p>ReentrantLock是一个可重入锁 ，调用 Lock 方法获取了锁之后，再次调用 Lock，是不会再阻塞，内部直接增加重入次数，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p>
<p>ReentrantLock是属于<strong>JUC包</strong>（JUC是Java平台提供的一个用于支持高并发程序设计的工具包）下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p>
<p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁。构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。</p>
<h3 id="面试官：刚才你说了CAS和AQS，你能介绍一下吗？"><a href="#面试官：刚才你说了CAS和AQS，你能介绍一下吗？" class="headerlink" title="面试官：刚才你说了CAS和AQS，你能介绍一下吗？"></a><strong>面试官</strong>：刚才你说了CAS和AQS，你能介绍一下吗？</h3><p><strong>候选人</strong>：</p>
<p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p>
<blockquote>
<p>《Java并发编程的艺术》2.3节对CAS操作的解释：</p>
<p>CAS 操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</p>
</blockquote>
<ul>
<li><p>CAS使用到的地方很多：AQS框架、AtomicXXX类</p>
</li>
<li><p>在操作共享变量的时候使用的自旋锁，效率上更高一些</p>
</li>
<li><p>CAS的底层是调用的<strong>Unsafe</strong>类中的方法，都是操作系统提供的，其他语言实现</p>
</li>
</ul>
<p>AQS的全称是：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。使⽤ AQS 能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，⽐如 <code>ReentrantLock</code> ， <code>Semaphore</code> ，其他的诸如<code>ReentrantReadWriteLock</code> ， <code>CountDownLatch</code> ， <code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们⾃⼰也能利⽤ AQS ⾮常轻松容易地构造出符合我们⾃⼰需求的同步器。</p>
<p>AQS内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过CAS机制设置 state 状态。</p>
<p>在它的内部还提供了基于 FIFO 的等待队列（<strong>CLH</strong> <strong>队列</strong>），是一个双向列表，其中</p>
<ul>
<li><p>tail 指向队列最后一个元素</p>
</li>
<li><p>head  指向队列中最久的一个元素</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f2050ba3d5a1d7e6b1f3.png" alt="image-20250225100831142"></p>
<h3 id="面试官：AQS对资源的共享方式（Semaphore、CountDownLatch、CyclicBarrier）"><a href="#面试官：AQS对资源的共享方式（Semaphore、CountDownLatch、CyclicBarrier）" class="headerlink" title="面试官：AQS对资源的共享方式（Semaphore、CountDownLatch、CyclicBarrier）"></a><strong>面试官</strong>：AQS对资源的共享方式（Semaphore、CountDownLatch、CyclicBarrier）</h3><p><strong>候选人：</strong></p>
<p><strong>Exclusive</strong>（独占）：只有⼀个线程能执⾏，如 ReentrantLock ，可分为公平锁和⾮公平锁。</p>
<p><strong>Share</strong>（共享）：多个线程可同时执⾏，如CountDownLatch（倒计时器）、Semaphore（信号量）、CyclicBarrier（回环栅栏） 。</p>
<p><strong>ReentrantReadWriteLock</strong> 可以看成是组合式，因为 <strong>ReentrantReadWriteLock</strong> 也就是读写锁允许多个线程同时对某⼀资源进⾏读。</p>
<p>不同的⾃定义同步器争⽤共享资源的⽅式也不同。⾃定义同步器在实现时只需要实现共享资源state 的获取与释放⽅式即可，⾄于具体线程等待队列的维护（如获取资源失败⼊队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p>
<blockquote>
<p>《Java并发编程的艺术》 8.1  8.2  8.3节</p>
<ul>
<li><code>Semaphore（信号量）</code>是用来控制同时访问特定资源的线程数量（大白话：可以指定多个线程同时访问某个资源），它通过协调各线程，以保证合理的使用公共资源。Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。Semaphore 的用法也很简单，首先线程使用 Semaphore 的 acquire( ) 方法获取一个许可证，使用完之后调用 release( ) 方法归还许可证。还可以用 tryAcquire( )方法尝试获取许可证。</li>
<li><code>CountDownLatch（倒计时器）</code>允许一个或多个线程等待其他线程完成操作。（大白话：它可以让某一个线程等待直到倒计时结束，再开始执行）。CountDownLatch 的构造函数接收一个 int 类型的参数作为计数器，如果你想等待 N个点完成，这里就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch 的await方法会阻塞当前线程，直到N变成零。</li>
<li><code>CyclicBarrier</code> 的字⾯意思是可循环使⽤（ Cyclic ）的屏障（ Barrier ）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续运行。 CyclicBarrier 默认的构造⽅法是 CyclicBarrier(int parties) ，其参数表示屏障拦截的线程数量，每个线程调⽤ await() ⽅法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch的用法</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    c.countDown();</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    c.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            c.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  CyclicBarrier的用法</span></span><br><span class="line"><span class="comment">// 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会出现两种输出</span></span><br><span class="line"><span class="comment">// 第一种： 1 2    第二种： 2 1</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="comment">// 如果把 new CyclicBarrier(2)修改成 new CyclicBarrier(3)，则主线程和子线程会永远等待。</span></span><br><span class="line">    <span class="comment">// 因为没有第三个线程执行 await 方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="面试官：CyclicBarrier和CountDownLatch的区别"><a href="#面试官：CyclicBarrier和CountDownLatch的区别" class="headerlink" title="面试官：CyclicBarrier和CountDownLatch的区别"></a><strong>面试官</strong>：CyclicBarrier和CountDownLatch的区别</h3><p><strong>候选人</strong>：（源自《Java并发编程的艺术》 8.2.3节）</p>
<ul>
<li>CountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset（) 方法重置。所以CyclicBarrier 能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</li>
<li>CyclicBarrier 还提供其他有用的方法，比如 getNumberWaiting方法可以获得 CyclicBarrier阻塞的线程数量。isBroken（）方法用来了解阻塞的线程是否被中断。</li>
</ul>
<hr>
<h3 id="面试官：synchronized和Lock有什么区别"><a href="#面试官：synchronized和Lock有什么区别" class="headerlink" title="面试官：synchronized和Lock有什么区别 ?"></a><strong>面试官</strong>：synchronized和Lock有什么区别 ?</h3><p><strong>候选人</strong>：</p>
<p>第一，语法层面</p>
<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li>
</ul>
<p>第二，功能层面</p>
<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
<p>第三，性能层面</p>
<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
<p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p>
<hr>
<h3 id="面试官：说说Synchronized和ReentrantLock的区别（高频）"><a href="#面试官：说说Synchronized和ReentrantLock的区别（高频）" class="headerlink" title="面试官：说说Synchronized和ReentrantLock的区别（高频）"></a><strong>面试官</strong>：说说Synchronized和ReentrantLock的区别<code>（高频）</code></h3><p><strong>候选人：</strong></p>
<ol>
<li>Synchronized 可以用来修饰普通方法、静态方法和代码块；ReentrantLock 只能用在代码块上。</li>
<li>Synchronized 会自动加锁和释放锁；ReentrantLock需手动加锁和释放锁。</li>
<li>Synchronized 属于非公平锁；ReentrantLock 既可以是公平锁也可以是非公平锁。</li>
<li>Synchronized 是JVM通过 monitor 实现的；ReentrantLock是通过CAS+AQS队列实现的。</li>
</ol>
<hr>
<h3 id="面试官：请谈谈你对-volatile-的理解"><a href="#面试官：请谈谈你对-volatile-的理解" class="headerlink" title="面试官：请谈谈你对 volatile 的理解"></a><strong>面试官</strong>：请谈谈你对 volatile 的理解</h3><p><strong>候选人</strong>：volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能：</p>
<p>第一：保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
<p>第二： 禁止进行指令<strong>重排序</strong>，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化。</p>
<blockquote>
<p>《Java并发编程的艺术》 3.2节</p>
<p><strong>重排序</strong>是指编译器和处理器为了<strong>优化程序性能而对指令序列进行重新排序</strong>的一种手段。</p>
</blockquote>
<hr>
<h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3 线程池"></a>3 线程池</h2><h3 id="面试官：-为什么要⽤线程池？"><a href="#面试官：-为什么要⽤线程池？" class="headerlink" title="面试官： 为什么要⽤线程池？"></a><strong>面试官</strong>： 为什么要⽤线程池？</h3><p><strong>候选人</strong>：（源自《Java 并发编程的艺术》 9.1节）</p>
<p>在开发过程中，合理地使用线程池能够带来3个好处：</p>
<ul>
<li><p><strong>降低资源消耗</strong>。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p><strong>提⾼响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。</p>
</li>
<li><p><strong>提⾼线程的可管理性</strong>。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控。</p>
</li>
</ul>
<hr>
<h3 id="面试官：线程池四种创建方式"><a href="#面试官：线程池四种创建方式" class="headerlink" title="面试官：线程池四种创建方式"></a><strong>面试官</strong>：线程池四种创建方式</h3><p><strong>候选人</strong>：</p>
<p>在jdk中默认提供了4种方式创建线程池。</p>
<p>第一个是：<strong>newCachedThreadPool</strong> 创建可以缓存的线程池，有任务提交到线程池时如果有空闲的线程可用则立即使用空闲线程执行任务，如果没有空闲的线程可用就会创建一个新的线程执行任务，当空闲线程闲置一段时间（默认是60秒）之后还未被使用，那么就会进行销毁操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建可缓存的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务给线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">studentId</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;学生 &quot;</span> + studentId + <span class="string">&quot; 正在报名兴趣小组...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟报名过程的时间消耗</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;学生 &quot;</span> + studentId + <span class="string">&quot; 报名成功！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f2730ba3d5a1d7e6b201.png" alt="image-20250225100951934"></p>
<p>第二个是：<strong>newFixedThreadPool</strong> 创建一个定长线程池。 该线程池中的线程数量始终不变。当有⼀个新的任务提交时，线程池中若有空闲线程，则⽴即执⾏。若没有，则新的任务会被暂存在⼀个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池，大小为2</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 提交3个任务给线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>(i);</span><br><span class="line">            executorService.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有任务执行完毕，关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> taskId;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> taskId)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.taskId = taskId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; 执行中...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 暂停，</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; 执行完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f28b0ba3d5a1d7e6b204.png" alt="image-20250225101005654"></p>
<p>第三个是：<strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具有固定核心线程数的线程池</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟任务，延迟3秒后仅执行一次</span></span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;延迟任务开始执行....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周期性任务，每隔1秒执行一次</span></span><br><span class="line">        executorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;周期性任务开始执行....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待一段时间后关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f2a10ba3d5a1d7e6b207.png" alt="image-20250225101018504"></p>
<p>第四个是：<strong>newSingleThreadExecutor</strong> 创建一个单线程的线程池，它只会使用一个线程执行任务，可以保证任务的执行顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadExecutorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建单线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 提交任务给线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskNumber</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskNumber + <span class="string">&quot; 执行中...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskNumber + <span class="string">&quot; 执行完毕&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕，等待线程池任务执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f2c60ba3d5a1d7e6b20c.png" alt="image-20250225101032535"></p>
<h3 id="面试官：ThreadPoolExecutor的核心参数有哪些？（高频）"><a href="#面试官：ThreadPoolExecutor的核心参数有哪些？（高频）" class="headerlink" title="面试官：ThreadPoolExecutor的核心参数有哪些？（高频）"></a><strong>面试官</strong>：ThreadPoolExecutor的核心参数有哪些？<code>（高频）</code></h3><p><strong>候选人</strong>：<code>ThreadPoolExecutor</code> 类中提供的四个构造⽅法。我们来看最⻓的那个，其余三个都是在这个构造⽅法的基础上产⽣（其他⼏个构造⽅法说⽩点都是给定某些默认参数的构造⽅法⽐如默认制定拒绝策略是什么）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⽤给定的初始参数创建⼀个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize , maximumPoolSize , keepAliveTime , milliseconds , runnableTaskQueue , handler);</span><br></pre></td></tr></table></figure>

<p>在线程池中一共有7个核心参数：</p>
<ol>
<li><strong>corePoolSize （线程池的基本大小）</strong> - 核⼼线程数定义了最⼩可以同时运⾏的线程数量</li>
<li><strong>maximumPoolSize （线程池最大数量）</strong> - 线程池允许创建的最大线程数。最大线程数目&#x3D;核心线程+救急线程的最大数目</li>
<li>keepAliveTime （线程活动保持时间） - 线程池的工作线程空闲后，保持存活的时间</li>
<li>timeUnit （线程活动保持时间的单位） - 如秒、毫秒等</li>
<li><strong>runnableTaskQueue （任务队列）</strong> - 用于保存等待执行的任务的阻塞队列</li>
</ol>
<blockquote>
<p>在多线程环境下，<strong>两个线程是有可能拿到同一个任务的</strong>，如果任务是存储在 <strong>线程安全的队列</strong>（如 <code>BlockingQueue</code>）中，并且线程通过 <code>poll()</code> 或 <code>take()</code> 方式消费任务，那么 <strong>同一个任务不会被多个线程同时拿到</strong>，因为 <code>poll()</code> 或 <code>take()</code> 操作是原子的。示例：使用 <code>LinkedBlockingQueue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueueExample</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     BlockingQueue&lt;String&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">     taskQueue.add(<span class="string">&quot;Task1&quot;</span>);</span><br><span class="line">     taskQueue.add(<span class="string">&quot;Task2&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> taskQueue.take(); <span class="comment">// 保证同一个任务不会被两个线程拿到</span></span><br><span class="line">             System.out.println(Thread.currentThread().getName() + <span class="string">&quot; processing &quot;</span> + task);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     executor.execute(worker);</span><br><span class="line">     executor.execute(worker);</span><br><span class="line"></span><br><span class="line">     executor.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>《Java 并发编程的艺术》 9.2.1节  详情见本模块最后一个issue…</p>
<p>可以选择以下几个阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue:一个基于数组结构的有界阻塞队列，此队列按 FIFO(先进先出)原则对元素进行排序。</li>
<li>LinkedBlockingQueue:一个基于链表结构的无界阻塞队列，此队列按 FIFO 排序元素，吞吐量通常要高于 ArrayBlockingQueue。</li>
</ul>
</blockquote>
<ol start="6">
<li><p>threadFactory （线程工厂） - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p>
</li>
<li><p>handler （拒绝策略） - 当队列和线程池都满时，会触发拒绝策略（默认策略是AbortPolicy，表明无法处理新任务时抛出异常）</p>
</li>
</ol>
<blockquote>
<p>《Java 并发编程的艺术》9.2.1节</p>
<p>在jdk1.5中Java线程池框架提供了以下4种拒绝策略。<code>（高频）</code></p>
<ul>
<li><strong>AbortPolicy</strong>: 当线程池无法接受新任务时，直接抛出异常。</li>
<li><strong>CallerRunsPolicy</strong>: 它会将被拒绝的任务回退给提交任务的线程执行。</li>
<li><strong>DiscardPolicy</strong>: 它会直接丢弃无法处理的任务，并且不会抛出任何异常。</li>
<li><strong>DiscardOldestPolicy</strong>: 它会丢弃任务队列中最旧的任务（即等待时间最长的任务），然后尝试重新提交当前任务。</li>
</ul>
</blockquote>
<hr>
<h3 id="面试官：线程池的执行原理知道吗？"><a href="#面试官：线程池的执行原理知道吗？" class="headerlink" title="面试官：线程池的执行原理知道吗？"></a><strong>面试官</strong>：线程池的执行原理知道吗？</h3><p><strong>候选人</strong>：当提交一个新任务到线程池时，线程池的处理流程如下。</p>
<p>1)<strong>线程池判断核心线程池里的线程是否都在执行任务。</strong> 如果不是，则创建一个新的工作线程（核心线程）来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</p>
<p>2)<strong>线程池判断工作队列是否已经满。</strong> 如果工作队列没有满，则将新提交的任务存储在这个任务队列里。如果任务队列满了，则进入下个流程。</p>
<p>3)<strong>线程池判断线程池的线程是否都处于工作状态。</strong> 如果没有，则创建一个新的救急线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</p>
<p>4)如果<strong>核心线程或救急线程</strong>完成任务，会检查任务队列中是否有需要执行的任务，如果有就<strong>核心线程或救急线程</strong>会执行任务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f3210ba3d5a1d7e6b22d.png" alt="image-20250225101113270"></p>
<blockquote>
<p><strong>追问：</strong> 线程池的coreSize是16，maxSize是20，队列大小是10，现在已经有16个任务在运行，这时第17个任务来了之后会怎么做？那如果是第31个任务来了后发生什么？</p>
<ul>
<li><p>当第17个任务到来时，由于<strong>核心线程已满（1-16）且队列未满（17-26）</strong>，任务会被放入队列等待执行。</p>
</li>
<li><p>当第31个任务到来时，核心线程已满（1-16），队列也已满（17-26），<strong>由于最大线程数为20，线程池会创建额外的线程来执行任务，直到线程数达到20（27-30）</strong>。当第31个任务到来时，任务会根据<strong>拒绝策略</strong>处理，默认情况下会抛出 RejectedExecutionException。</p>
</li>
</ul>
</blockquote>
<hr>
<h3 id="面试官：为什么不建议使用Executors创建线程池呢？"><a href="#面试官：为什么不建议使用Executors创建线程池呢？" class="headerlink" title="面试官：为什么不建议使用Executors创建线程池呢？"></a><strong>面试官</strong>：为什么不建议使用Executors创建线程池呢？</h3><p><strong>候选人</strong>：</p>
<p>好的，其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了。</p>
<p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是<strong>Integer.MAX_VALUE</strong>，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p>
<p>所以，我们一般推荐使用<strong>ThreadPoolExecutor</strong>来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p>
<hr>
<h3 id="面试官：-执⾏execute-⽅法和submit-⽅法的区别是什么呢？"><a href="#面试官：-执⾏execute-⽅法和submit-⽅法的区别是什么呢？" class="headerlink" title="面试官： 执⾏execute()⽅法和submit()⽅法的区别是什么呢？"></a><strong>面试官</strong>： 执⾏execute()⽅法和submit()⽅法的区别是什么呢？</h3><p><strong>候选人：</strong></p>
<ol>
<li><strong>execute()</strong> ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与否；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>submit()</strong> ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 get() ⽅法来获取返回值， get() ⽅法会阻塞当前线程直到任务完成，⽽使⽤ get（long timeout ，TimeUnitunit）⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏完。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                <span class="comment">// 处理中断异常</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">                <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                executor.shutdown();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<h3 id="面试官：Java-里的阻塞队列都有哪些？能简单说说吗？"><a href="#面试官：Java-里的阻塞队列都有哪些？能简单说说吗？" class="headerlink" title="面试官：Java 里的阻塞队列都有哪些？能简单说说吗？"></a><strong>面试官</strong>：Java 里的阻塞队列都有哪些？能简单说说吗？</h3><p><strong>候选人：</strong>（源自《Java并发编程的艺术》 6.3.2节）</p>
<p>JDK7提供了7个阻塞队列，如下。</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<p>下面重点介绍3类阻塞队列，其他的队列还请大家自行查阅书籍网站（没有先后次序之分）。</p>
<ol>
<li><p><strong>ArrayBlockingQueue</strong></p>
<p>ArrayBlockingQueue是一个用数组实现的<strong>有界阻塞队列</strong>。此队列按照先进先出(FIFO)的原则对元素进行排序。</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>LinkedBlockingQueue 是一个用链表实现的<strong>无界阻塞队列</strong>。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出(FIFO)的原则对元素进行排序。</p>
</li>
<li><p><strong>LinkedBlockingDeque</strong></p>
<p>LinkedBlockingDeque 是一个由链表结构组成的<strong>双向阻塞队列</strong>。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p>
</li>
</ol>
<h2 id="4-线程使用场景问题"><a href="#4-线程使用场景问题" class="headerlink" title="4 线程使用场景问题"></a>4 线程使用场景问题</h2><h3 id="面试官：如果控制某一个方法允许并发访问线程的数量？"><a href="#面试官：如果控制某一个方法允许并发访问线程的数量？" class="headerlink" title="面试官：如果控制某一个方法允许并发访问线程的数量？"></a><strong>面试官</strong>：如果控制某一个方法允许并发访问线程的数量？</h3><p><strong>候选人</strong>：</p>
<p>在jdk中提供了一个Semaphore类（信号量）</p>
<p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p>
<p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p>
<h3 id="面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？"><a href="#面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？" class="headerlink" title="面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？"></a><strong>面试官</strong>：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</h3><p><strong>候选人</strong>：</p>
<p>嗯，刚才讲过了导致线程安全的原因。要解决多线程环境下的执行安全问题，JDK提供了多种工具和机制来帮助我们：</p>
<ul>
<li><strong>原子性问题</strong>：可以通过使用<code>java.util.concurrent.atomic</code>包下的原子类（如<code>AtomicInteger</code>、<code>AtomicLong</code>等）来解决。此外，<code>synchronized</code>关键字和<code>ReentrantLock</code>也可以用来确保代码块的原子性执行。</li>
<li><strong>可见性问题</strong>：<code>synchronized</code>关键字和<code>volatile</code>关键字都可以用来确保一个线程对共享变量的修改能够被其他线程看到。使用显式锁（如<code>ReentrantLock</code>）时，配合<code>Condition</code>对象也可以保证可见性。</li>
<li><strong>有序性问题</strong>：通过遵循<code>Happens-Before</code>规则，可以保证多线程环境下操作的有序性。<code>synchronized</code>关键字和<code>volatile</code>关键字同样可以用来保证有序性。</li>
</ul>
<hr>
<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h2><h3 id="面试官：介绍下Fork-Join框架（工作窃取算法）"><a href="#面试官：介绍下Fork-Join框架（工作窃取算法）" class="headerlink" title="面试官：介绍下Fork&#x2F;Join框架（工作窃取算法）"></a><strong>面试官</strong>：介绍下Fork&#x2F;Join框架（工作窃取算法）</h3><p><strong>候选人</strong>：（源自《Java并发编程艺术》6.4.1节）</p>
<p><strong>Fork&#x2F;Join</strong> 框架是 Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>我们再通过 Fork 和 Join 这两个单词来理解一下 <strong>Fork&#x2F;Join</strong> 框架。Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算 1+2+…+10000，可以分割成 10个子任务，每个子任务分别对 1000个数进行求和，最终汇总这10个子任务的结果。Fork &#x2F;Join的运行流程图如图4-5所示。（图源《Java程序员面试笔试宝典》第二版 4.18节）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f3850ba3d5a1d7e6b23c.png" alt="image-20250225101236776"></p>
<p>这种模型内部使用了线程池来执行各个子任务，它的工作原理为:线程池中的每个线程都有自己的工作队列，当自己队列中的任务都完成以后，会从其他线程的工作队列中“偷”一个任务执行，这样可以充分利用资源，这种思想被称为<strong>工作窃取算法</strong>(work-stealing)。执行流程如图 4-6 所示。（本段文字图片皆源自《Java程序员面试笔试宝典》第二版 4.18节）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f38e0ba3d5a1d7e6b23d.png" alt="image-20250225101247917"></p>
<p>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用<strong>双端队列</strong>，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<blockquote>
<p>扩展：<strong>工作窃取算法的优缺点？</strong></p>
<p>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时，并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
</blockquote>
<h3 id="面试官：讲一下JMM-Java内存模型"><a href="#面试官：讲一下JMM-Java内存模型" class="headerlink" title="面试官：讲一下JMM(Java内存模型)"></a><strong>面试官</strong>：讲一下JMM(Java内存模型)</h3><p><strong>候选人</strong>：</p>
<ul>
<li>Java线程间的通信由JMM控制，JMM定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作，从而保证指令的准确性，内存可见性。</li>
</ul>
<blockquote>
<p>《Java并发编程的艺术》 3.1.3节</p>
<p>JMM 属于语言级的内在模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
</blockquote>
<ul>
<li>JMM把内存分成两块，一块是本地内存，一块是主内存。</li>
<li>线程跟线程之间相互隔离，线程跟线程交互需要通过主内存。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e8f3b70ba3d5a1d7e6b242.png" alt="image-20250225101305060"></p>
<hr>
<h3 id="面试官：JMM-可能会导致数据不一致？怎么理解？"><a href="#面试官：JMM-可能会导致数据不一致？怎么理解？" class="headerlink" title="面试官：JMM 可能会导致数据不一致？怎么理解？"></a><strong>面试官</strong>：JMM 可能会导致数据不一致？怎么理解？</h3><p><strong>候选人：</strong></p>
<p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进⾏特别的注意的。⽽在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（⽐如机器的寄存器）中，⽽不是直接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使⽤它在寄存器中的变量值的拷⻉，造成<strong>数据的不⼀致</strong>。</p>
<p>要解决这个问题，可以把变量声明为 <strong>volatile</strong> ，这就指示 JVM 这个变量是共享且不稳定的，每次使⽤它都到主存中进⾏读取。保证变量的可⻅性。</p>
<hr>
<h3 id="面试官：聊聊happens-before与JMM的关系？"><a href="#面试官：聊聊happens-before与JMM的关系？" class="headerlink" title="面试官：聊聊happens-before与JMM的关系？"></a><strong>面试官</strong>：聊聊happens-before与JMM的关系？</h3><p><strong>候选人：</strong> happens-before是JMM最核心的概念。对应Java程序员来说，理解happens-before是理解JMM的关键。</p>
<p>JSR-133 使用 happens-before 的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM 可以通过happens-before 关系向程序员提供<strong>跨线程的内存可见性保证</strong>(如果A线程的写操作a与B线程的读操作b之间存在 happens-before 关系，尽管a操作和b操作在不同的线程中执行，但 JMM 向程序员保证a操作将对 b操作可见)。</p>
<blockquote>
<p>《JSR-133: Java Memory Model and Thread Specification》对happens-before 关系的定义如下。</p>
<ol>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before关系来执行的结果一致，那么这种重排序并不非法(也就是说，JMM 允许这种重排序)。</li>
</ol>
</blockquote>
<hr>
<h3 id="面试官：你知道happens-before有哪些应用场景吗？"><a href="#面试官：你知道happens-before有哪些应用场景吗？" class="headerlink" title="面试官：你知道happens-before有哪些应用场景吗？"></a><strong>面试官</strong>：你知道happens-before有哪些应用场景吗？</h3><p><strong>候选人：<strong>happens-before 的应用场景主要是在多线程编程中，用于确保线程之间的</strong>操作顺序和可见性</strong>。以下是一些常见的应用场景：</p>
<ul>
<li><p>线程同步：happens-before 可以用于保证线程之间的同步操作的正确性。例如，在使用 synchronized 或 Lock 机制进行线程同步时，happens-before规则可以确保一个线程的<strong>解锁操作 happens-before 后续线程的加锁操作</strong>，从而保证线程之间的同步性。</p>
</li>
<li><p>volatile 变量：happens-before 可以用于保证对 volatile 变量的写操作对后续线程的读操作可见。因为 volatile 变量具有可见性，所以对一个 volatile 变量的<strong>写操作 happens-before 后续线程对该变量的读操作</strong>，确保了变量的可见性。</p>
</li>
<li><p>线程间通信：happens-before 可以用于确保线程间通信的正确性。例如，使用 wait&#x2F;notify 或 await&#x2F;signal 机制进行线程间的等待和唤醒操作时，happens-before 可以确保等待线程在<strong>接收通知之前必须看到发送通知的线程对共享数据的修改</strong>。</p>
</li>
<li><p>线程安全性：happens-before 可以用于保证线程安全性。例如，在使用 synchronized 或 Lock 机制保护共享资源时，happens-before 可以确保一个线程的写操作 happens-before 后续线程的读操作，从而保证线程安全。</p>
</li>
<li><p>线程的启动和终止：happens-before 可以用于确保线程的启动操作 happens-before 后续线程的操作，以及线程的终止操作 happens-before 其他线程对该线程的操作。</p>
</li>
</ul>
<hr>
<h3 id="面试官：谈谈你对ThreadLocal的理解"><a href="#面试官：谈谈你对ThreadLocal的理解" class="headerlink" title="面试官：谈谈你对ThreadLocal的理解"></a><strong>面试官</strong>：谈谈你对ThreadLocal的理解</h3><p><strong>候选人</strong>：</p>
<p>通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现<strong>每⼀个线程都有⾃⼰的专属本地变量</strong>该如何解决呢？ JDK 中提供的 ThreadLocal 类正是为了解决这样的问题。</p>
<p>ThreadLocal 类主要解决的就是让每个线程绑定⾃⼰的值，可以将 ThreadLocal 类形象的⽐喻成存放数据的盒⼦，盒⼦中可以存储每个线程的私有数据。从而避免了线程间竞争的安全问题。</p>
<blockquote>
<p>《Java并发编程的艺术》 4.3.6节</p>
<p>ThreadLocal，即线程变量，是一个以 ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal对象查询到绑定在这个线程上的一个值。可以通过 set(T)方法来设置一个值，在当前线程下再通过 get()方法获取到原先设置的值。</p>
</blockquote>
<hr>
<h3 id="面试官：好的，那你知道ThreadLocal的底层原理实现吗？"><a href="#面试官：好的，那你知道ThreadLocal的底层原理实现吗？" class="headerlink" title="面试官：好的，那你知道ThreadLocal的底层原理实现吗？"></a><strong>面试官</strong>：好的，那你知道ThreadLocal的底层原理实现吗？</h3><p><strong>候选人</strong>：</p>
<p>在ThreadLocal内部维护了一个 ThreadLocalMap 类型的成员变量，用来存储资源对象。</p>
<ul>
<li><p>当调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，<strong>放入</strong>当前线程的 ThreadLocalMap 集合中。</p>
</li>
<li><p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中<strong>查找</strong>关联的资源值。</p>
</li>
<li><p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，<strong>移除</strong>当前线程关联的资源值。</p>
</li>
</ul>
<hr>
<h3 id="面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？"><a href="#面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？" class="headerlink" title="面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？"></a><strong>面试官</strong>：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</h3><p><strong>候选人</strong>：</p>
<p>因为ThreadLocalMap 中的 key 被设计为<strong>弱引用</strong>（使用弱引用的目的在于节约资源），而value是一个<strong>强引用</strong>。所以在垃圾回收的时候，key 会被清理掉，⽽ value 不会被清理掉。这样⼀来， ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远⽆法被 GC 回收，这个时候就可能会产⽣内存泄露（OOM）。</p>
<p>ThreadLocalMap 实现中已经考虑了这种情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null的记录。使⽤完 ThreadLocal ⽅法后 最好⼿动调⽤ remove() 释放key。</p>
<blockquote>
<p>拓展：强引用与弱引用（《深入理解Java虚拟机：JVM高级特性与最佳实践》）</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“ Object obj &#x3D; new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
</ul>
</blockquote>
<hr>
<h3 id="面试官：跨线程传递ThreadLocal的问题"><a href="#面试官：跨线程传递ThreadLocal的问题" class="headerlink" title="面试官：跨线程传递ThreadLocal的问题"></a><strong>面试官</strong>：跨线程传递ThreadLocal的问题</h3><p><strong>候选人：</strong></p>
<p>在Java中，<code>ThreadLocal</code> 提供了线程本地变量，通常用于存储线程独有的数据，避免线程间的资源竞争。然而，<code>ThreadLocal</code> 的数据只能在当前线程中访问，跨线程时数据无法直接传递。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><strong>使用 <code>InheritableThreadLocal</code></strong><ul>
<li><code>InheritableThreadLocal</code> 允许父线程的数据传递到子线程。它在创建子线程时会复制父线程的值。</li>
<li>适用于简单的父子线程场景。</li>
<li><strong>注意</strong>：数据是引用传递，如果子线程修改了数据，父线程的数据会受到影响。</li>
</ul>
</li>
<li><strong>使用 <code>TransmittableThreadLocal</code> (TTL)</strong><ul>
<li>针对线程池等复杂场景，可以使用阿里巴巴的<strong>TTL</strong>组件。</li>
<li><code>TransmittableThreadLocal</code> 在任务提交到线程池前会备份当前线程的 <code>ThreadLocal</code> 数据，并在任务执行时恢复。</li>
<li>常用于分布式追踪、日志上下文等场景。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">miahemu</div><div class="post-copyright__author_desc">Hi~同行者</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/03/30/JUC相关面试题/')">JUC相关面试题</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://i.miji.bid/2025/03/23/eeafc8609ad2edbb8e7112ced837d7f4.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://i.miji.bid/2025/03/29/81b165cb796725599ea7e82472ce9896.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">和睦的拾光物语</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JAVA%E9%9D%A2%E7%BB%8F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JAVA面经<span class="tagsPageCount">11</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/j3/wallhaven-j3rgqw.jpg" data-sites="facebook,twitter,wechat,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/nm/wallhaven-nmd8lm.png" onerror="onerror=null;src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM相关面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/nm/wallhaven-nmd8lm.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-30</div><div class="title">JVM相关面试题</div></div></a></div><div><a href="/2025/03/22/JavaSE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JavaSE相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/l8/wallhaven-l8ejkp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-22</div><div class="title">JavaSE相关面试题</div></div></a></div><div><a href="/2025/03/23/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/qz/wallhaven-qzwme5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-23</div><div class="title">Java集合相关面试题</div></div></a></div><div><a href="/2025/03/29/Linux%E3%80%81Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux、Git常用命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/96/wallhaven-96lx71.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-29</div><div class="title">Linux、Git常用命令</div></div></a></div><div><a href="/2025/03/24/MySQL%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="MySQL相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/ym/wallhaven-ym22lk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-24</div><div class="title">MySQL相关面试题</div></div></a></div><div><a href="/2025/03/25/Redis%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Redis相关面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/xl/wallhaven-xl8p9d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-25</div><div class="title">Redis相关面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">🌙惟信道而且行善，并以真理相劝，以坚忍相勉的人则不然。<br>----时光章[103:3]</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">miahemu</h1><div class="author-info__desc">Hi~同行者</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/miahemu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1046498117" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">1.屏幕太大功能显示不全的话，可以手动"ctrl + -"来缩放页面。  2.网页右上角换至深色主题效果更佳✨   3.网页左下角可以播放音乐哦☀️</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">1 线程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%81%8A%E4%B8%80%E4%B8%8B%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">面试官：聊一下并行和并发有什么区别？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">面试官：说一下线程和进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E2%BD%82%E5%88%87%E6%8D%A2-%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">面试官：什么是线程上下⽂切换?（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E2%BD%82%E5%88%87%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">面试官：如何减少上下⽂切换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">面试官： 同步和异步的区别？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%9C%A8java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">面试官：如果在java中创建线程有哪些方式？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E7%9A%84runnable-%E5%92%8C-callable-%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">面试官：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">面试官：线程的生命周期和状态？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4sleep-%E2%BD%85%E6%B3%95%E5%92%8Cwait-%E2%BD%85%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.9.</span> <span class="toc-text">面试官：说说sleep()⽅法和wait()⽅法区别和共同点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E6%88%91%E7%8E%B0%E5%9C%A8%E4%B8%BE%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%BD%A0%E6%9D%A5%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%96%B0%E5%BB%BA-T1%E3%80%81T2%E3%80%81T3-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">面试官：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%9C%A8%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%E3%80%82%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">面试官：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E9%82%A3%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">面试官：那如何停止一个正在运行的线程呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E5%8F%91%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">2 线程中并发锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">面试官：说一下公平锁与非公平锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">面试官：说一下悲观锁与乐观锁的区别？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8Bsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">面试官：讲一下synchronized关键字的底层原理？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E8%83%BD%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%8BMonitor-%E5%90%97%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">面试官：你能具体说下Monitor 吗？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4%E2%BE%83%E2%BC%B0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E2%BD%A4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">面试官：说说⾃⼰是怎么使⽤ synchronized 关键字的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9D%A5%E7%BB%99%E6%88%91%E2%BC%BF%E5%86%99%E2%BC%80%E4%B8%8B%EF%BC%81%E7%BB%99%E6%88%91%E8%A7%A3%E9%87%8A%E2%BC%80%E4%B8%8B%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E2%BD%85%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%91%97%EF%BC%81"><span class="toc-number">2.6.</span> <span class="toc-text">面试官：单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%85%B3%E4%BA%8Esynchronized-%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">面试官：关于synchronized 的锁升级的情况了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E4%BA%86synchronized%E5%AE%83%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%80%A7%E8%83%BD%E4%B8%8D%E9%AB%98%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E4%BD%BF%E7%94%A8%E9%94%81%E5%91%A2%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%8BReentrantLock%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">面试官：说下ReentrantLock的使用方式和底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E4%BA%86CAS%E5%92%8CAQS%EF%BC%8C%E4%BD%A0%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">面试官：刚才你说了CAS和AQS，你能介绍一下吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AAQS%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88Semaphore%E3%80%81CountDownLatch%E3%80%81CyclicBarrier%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">面试官：AQS对资源的共享方式（Semaphore、CountDownLatch、CyclicBarrier）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9ACyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.12.</span> <span class="toc-text">面试官：CyclicBarrier和CountDownLatch的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9Asynchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.13.</span> <span class="toc-text">面试官：synchronized和Lock有什么区别 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4Synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">面试官：说说Synchronized和ReentrantLock的区别（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-volatile-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.15.</span> <span class="toc-text">面试官：请谈谈你对 volatile 的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.</span> <span class="toc-text">3 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E2%BD%A4%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">面试官： 为什么要⽤线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9B%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">面试官：线程池四种创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AThreadPoolExecutor%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">面试官：ThreadPoolExecutor的核心参数有哪些？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">面试官：线程池的执行原理知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%A2%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">面试官：为什么不建议使用Executors创建线程池呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E6%89%A7%E2%BE%8Fexecute-%E2%BD%85%E6%B3%95%E5%92%8Csubmit-%E2%BD%85%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">面试官： 执⾏execute()⽅法和submit()⽅法的区别是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AJava-%E9%87%8C%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">面试官：Java 里的阻塞队列都有哪些？能简单说说吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">4 线程使用场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">面试官：如果控制某一个方法允许并发访问线程的数量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Java%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%A7%E8%A1%8C%E5%AE%89%E5%85%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96"><span class="toc-number">5.</span> <span class="toc-text">5 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BB%8B%E7%BB%8D%E4%B8%8BFork-Join%E6%A1%86%E6%9E%B6%EF%BC%88%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">面试官：介绍下Fork&#x2F;Join框架（工作窃取算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BJMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">面试官：讲一下JMM(Java内存模型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9AJMM-%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%9F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">面试官：JMM 可能会导致数据不一致？怎么理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%81%8A%E8%81%8Ahappens-before%E4%B8%8EJMM%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">面试官：聊聊happens-before与JMM的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93happens-before%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%90%97%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">面试官：你知道happens-before有哪些应用场景吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.6.</span> <span class="toc-text">面试官：谈谈你对ThreadLocal的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E4%BD%A0%E7%9F%A5%E9%81%93ThreadLocal%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">面试官：好的，那你知道ThreadLocal的底层原理实现吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E5%85%B3%E4%BA%8EThreadLocal%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%BF%99%E4%B8%AA%E4%BA%8B%E6%83%85%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%B7%A8%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92ThreadLocal%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.9.</span> <span class="toc-text">面试官：跨线程传递ThreadLocal的问题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC相关面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/j3/wallhaven-j3rgqw.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="JUC相关面试题"/></a><div class="content"><a class="title" href="/2025/03/30/JUC%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC相关面试题">JUC相关面试题</a><time datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM相关面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/nm/wallhaven-nmd8lm.png" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="JVM相关面试题"/></a><div class="content"><a class="title" href="/2025/03/30/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM相关面试题">JVM相关面试题</a><time datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/%E5%B8%B8%E8%A7%81%E7%9A%84HR%E9%9D%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="常见的HR面问题汇总"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/wy/wallhaven-wyxq97.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="常见的HR面问题汇总"/></a><div class="content"><a class="title" href="/2025/03/30/%E5%B8%B8%E8%A7%81%E7%9A%84HR%E9%9D%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="常见的HR面问题汇总">常见的HR面问题汇总</a><time datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/Linux%E3%80%81Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux、Git常用命令"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/96/wallhaven-96lx71.png" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="Linux、Git常用命令"/></a><div class="content"><a class="title" href="/2025/03/29/Linux%E3%80%81Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux、Git常用命令">Linux、Git常用命令</a><time datetime="2025-03-28T16:00:00.000Z" title="发表于 2025-03-29 00:00:00">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/%E5%8D%81%E9%81%93%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E5%8D%81%E4%B8%AA%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="十道海量数据处理面试题与十个方法总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://w.wallhaven.cc/full/47/wallhaven-47v5vy.jpg" onerror="this.onerror=null;this.src='https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg'" alt="十道海量数据处理面试题与十个方法总结"/></a><div class="content"><a class="title" href="/2025/03/29/%E5%8D%81%E9%81%93%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E5%8D%81%E4%B8%AA%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="十道海量数据处理面试题与十个方法总结">十道海量数据处理面试题与十个方法总结</a><time datetime="2025-03-28T16:00:00.000Z" title="发表于 2025-03-29 00:00:00">2025-03-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://mail.qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67e6c7490ba3d5a1d7e5c8f7.png" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://miahemu.github.io/" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="miahemu" target="_blank">miahemu</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["心怀信仰&#44; 步步生光&#44; 主恩常在&#44; 万物蒙福."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://miahemu.github.io" title="Allah will bless you☘️">Allah will bless you☘️</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/miahemu" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="力扣"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="力扣"/><span class="back-menu-item-text">力扣</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://leetcode.cn/u/lu-ren-r41/" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://miahemu.github.io/about/" title="个人简介"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://w.wallhaven.cc/full/jx/wallhaven-jx6yj5.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人简介"/><span class="back-menu-item-text">个人简介</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9460279562&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 小挂件</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/weather/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 天气</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JAVA%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">JAVA面经<sup>11</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">数据结构与算法<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AF%95/" style="font-size: 0.88rem;">笔试<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="9461259355" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("2025/3/22 07:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 miahemu 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("2025/3/22 07:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><div class="aplayer no-destroy" data-id="565851830" data-server="netease" data-type="song" data-mini="true" data-autoplay="true" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>